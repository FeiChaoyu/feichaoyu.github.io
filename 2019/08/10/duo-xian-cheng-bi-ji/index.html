<!DOCTYPE HTML>
<html lang="zh-CN">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Java多线程编程核心技术读书笔记, golang,go语言,feichaoyu,java,Spring,Spring Boot,博客,软件架构">
    <meta name="description" content="总结了《Java多线程编程核心技术》的知识点">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Java多线程编程核心技术读书笔记 | feichaoyu</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">
    
    <script src="/libs/jquery/jquery.min.js"></script>
    
<meta name="generator" content="Hexo 4.2.0"><link rel="alternate" href="/atom.xml" title="feichaoyu" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">feichaoyu</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>留言板</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>

<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">feichaoyu</div>
        <div class="logo-desc">
            
            专注于IT互联网，包括但不限于Go、Java、项目管理、软件架构、分布式系统等
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			留言板
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
    </ul>
</div>

        </div>

        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/18.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Java多线程编程核心技术读书笔记</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #toc-content .is-active-link::before {
        background-color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                                <span class="chip bg-color">多线程</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Java/" class="post-category">
                                Java
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2019-08-10
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2019-09-28
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    13k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    58 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>

        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <h2 id="一、多线程基础"><a href="#一、多线程基础" class="headerlink" title="一、多线程基础"></a>一、多线程基础</h2><h3 id="1-实现多线程的三种方式"><a href="#1-实现多线程的三种方式" class="headerlink" title="1.实现多线程的三种方式"></a>1.实现多线程的三种方式</h3><p>①继承Thread类</p>
<pre><code>public class MyThread extends Thread {
    @Override
    public void run() {
        super.run();
        //......
    }
}

//使用MyThread
MyThread thread = new MyThread();
thread.start();</code></pre><p>②实现Runnable接口</p>
<pre><code>public class MyRunnable implements Runnable {
    @Override
    public void run() {
        //......
    }
}

//使用MyRunnable
Runnable runnable = new MyRunnable();
Thread thread = new Thread(runnable);
thread.start();</code></pre><p>比较这两个方法，用实现<code>Runnable</code>接口的优点在于，如果线程类已经有一个父类了，这时不能再继承自<code>Thread</code>类了，因为Java不支持多继承，但是可以实现<code>Runnable</code>接口来处理。</p>
<p>由于<code>Thread</code>类也实现了<code>Runnable</code>接口，所以构造函数<code>Thread(Runnable target)</code>不光可以传入<code>Runnable</code>接口的对象，还可以传入<code>Thread</code>类的对象，这告诉我们，可以把一个<code>Thread</code>对象中的<code>run</code>方法交给其他线程调用。</p>
<p>③实现Callable接口</p>
<pre><code>public class MyThread implements Callable {
    @Override
    public Object call() throws Exception {
        try {
            Thread.sleep(1000);
        }catch (InterruptedException e){
            e.printStackTrace();
        }
        System.out.println("这是线程B");
        return "thread B";
    }
}

public class Run {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        FutureTask futureTask = new FutureTask(myThread);
        new Thread(futureTask).start();
        System.out.println("这是主线程：begin");
        try {
            System.out.println("返回结果："+futureTask.get());
        }catch (InterruptedException e){
            e.printStackTrace();
        } catch (ExecutionException e) {
            e.printStackTrace();
        }
        System.out.println("这是主线程：end");
    }
}

//输出：
这是主线程：begin
这是线程B
返回结果：thread B
这是主线程：end</code></pre><h3 id="2-实例变量的线程安全"><a href="#2-实例变量的线程安全" class="headerlink" title="2.实例变量的线程安全"></a>2.实例变量的线程安全</h3><p>多线程安全问题三要素: </p>
<ul>
<li><p>是否存在多线程环境</p>
</li>
<li><p>是否存在共享的数据</p>
</li>
<li><p>是否有多条语句同时操作这条数据</p>
</li>
</ul>
<p>经典的抢票示例</p>
<pre><code>public class MyThread extends Thread {
    private int count=5;
    @Override
    synchronized public void run() {
        super.run();
        count--;
        System.out.println(this.currentThread().getName()+" count="+count);
    }
}

public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread a = new Thread(myThread, "A");
        Thread b = new Thread(myThread, "B");
        Thread c = new Thread(myThread, "C");
        Thread d = new Thread(myThread, "D");
        Thread e = new Thread(myThread, "E");
        a.start();
        b.start();
        c.start();
        d.start();
        e.start();
}

//打印输出
A count=4
D count=3
E count=2
C count=1
B count=0</code></pre><p>通过在<code>run</code>方法前加入<code>synchronized</code>关键字后，多个线程会排队处理。当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果拿到了这把锁，那么这个线程就可以执行<code>synchronized</code>里面的代码，否则多个线程会同时去抢这把锁。</p>
<p>打印语句是线程安全的，但是如果在打印语句中加入某些在打印之前执行的操作，可能会非线程安全。</p>
<p>如果将线程对象以构造参数的方式传递给<code>Thread</code>对象时，<code>Thread.currentThread()</code>和<code>this</code>是不同的</p>
<h3 id="3-停止线程的方法"><a href="#3-停止线程的方法" class="headerlink" title="3.停止线程的方法"></a>3.停止线程的方法</h3><p>（1）使用退出标志，当<code>run</code>方法完成中止线程</p>
<pre><code>public class RunThread extends Thread {
    //退出标志
    private boolean isRunning = true;

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean isRunning) {
        this.isRunning = isRunning;
    }

    @Override
    public void run() {
        System.out.println("进入run了");
        while (isRunning == true) {
            System.out.println(Thread.currentThread().getName());
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

public class Run {
    public static void main(String[] args) {
        try {
            RunThread thread = new RunThread();
            thread.start();
            Thread.sleep(5000);
            thread.setRunning(false);
            System.out.println("退出");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p>（2）使用interrupt中断线程（还需要其他条件）</p>
<p>判断线程停止的方法：</p>
<ul>
<li><p>interrupted()方法：测试<strong>当前线程</strong>是否是中断状态，执行完后变为false</p>
<pre><code>public static boolean interrupted() {
        return currentThread().isInterrupted(true);
}</code></pre></li>
<li><p>isinterrupted()方法：测试线程Thread对象是否已经是中断状态，默认不清除状态标志,可以通过重载方法设置清除</p>
<pre><code>public boolean isInterrupted() {
        return isInterrupted(false);
}</code></pre><p>①异常法</p>
<pre><code>public class MyThread extends Thread {
    @Override
    public void run() {
        super.run();
        try {
            for (int i = 0; i &lt; 500_000; i++) {
                if (this.isInterrupted()) {
                    System.out.println("已经停止，我要退出");
                    throw new InterruptedException();
                }
                System.out.println("i="+(i+1));
            }
        } catch (InterruptedException e) {
            System.out.println("我被抓了");
            e.printStackTrace();
        }
    }
}</code></pre><p>②return法</p>
<pre><code>public class MyThread extends Thread {
    @Override
    public void run() {
        super.run();
        while (true){
            if (this.isInterrupted()){
                System.out.println("停止");
                return;
            }
        }
    }
}</code></pre><p>建议使用异常法来停止线程，因为异常可以向上抛，使事件得到传播。</p>
</li>
</ul>
<h3 id="4-线程的暂停和恢复"><a href="#4-线程的暂停和恢复" class="headerlink" title="4.线程的暂停和恢复"></a>4.线程的暂停和恢复</h3><p>暂停<code>suspend()</code>，恢复<code>resume()</code></p>
<p>缺点：</p>
<ul>
<li><p>造成公共的同步对象的独占，使得其他线程无法访问公共同步对象</p>
<pre><code>public class SynchronizedObject {
    synchronized public void sameMethod(){
        if (Thread.currentThread().getName().equals("A")){
            // A线程永远suspend，其他线程无法进来
            Thread.currentThread().suspend();
        }
    }
}</code></pre></li>
<li><p>暂停导致数据不同步</p>
</li>
</ul>
<h3 id="5-线程的优先级"><a href="#5-线程的优先级" class="headerlink" title="5.线程的优先级"></a>5.线程的优先级</h3><p>Java中线程的优先级分为1~10这10个等级，如果小于1或大于10，那么会抛出异常。</p>
<p>使用3个常量来预置定义优先级的值</p>
<pre><code>public final static int MIN_PRIORITY = 1;
public final static int NORM_PRIORITY = 5;
public final static int MAX_PRIORITY = 10;</code></pre><ul>
<li><p>继承性</p>
<p>  在Java中，线程优先级具有继承性，当A线程启动B线程，那么B线程的优先级和A线程相同。当优先级被修改后再继承的话，会继承修改后的优先级</p>
</li>
<li><p>规则性</p>
<p>  高优先级总是大部分先执行完</p>
</li>
<li><p>随机性</p>
<p>  高优先级总是大部分先执行完，但不代表高优先级一定全部都先执行完</p>
</li>
</ul>
<h3 id="6-守护线程（Daemon）"><a href="#6-守护线程（Daemon）" class="headerlink" title="6.守护线程（Daemon）"></a>6.守护线程（Daemon）</h3><p>守护线程是一种特殊的线程，典型的守护线程就是垃圾回收线程（GC），当进程中不存在非守护线程了，则垃圾回收线程就会自动销毁。当最后一个非守护线程结束，守护线程才随着JVM一同结束工作。</p>
<h3 id="7-私有变量是线程安全的原因"><a href="#7-私有变量是线程安全的原因" class="headerlink" title="7.私有变量是线程安全的原因"></a>7.私有变量是线程安全的原因</h3><p>因为新建类的时候它只会为类中的成员变量开辟空间，而方法只在方法区开辟一个内存空间并且只存一份共用的代码段（变量在堆区，引用在栈区），而方法中的私有变量不会先开辟出内存空间，而是等调用时在对应调用线程中为方法中的变量申请空间，所以有几个线程调用则每个线程就会在自己的线程空间的栈为局部变量申请几个引用同时在堆中为变量再申请对应的空间（即方法内的私有变量有几个线程就在栈中申请几个引用，在堆中申请几个空间），所以多线程在调用时只会处理自己线程内的方法的私有变量，因此，方法内的私有变量是线程安全的。</p>
<h3 id="8-锁对象"><a href="#8-锁对象" class="headerlink" title="8.锁对象"></a>8.锁对象</h3><p>多个对象多把锁不是同步的，因为<code>synchronized</code>关键字取得的锁是对象锁，不是一段代码或方法当作锁，哪个线程先执行带<code>synchronized</code>的方法，哪个线程就持有该方法所属对象的锁，其他对象就只能等待，前提是多个线程访问同一个对象。</p>
<p>A线程先持有对象锁，B线程可以异步调用对象中非<code>synchronized</code>类型的方法。</p>
<p>A线程先持有对象锁，B线程如果调用对象中<code>synchronized</code>类型的其他方法则需等待，等到A线程执行完释放锁才可以调用，也就是同步。</p>
<p>只要对象不变，对象的属性改变，结果还是同步的。</p>
<h3 id="9-锁重入"><a href="#9-锁重入" class="headerlink" title="9.锁重入"></a>9.锁重入</h3><p>当一个<code>synchronized</code>方法/块的内部调用本类的其他<code>synchronized</code>方法/块时，可以得到锁。</p>
<p>当存在父子类继承关系时，子类完全可以通过“可重入锁”调用父类的同步方法。</p>
<p>这里需要注意，如果父类有<code>synchronized</code>同步方法，子类没有，那么子类是无法继承父类的synchronized的，也就是说<strong>同步无法继承</strong>。</p>
<h3 id="10-异常释放锁"><a href="#10-异常释放锁" class="headerlink" title="10.异常释放锁"></a>10.异常释放锁</h3><p>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</p>
<h3 id="11-synchronized同步代码块"><a href="#11-synchronized同步代码块" class="headerlink" title="11.synchronized同步代码块"></a>11.<code>synchronized</code>同步代码块</h3><p>用关键字<code>synchronized</code>声明的方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间任务，那么B线程必须等待比较长的时间，这种情况可以使用<code>synchronized</code>同步代码块解决。</p>
<p>同步代码块加在需要地方，如下示例</p>
<pre><code>public class Task {
    private String getData1;
    private String getData2;
    public void doLongTimeTask(){
        try {
            System.out.println("start task");
            Thread.sleep(3000);
            String privateGetData1=Thread.currentThread().getName();
            String privateGetData2=Thread.currentThread().getName();
            synchronized (this){
                getData1=privateGetData1;
                getData2=privateGetData2;
            }
            System.out.println(getData1);
            System.out.println(getData2);
            System.out.println("end task");
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}</code></pre><p>上面代码如果用原来的方法将<code>synchronized</code>加在方法上，那么执行两个线程的话，需要执行6s，但是用了<code>synchronized</code>同步代码块后，执行时间只需要3s，这是因为在<code>synchronized</code>同步代码块外的代码是异步的，这样多个线程可以去抢，并不会把Thread.sleep(3000)这条语句锁起来。</p>
<p>在使用<code>synchronized</code>同步代码块时需要注意，当一个线程访问<code>synchronized</code>同步代码块时，其他线程对同一个对象中所有其他的<code>synchronized</code>同步代码块的访问将被阻塞。</p>
<h3 id="12-任意对象锁"><a href="#12-任意对象锁" class="headerlink" title="12.任意对象锁"></a>12.任意对象锁</h3><p>之前都是使用synchronized (this)来同步代码块，其实Java还支持对任意对象作为对象监视器来实现同步功能，格式为<code>synchronized</code> (非this对象)</p>
<p>锁非this对象的好处是：<code>synchronized</code> (非<code>this</code>对象)代码块中的程序与其他同步方法是异步的，不会和其他锁<code>this</code>同步方法争抢<code>this</code>锁，因为我可以创建很多对象，这些对象锁之间是异步的，但是需要注意，对象一定在方法外部，这样才能确保用的是同一个对象锁。</p>
<p>有如下示例</p>
<pre><code>public class Example {
    private Object anyObject = new Object();
    public void a(){
        try {
            synchronized (anyObject){
                System.out.println("a begin");
                Thread.sleep(1000);
                System.out.println("a end");
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
    synchronized public void b(){
        System.out.println("b begin");
        System.out.println("b end");
    }
}</code></pre><p>由于<code>a()</code>方法和<code>b()</code>方法的对象监视器不同，a方法是<code>anyObject</code>，b方法是<code>this</code>，所以会出现异步执行的结果。</p>
<p>同步代码块放在非同步<code>synchronized</code>方法中进行声明并不能保证调用方法的线程的执行顺序性，也就是线程调用方法的顺序是无序的，这样会产生“脏读”问题，使用<code>synchronized</code>(非<code>this</code>对象)同步代码块可以解决“脏读”问题。</p>
<h3 id="13-静态synchronized同步代码块"><a href="#13-静态synchronized同步代码块" class="headerlink" title="13.静态synchronized同步代码块"></a>13.静态<code>synchronized</code>同步代码块</h3><p><code>synchronized</code>加到<code>static</code>静态方法上是对<code>Class</code>类加锁，加到非<code>static</code>静态方法是给对象加锁。</p>
<p>即使给的不是同一个对象，在静态同步代码块中，都是同步的，因为<code>Class</code>锁可以对类的所有对象实例起作用。</p>
<p><code>synchronized(class)</code>代码块的作用和<code>synchronized static</code>方法的作用一样。</p>
<p>静态同步代码块或方法可以用于创建多个线程时，由于每个线程的对象锁是不一样的，但是Class锁是一样的。</p>
<h3 id="14-String的常量池特性"><a href="#14-String的常量池特性" class="headerlink" title="14.String的常量池特性"></a>14.<code>String</code>的常量池特性</h3><p>在JVM中具有<code>String</code>常量池缓存的功能，所以下面的结果是<code>true</code></p>
<pre><code>String a = "a";
String b = "a";
System.out.println(a == b); // true</code></pre><p>如果把<code>synchronized(string)</code>同步块与<code>String</code>结合使用时，需要注意以下问题：</p>
<pre><code>public class Service {
    public static void print(String stringParam){
        try {
            synchronized (stringParam){
                while (true){
                    System.out.println(Thread.currentThread().getName());
                    Thread.sleep(1000);
                }
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}

public class ThreadA extends Thread {
    private Service service;
    public ThreadA(Service service){
        super();
        this.service=service;
    }

    @Override
    public void run() {
        Service.print("a");
    }
}

public class ThreadB extends Thread {
    private Service service;
    public ThreadB(Service service){
        super();
        this.service=service;
    }

    @Override
    public void run() {
        Service.print("a");
    }
}

public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}</code></pre><p>此时只有A线程执行，出现这样的原因是<code>String</code>的两个值都是a，两个线程持有相同的锁，所以造成线程B不能执行。这就是<code>String</code>常量池带来的问题，因此<code>synchronized</code>代码块不用<code>String</code>作为锁对象，而用其他<code>Object</code>对象。</p>
<p>现修改代码如下，此时AB线程都可以执行，因为这时候AB持有不同的锁：</p>
<pre><code>public class Service {
    public static void print(Object object){
        try {
          //用Object作为锁
            synchronized (object){
                while (true){
                    System.out.println(Thread.currentThread().getName());
                    Thread.sleep(1000);
                }
            }
        }catch (InterruptedException e){
            e.printStackTrace();
        }
    }
}

public class ThreadA extends Thread {
    private Service service;
    public ThreadA(Service service){
        super();
        this.service=service;
    }

    @Override
    public void run() {
      // 这里new Object
        Service.print(new Object());
    }
}</code></pre><h3 id="15-多线程的死锁"><a href="#15-多线程的死锁" class="headerlink" title="15.多线程的死锁"></a>15.多线程的死锁</h3><p>示例如下：</p>
<pre><code>public class DeadLockThread implements Runnable {
    public String name;
    public Object lock1 = new Object();
    public Object lock2 = new Object();

    public void setName(String name) {
        this.name = name;
    }

    @Override
    public void run() {
        if (name.equals("a")) {
            synchronized (lock1) {
                System.out.println("name=" + name);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock2) {
                    System.out.println("lock1-&gt;lock2");
                }
            }
        }
        if (name.equals("b")) {
            synchronized (lock2) {
                System.out.println("name=" + name);
                try {
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
                synchronized (lock1) {
                    System.out.println("lock2-&gt;lock1");
                }
            }
        }

    }
}

public class Run {
    public static void main(String[] args) {
        try {
            DeadLockThread deadLockThread = new DeadLockThread();
            deadLockThread.setName("a");
            Thread thread1 = new Thread(deadLockThread);
            thread1.start();
            Thread.sleep(1000);
            deadLockThread.setName("b");
            Thread thread2 = new Thread(deadLockThread);
            thread2.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p>由于<code>lock1</code>在等<code>lock2</code>释放锁，而<code>lock2</code>在等<code>lock1</code>释放锁，从而构成了死锁。</p>
<h3 id="16-volatile关键字"><a href="#16-volatile关键字" class="headerlink" title="16.volatile关键字"></a>16.<code>volatile</code>关键字</h3><p><code>volatile</code>关键字的作用：使变量在多个线程间可见。</p>
<p>下面这个示例说明<code>volatile</code>的作用：</p>
<pre><code>public class RunThread extends Thread {
    private boolean isRunning = true;

    public boolean isRunning() {
        return isRunning;
    }

    public void setRunning(boolean isRunning) {
        this.isRunning = isRunning;
    }

    @Override
    public void run() {
        System.out.println("进入run了");
        while (isRunning) {
            //这里传入任意synchronized同步方法都是可以解决死循环的
        }
        System.out.println("线程被停止了");
    }
}

public class Run {
    public static void main(String[] args) {
        try {
            RunThread thread = new RunThread();
            thread.start();
            Thread.sleep(1000);
            thread.setRunning(false);
            System.out.println("已经赋值为false了");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><p><img src="/images/1553137318653.png" alt="1553137318653">可以看到程序并没有停止，一直在<code>while</code>死循环中。</p>
<p>出现这样的结果是因为启动线程时，变量<code>private boolean isRunning = true;</code>存在于公共堆栈及线程的私有堆栈中。但在run中，线程一直在私有堆栈中取得<code>isRunning</code>的值<code>true</code>，而<code>thread.setRunning(false);</code>虽然被执行了，更新的却是公共堆栈中的<code>isRunning</code>变量值<code>false</code>，所以一直都是死循环状态。归根结底，是私有堆栈中的值和公共堆栈中的值不同步造成的，解决办法是使用<code>volatile</code>关键字，让线程强制从公共堆栈中取值。</p>
<pre><code>volatile private boolean isRunning = true;</code></pre><p>注意到我上面在<code>while</code>循环中的注释，传入任意<code>synchronized</code>同步方法都是可以解决死循环的，这说明<strong>synchronized也能将私有堆栈和公共堆栈中的数据做同步。</strong></p>
<p>比较<code>synchronized</code>和<code>volatile</code>：</p>
<ul>
<li><code>volatile</code>是线程同步的轻量级实现，所以volatile性能比<code>synchronized</code>好，但<code>volatile</code>只能修饰变量，而<code>synchronized</code>可以修饰方法和代码块</li>
<li>多线程访问<code>volatile</code>不会发生阻塞，而<code>synchronized</code>会出现阻塞</li>
<li><code>volatile</code>能保证数据的可见性，但不能保证原子性，<code>synchronized</code>可以保证间接可见性和原子性</li>
<li><code>volatile</code>解决的是变量在多个线程间的可见性，<code>synchronized</code>解决的是多个线程之间访问资源的同步性</li>
</ul>
<p>JVM有主内存(Main Memory)和工作内存(Working Memory)，主内存其实就是我们平时说的Java堆内存，存放程序中所有的类实例、静态数据等变量，是多个线程共享的，而工作内存存放的是该线程从主内存中拷贝过来的变量以及访问方法所取得的局部变量，是每个线程私有的其他线程不能访问，每个线程对变量的操作都是以先从主内存将其拷贝到工作内存再对其进行操作的方式进行,多个线程之间不能直接互相传递数据通信,只能通过共享变量来进行。</p>
<p><img src="/images/1553154446508.png" alt="1553154446508"></p>
<p>如图：</p>
<p>read和load阶段：从主存复制变量到当前线程工作内存</p>
<p>use和assign阶段：执行代码，改变共享变量值</p>
<p>store和write阶段：用工作内存数据刷新主存对应变量的值</p>
<p>在多线程环境中，use和assign是多次出现的，但这一操作并不是原子性，也就是在read和load后，如果主内存count变量发生变化后，线程工作内存由于已经load，不会产生对应的变化，也就是私有内存和公共内存中的变量不同步，所以计算出来的结果和预期不一样，也就是出现了非线程安全问题。</p>
<h3 id="17-原子类"><a href="#17-原子类" class="headerlink" title="17.原子类"></a>17.原子类</h3><p>在进行<code>i++</code>这种操作时，除了使用<code>synchronized</code>关键字实现同步外，还可以使用<code>AtomicInteger</code>原子类进行实现。</p>
<pre><code>public class AddCountThread extends Thread {
    private AtomicInteger count = new AtomicInteger(0);

    @Override
    public void run() {
        for (int i = 0; i &lt; 100; i++) {
            System.out.println(count.incrementAndGet());
        }
    }
}

public class Run {
    public static void main(String[] args) {
        AddCountThread addCountThread = new AddCountThread();
        Thread t1 = new Thread(addCountThread);
        t1.start();
        Thread t2 = new Thread(addCountThread);
        t2.start();
    }
}</code></pre><p>但是需要注意，虽然<code>incrementAndGet()</code>方法是原子的，但方法和方法之间的调用却不是原子的，解决的办法是用<code>synchronized</code>做同步。</p>
<p>如下所示</p>
<pre><code>public class AddCountThread extends Thread {
    private AtomicInteger count = new AtomicInteger(0);

    @Override
    public void run() {
        synchronized (this){
            for (int i = 0; i &lt; 100; i++) {
                System.out.println(count.incrementAndGet());
                System.out.println(count.incrementAndGet());
            }
        }
    }
}</code></pre><p>必须加上<code>synchronized</code>代码块或方法，否则原子方法的调用是异步的。</p>
<h3 id="18-线程的生命周期及状态切换"><a href="#18-线程的生命周期及状态切换" class="headerlink" title="18.线程的生命周期及状态切换"></a>18.线程的生命周期及状态切换</h3><p><img src="/images/1553400692450.png" alt="1553400692450"></p>
<p>如图所示，</p>
<p>（1）新创建一个新的线程对象后，再调用它的<code>start()</code>方法，系统会为此线程分配CPU资源，使其处于<code>Runnable</code> (可运行)状态，这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于<code>Running</code> (运行)状态。</p>
<p>（2） <code>Runnable</code>状态和<code>Running</code>状态可相互切换，因为有可能线程运行一段时间后,有其他高优先级的线程抢占了CPU资源，这时此线程就从<code>Running</code>状态变成<code>Runnable</code>状态。线程进入<code>Rurnable</code>状态大体分为如下5种情况：</p>
<ul>
<li><p>调用<code>sleep()</code>方法后经过的时间超过了指定的休眠时间</p>
</li>
<li><p>线程调用的阻塞IO已经返回，阻塞方法执行完毕</p>
</li>
<li><p>线程成功地获得了试图同步的监视器</p>
</li>
<li><p>线程正在等待某个通知,其他线程发出了通知</p>
</li>
<li><p>处于挂起状态的线程调用了<code>resume()</code>恢复方法</p>
</li>
</ul>
<p>（3） <code>Blocked</code>是阻塞的意思，例如遇到了一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他线程，这时也可以称为“暂停”状态。<code>Blocked</code>状态结束后，进入<code>Runnable</code>状态，等待系统重新分配资源。出现阻塞的情况大体分为如下5种：</p>
<ul>
<li><p>线程调用<code>sleep</code>方法，主动放弃占用的处理器资源</p>
</li>
<li><p>线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞</p>
</li>
<li><p>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有</p>
</li>
<li><p>线程等待某个通知</p>
</li>
<li><p>程序调用了<code>suspend</code>方法将该线程挂起。此方法容易导致死锁,尽量避免使用该方法</p>
</li>
</ul>
<p>（4）run()方法运行结束后进入销毁阶段,整个线程执行完毕。</p>
<p>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p>
<h3 id="19-线程组"><a href="#19-线程组" class="headerlink" title="19.线程组"></a>19.线程组</h3><p>线程组是为了方便管理线程，线程组机制允许我们通过分组来区分有不同安全特性的线程，对不同组的线程进行不同的管理，还可以通过线程组的分层结构来支持不对等安全措施的采用。</p>
<p>线程组和线程池的区别：前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p>
<h3 id="20-线程的异常处理"><a href="#20-线程的异常处理" class="headerlink" title="20.线程的异常处理"></a>20.线程的异常处理</h3><p>对于<code>checked exception</code>我们一般在程序中直接<code>try catch</code>即可，但是遇到<code>unchecked exception</code>，我们就需要自定义一个异常处理器专门去处理非检查型异常，示例如下：</p>
<pre><code>public class MyThreadExceptionHandler implements Thread.UncaughtExceptionHandler {
    @Override
    public void uncaughtException(Thread t, Throwable e) {
        System.out.println("An exception has been captured");
        System.out.printf("Exception: %s: %s\n", e.getClass().getName(), e.getMessage());
        System.out.println("Stack Trace");
        e.printStackTrace(System.out);
        System.out.printf("Thread status: %s\n", t.getState());
    }
}

public class MyThread implements Runnable {

    @Override
    public void run() {
        int a = Integer.parseInt("a");
        System.out.println(a);
    }
}

public class Run {
    public static void main(String[] args) {
        MyThread myThread = new MyThread();
        Thread thread = new Thread(myThread);
        thread.setUncaughtExceptionHandler(new MyThreadExceptionHandler());
        thread.start();
    }
}

//输出
An exception has been captured
Exception: java.lang.NumberFormatException: For input string: "a"
Stack Trace
java.lang.NumberFormatException: For input string: "a"
    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)
    at java.lang.Integer.parseInt(Integer.java:580)
    at java.lang.Integer.parseInt(Integer.java:615)
    at t10.MyThread.run(MyThread.java:11)
    at java.lang.Thread.run(Thread.java:748)
Thread status: RUNNABLE</code></pre><p>线程组的异常处理如下：</p>
<pre><code>public class MyThreadGroup extends ThreadGroup {
    public MyThreadGroup(String name) {
        super(name);
    }

    @Override
    public void uncaughtException(Thread t, Throwable e) {
        super.uncaughtException(t, e);
        // 中断线程组
        this.interrupt();

    }
}</code></pre><pre><code>public class MyThread extends Thread {
    private String num;

    public MyThread(ThreadGroup group, String name, String num) {
        super(group, name);
        this.num = num;
    }

    @Override
    public void run() {
        int numInt = Integer.parseInt(num);
        while (this.isInterrupted() == false) {
            System.out.println("while循环中：" + Thread.currentThread().getName());
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        MyThreadGroup group = new MyThreadGroup("我的线程组");
        MyThread[] myThread = new MyThread[10];
        for (int i = 0; i &lt; myThread.length; i++) {
            myThread[i] = new MyThread(group, "线程" + (i + 1), "1");
            myThread[i].start();
        }
        MyThread thread = new MyThread(group, "报错线程", "a");
        thread.start();
    }
}</code></pre><p>只要有一个线程发生异常，那么此线程组中的所有线程都会中断。</p>
<h3 id="21-synchronized不同写法的性能比较"><a href="#21-synchronized不同写法的性能比较" class="headerlink" title="21.synchronized不同写法的性能比较"></a>21.<code>synchronized</code>不同写法的性能比较</h3><p>性能和执行效率从小到大：</p>
<pre><code>public synchronized void method(){
    // 方法体
}

public void method(){
    synchronized (this){
        // 同步代码块
    }
}
// 因为进入方法体也需要时间，同步代码块的写法更节省时间

private byte[] lock = new byte[1];
public void method(){
    synchronized (lock){
        // 自定义对象锁
    }
}
// 因为加锁和释放锁都需要对象的资源，那肯定对象越小越好，所以造个一字节的byte对象最小</code></pre><h2 id="二、线程间的通信"><a href="#二、线程间的通信" class="headerlink" title="二、线程间的通信"></a>二、线程间的通信</h2><h3 id="1-等待-通知机制"><a href="#1-等待-通知机制" class="headerlink" title="1.等待/通知机制"></a>1.等待/通知机制</h3><p><code>wait()</code>方法的作用是使当前执行代码的线程进行等待。在调用<code>wait()</code>之前，线程必须获得该对象的对象级别锁,即只能在同步方法或同步块中调用<code>wait()</code>方法。在执行<code>wait()</code>方法后,当前线程释放锁。在从<code>wait()</code>返回前,线程与其他线程竞争重新获得锁。如果调用<code>wait()</code>时没有持有适当的锁,则抛出<code>llegalMonitorStateException</code>，它是<code>RuntimeException</code>的一个子类，因此，不需要<code>try catch</code>语句进行捕捉异常。方法<code>notify()</code>也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用<code>notify()</code>时没有持有适当的锁,也会抛出<code>llegalMonitorStateException</code>。该方法用来通知那些可能等待该对象的对象锁的其他线程,如果有多个线程等待,则由线程规划器随机挑选出其中一个呈<code>wait</code>状态的线程,对其发出通知<code>notify</code>,并使它等待获取该对象的对象锁。需要说明的是,在执行<code>notify()</code>方法后,当前线程不会马上释放该对象锁,呈<code>wait</code>状态的线程也并不能马上获取该对象锁,要等到执行<code>notify()</code>方法的线程将程序执行完，也就是退出<code>synchronized</code>代码块后,当前线程才会释放锁,而呈<code>wait</code>状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的<code>wait</code>线程运行完毕以后,它会释放掉该对象锁,此时如果该对象没有再次使用<code>notify</code>语句,则即便该对象已经空闲,其他<code>wait</code>状态等待的线程由于没有得到该对象的通知,还会继续阻塞在<code>wait</code>状态,直到这个对象发出一个<code>notify</code>或<code>notifyAll</code>。</p>
<p>用一句话来总结一下<code>wait</code>和<code>notify</code>：<code>wait</code>使线程停止运行，而<code>notify</code>使停止的线程继续。</p>
<p>请看如下示例</p>
<pre><code>public class MyList {
    private static List list = new ArrayList();

    public static void add() {
        list.add("any");
    }

    public static int size() {
        return list.size();
    }
}

public class ThreadA extends Thread {
    private Object lock;

    public ThreadA(Object lock) {
        super();
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            synchronized (lock) {
                if (MyList.size() != 5) {
                    System.out.println("wait begin " + System.currentTimeMillis());
                    lock.wait();
                    System.out.println("wait end " + System.currentTimeMillis());
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class ThreadB extends Thread {
    private Object lock;

    public ThreadB(Object lock) {
        this.lock = lock;
    }

    @Override
    public void run() {
        try {
            synchronized (lock) {
                for (int i = 0; i &lt; 10; i++) {
                    MyList.add();
                    if (MyList.size() == 5) {
                        lock.notify();
                        System.out.println("has notified");
                    }
                    System.out.println("add " + (i + 1) + " element");
                    Thread.sleep(1000);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}

public class Run {
    public static void main(String[] args) {
        Object lock = new Object();
        ThreadA threadA = new ThreadA(lock);
        threadA.start();
        ThreadB threadB = new ThreadB(lock);
        threadB.start();
    }
}

//输出
wait begin 1553399418175
add 1 element
add 2 element
add 3 element
add 4 element
has notified
add 5 element
add 6 element
add 7 element
add 8 element
add 9 element
add 10 element
wait end 1553399428180</code></pre><p>注意到<code>notify()</code>方法执行后并不立即释放锁，而是执行完<code>notify()</code>方法所在的<code>synchronized</code>同步代码块后才释放锁。</p>
<h3 id="2-wait和notify"><a href="#2-wait和notify" class="headerlink" title="2.wait和notify"></a>2.<code>wait</code>和<code>notify</code></h3><p>当线程<code>wait</code>时，此时调用<code>interrupt</code>方法会出现<code>InterruptedException</code>异常。</p>
<p><code>notify()</code>只能随机唤醒一个线程，<code>notifyAll()</code>能唤醒所有<code>waiting</code>的线程。</p>
<p>带一个参数的<code>wait(long)</code>方法会等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。</p>
<h3 id="3-生产者-消费者模式"><a href="#3-生产者-消费者模式" class="headerlink" title="3.生产者/消费者模式"></a>3.生产者/消费者模式</h3><h4 id="一生产与一消费：操作值"><a href="#一生产与一消费：操作值" class="headerlink" title="一生产与一消费：操作值"></a>一生产与一消费：操作值</h4><pre><code>public class ValueObject {
    public static String value = "";
}</code></pre><pre><code>public class P {
    private String lock;

    public P(String lock) {
        this.lock = lock;
    }

    public void setValue() {
        try {
            synchronized (lock) {
                if (!ValueObject.value.equals("")) {
                    lock.wait();
                }
                String value = "value";
                System.out.println("set的值是 " + value);
                ValueObject.value = value;
                lock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class C {
    private String lock;

    public C(String lock) {
        this.lock = lock;
    }

    public void getValue() {
        try {
            synchronized (lock) {
                if (ValueObject.value.equals("")) {
                    lock.wait();
                }
                System.out.println("get的值是 " + ValueObject.value);
                ValueObject.value = "";
                lock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ThreadP extends Thread {
    private P p;

    public ThreadP(P p) {
        this.p = p;
    }

    @Override
    public void run() {
        while (true) {
            p.setValue();
        }
    }
}</code></pre><pre><code>public class ThreadC extends Thread {
    private C c;

    public ThreadC(C c) {
        this.c = c;
    }

    @Override
    public void run() {
        while (true) {
            c.getValue();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        String lock = new String();
        P p = new P(lock);
        C c = new C(lock);
        ThreadP threadP = new ThreadP(p);
        ThreadC threadC = new ThreadC(c);
        threadP.start();
        threadC.start();
    }
}</code></pre><pre><code>输出结果是循环交替：
set的值是 value
get的值是 value</code></pre><h4 id="多生产与多消费：操作值"><a href="#多生产与多消费：操作值" class="headerlink" title="多生产与多消费：操作值"></a>多生产与多消费：操作值</h4><p>多产生与多消费时会出现“假死”的现象，所谓假死就是线程进入<code>waiting</code>等待状态。比如生产者唤醒生产者，消费者唤醒消费者，这样就会导致所有线程都是<code>waiting</code>状态。</p>
<p>与上面不同的程序如下：</p>
<pre><code>public class P {
    private String lock;

    public P(String lock) {
        this.lock = lock;
    }

    public void setValue() {
        try {
            synchronized (lock) {
                while (!ValueObject.value.equals("")) {
                    System.out.println("生产者 "+Thread.currentThread().getName()+"waiting★");
                    lock.wait();
                }
                System.out.println("生产者 "+Thread.currentThread().getName()+"runnable");
                String value = "value";
                ValueObject.value = value;
                lock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class C {
    private String lock;

    public C(String lock) {
        this.lock = lock;
    }

    public void getValue() {
        try {
            synchronized (lock) {
                while (ValueObject.value.equals("")) {
                    System.out.println("消费者 "+Thread.currentThread().getName()+"waiting☆");
                    lock.wait();
                }
                System.out.println("消费者 "+Thread.currentThread().getName()+"runnable");
                ValueObject.value = "";
                lock.notify();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        String lock = new String();
        P p = new P(lock);
        C c = new C(lock);
        ThreadP[] threadP = new ThreadP[2];
        ThreadC[] threadC = new ThreadC[2];
        for (int i = 0; i &lt; 2; i++) {
            threadP[i] = new ThreadP(p);
            threadP[i].setName("生产者" + (i + 1));
            threadC[i] = new ThreadC(c);
            threadC[i].setName("消费者" + (i + 1));
            threadP[i].start();
            threadC[i].start();
        }
        Thread.sleep(5000);
        Thread[] threads = new Thread[Thread.currentThread().getThreadGroup().activeCount()];
        Thread.currentThread().getThreadGroup().enumerate(threads);
        for (Thread thread : threads) {
            System.out.println(thread.getName() + " " + thread.getState());
        }
    }
}</code></pre><pre><code>//输出结果如下
1.生产者 生产者1runnable
2.生产者 生产者1waiting★
3.生产者 生产者2waiting★
4.消费者 消费者1runnable
5.消费者 消费者1waiting☆
6.生产者 生产者1runnable
7.生产者 生产者1waiting★
8.生产者 生产者2waiting★
9.消费者 消费者2runnable
10.消费者 消费者2waiting☆
11.消费者 消费者1waiting☆
    main RUNNABLE
    Monitor Ctrl-Break RUNNABLE
    生产者1 WAITING
    消费者1 WAITING
    生产者2 WAITING
    消费者2 WAITING</code></pre><p>分析结果：</p>
<ol>
<li><p>生产者1被启动，进入生产，生产完毕后发出通知，并释放锁，准备进入下一次while循环。</p>
</li>
<li><p>生产者1进入下一次循环，再次持有锁，发现产品并没有被消费，所以生产者1进入等待状态。</p>
</li>
<li><p>生产者2被启动，生产者2发现产品还没有被消费，所以生产者2也进入等待状态。</p>
</li>
<li><p>消费者1被启动，消费者1持有锁，将产品消费并发出通知（发出的通知唤醒了第6行的生产者1），运行结束后释放锁，准备进入下次循环。</p>
</li>
<li><p>消费者1进入下一次循环，发现产品还没有生产，所以释放锁并进入等待状态。</p>
</li>
<li><p>生产者1被第4行的消费者1唤醒，进入生产，生产完毕后发出通知（唤醒了第8行的生产者2）准备进入下一次循环。</p>
</li>
<li><p>生产者1再次进入循环，发现产品还没有被消费，所以生产者1进入等待状态。</p>
</li>
<li><p>生产者2被唤醒，发现产品没有消费，进入等待状态。</p>
</li>
<li><p>消费者2被启动，将产品消费完并发出通知（唤醒了第11行的消费者1），运行结束后释放锁，准备进入下一次循环。</p>
</li>
<li><p>消费者2再次进入循环，发现产品还没有生产，所以释放锁进入等待状态。</p>
</li>
<li><p>消费者1被唤醒，发现产品还没有生产，所以也释放锁进入等待状态。</p>
<p>至此，所有生产者和消费者都进入等待状态，出现所谓的“假死”。</p>
</li>
</ol>
<p>由上可知，假死出现的原因是有可能唤醒同类，只要能不光唤醒同类，也将异类也一起唤醒就可以了，解决办法就是将<code>notify()</code>方法改成<code>notifyAll()</code>方法。</p>
<h4 id="一生产与一消费：操作栈"><a href="#一生产与一消费：操作栈" class="headerlink" title="一生产与一消费：操作栈"></a>一生产与一消费：操作栈</h4><p>本示例是使生产者向堆栈<code>List</code>对象中放入数据，使消费者从<code>List</code>堆栈中取出数据。<code>List</code>容量为1</p>
<pre><code>public class MyStack {
    private List list = new ArrayList();

    synchronized public void push() {
        try {
            while (list.size() == 1) {
                this.wait();
            }
            list.add("any");
            this.notify();// 多通信时需要改成notifyAll()
            System.out.println("push=" + list.size());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    synchronized public String pop() {
        String returnValue = "";
        try {
            while (list.size() == 0) {
                System.out.println("pop操作中的: " + Thread.currentThread().getName() + " 线程为wait状态");
                this.wait();
            }
            returnValue = "" + list.get(0);
            list.remove(0);
            this.notify();// 多通信时需要改成notifyAll()
            System.out.println("pop=" + list.size());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
        return returnValue;
    }
}</code></pre><pre><code>public class P {
    private MyStack myStack;

    public P(MyStack myStack) {
        this.myStack = myStack;
    }

    public void pushService() {
        myStack.push();
    }
}</code></pre><pre><code>public class C {
    private MyStack myStack;

    public C(MyStack myStack) {
        this.myStack = myStack;
    }

    public void popService() {
        System.out.println("pop=" + myStack.pop());
    }
}</code></pre><pre><code>public class ThreadP extends Thread {
    private P p;

    public ThreadP(P p) {
        this.p = p;
    }

    @Override
    public void run() {
        while (true) {
            p.pushService();
        }
    }
}</code></pre><pre><code>public class ThreadC extends Thread {
    private C c;

    public ThreadC(C c) {
        this.c = c;
    }

    @Override
    public void run() {
        while (true) {
            c.popService();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        MyStack myStack = new MyStack();
        P p = new P(myStack);
        C c = new C(myStack);
        ThreadP threadP = new ThreadP(p);
        ThreadC threadC = new ThreadC(c);
        threadP.start();
        threadC.start();
    }
}</code></pre><h4 id="一生产与多消费：操作栈"><a href="#一生产与多消费：操作栈" class="headerlink" title="一生产与多消费：操作栈"></a>一生产与多消费：操作栈</h4><p>修改上面Run中的消费者和生产者数量即可</p>
<h4 id="多生产与一消费：操作栈"><a href="#多生产与一消费：操作栈" class="headerlink" title="多生产与一消费：操作栈"></a>多生产与一消费：操作栈</h4><p>同上</p>
<h4 id="多生产与多消费：操作栈"><a href="#多生产与多消费：操作栈" class="headerlink" title="多生产与多消费：操作栈"></a>多生产与多消费：操作栈</h4><p>同上</p>
<h3 id="4-管道线程通信：字节流"><a href="#4-管道线程通信：字节流" class="headerlink" title="4.管道线程通信：字节流"></a>4.管道线程通信：字节流</h3><p>管道流可以在不同线程间直接传送数据，实现不同线程间的通信。</p>
<pre><code>public class WriteData {
    public void writeMethod(PipedOutputStream out) {
        try {
            System.out.println("write:");
            for (int i = 0; i &lt; 300; i++) {
                String outData = "" + (i + 1);
                out.write(outData.getBytes());
                System.out.print(outData);
            }
            System.out.println();
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ReadData {
    public void readMethod(PipedInputStream input) {
        try {
            System.out.println("read:");
            byte[] bytes = new byte[20];
            int readLength = input.read(bytes);
            while (readLength != -1) {
                String newData = new String(bytes, 0, readLength);
                System.out.print(newData);
                readLength = input.read(bytes);
            }
            System.out.println();
            input.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ThreadWrite extends Thread {
    private WriteData write;
    private PipedOutputStream out;

    public ThreadWrite(WriteData write, PipedOutputStream out) {
        this.write = write;
        this.out = out;
    }

    @Override
    public void run() {
        write.writeMethod(out);
    }
}</code></pre><pre><code>public class ThreadRead extends Thread {
    private ReadData read;
    private PipedInputStream input;

    public ThreadRead(ReadData read, PipedInputStream input) {
        this.read = read;
        this.input = input;
    }

    @Override
    public void run() {
        read.readMethod(input);
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        try {
            WriteData writeData = new WriteData();
            ReadData readData = new ReadData();

            PipedOutputStream outputStream = new PipedOutputStream();
            PipedInputStream inputStream = new PipedInputStream();

            // 连接两个管道，进行数据的输入输出
            outputStream.connect(inputStream);

            ThreadRead threadRead = new ThreadRead(readData, inputStream);
            threadRead.start();

            Thread.sleep(2000);

            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);
            threadWrite.start();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><h3 id="5-管道线程通信：字符流"><a href="#5-管道线程通信：字符流" class="headerlink" title="5.管道线程通信：字符流"></a>5.管道线程通信：字符流</h3><p><code>inputstream</code>和<code>outputstream</code>更改成<code>reader</code>和<code>writer</code>即可</p>
<pre><code>public class WriteData {
    public void writeMethod(PipedWriter out) {
        try {
            System.out.println("write:");
            for (int i = 0; i &lt; 300; i++) {
                String outData = "" + (i + 1);
                out.write(outData);
                System.out.print(outData);
            }
            System.out.println();
            out.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ReadData {
    public void readMethod(PipedReader input) {
        try {
            System.out.println("read:");
            char[] bytes = new char[20];
            int readLength = input.read(bytes);
            while (readLength != -1) {
                String newData = new String(bytes, 0, readLength);
                System.out.print(newData);
                readLength = input.read(bytes);
            }
            System.out.println();
            input.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ThreadWrite extends Thread {
    private WriteData write;
    private PipedWriter out;

    public ThreadWrite(WriteData write, PipedWriter out) {
        this.write = write;
        this.out = out;
    }

    @Override
    public void run() {
        write.writeMethod(out);
    }
}</code></pre><pre><code>public class ThreadRead extends Thread {
    private ReadData read;
    private PipedReader input;

    public ThreadRead(ReadData read, PipedReader input) {
        this.read = read;
        this.input = input;
    }

    @Override
    public void run() {
        read.readMethod(input);
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        try {
            WriteData writeData = new WriteData();
            ReadData readData = new ReadData();

            PipedWriter outputStream = new PipedWriter();
            PipedReader inputStream = new PipedReader();

            outputStream.connect(inputStream);

            ThreadRead threadRead = new ThreadRead(readData, inputStream);
            threadRead.start();

            Thread.sleep(2000);

            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);
            threadWrite.start();

        } catch (IOException e) {
            e.printStackTrace();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><h3 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.<code>join</code>方法</h3><p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到<code>join()</code>方法。</p>
<p>方法<code>join</code>的作用是使所属的线程对象x正常执行<code>run()</code>方法中的任务，而使当前线程z进行无限期的阻塞 ，等待线程x销毁后再继续执行线程z后面的代码。</p>
<p>方法<code>join</code>具有使线程排队的作用，有些类似同步的运行效果。</p>
<p><code>join</code>与<code>synchronized</code>的区别是：<code>join</code>在内部使用<code>wait()</code>方法进行等待，<code>synchronized</code>使用的是对象监视器做同步。</p>
<p>在<code>join</code>过程中，如果当前线程对象被中断则当前线程出现异常。</p>
<p><code>join(time)</code>和<code>sleep(time)</code>的区别：<code>join</code>由于内部使用<code>wait</code>等待，所以会释放锁，而<code>sleep</code>不能。</p>
<h3 id="7-ThreadLocal类"><a href="#7-ThreadLocal类" class="headerlink" title="7.ThreadLocal类"></a>7.<code>ThreadLocal</code>类</h3><p>类<code>ThreadLocal</code>解决了每个线程绑定自己的值的问题，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p>验证变量隔离性，同时赋予<code>get</code>默认值，示例如下：</p>
<pre><code>public class Tools {
    public static ThreadLocalExt t1 = new ThreadLocalExt();
}</code></pre><pre><code>public class ThreadLocalExt extends ThreadLocal {
    @Override
    protected Object initialValue() {
        return System.currentTimeMillis();
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            System.out.println("在ThreadA线程中取值=" + Tools.t1.get());
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println("在Main线程中取值=" + Tools.t1.get());
            }
            Thread.sleep(5000);
            ThreadA a = new ThreadA();
            a.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>输出：
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在Main线程中取值=1553519014020
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023
在ThreadA线程中取值=1553519019023</code></pre><h3 id="8-InheritableThreadLocal类"><a href="#8-InheritableThreadLocal类" class="headerlink" title="8.InheritableThreadLocal类"></a>8.<code>InheritableThreadLocal</code>类</h3><p>类<code>InheritableThreadLocal</code>可以让子线程从父线程中取得值。</p>
<p>除了继承之，还可以修改继承的值，示例如下：</p>
<pre><code>public class Tools {
    public static InheritableThreadLocalExt t1 = new InheritableThreadLocalExt();
}</code></pre><pre><code>public class InheritableThreadLocalExt extends InheritableThreadLocal {

    @Override
    protected Object childValue(Object parentValue) {
        return parentValue+" 加上子线程自己的值";
    }

    @Override
    protected Object initialValue() {
        return System.currentTimeMillis();
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    @Override
    public void run() {
        for (int i = 0; i &lt; 10; i++) {
            System.out.println("在ThreadA线程中取值=" + Tools.t1.get());
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        try {
            for (int i = 0; i &lt; 10; i++) {
                System.out.println("在Main线程中取值=" + Tools.t1.get());
            }
            Thread.sleep(5000);
            ThreadA a = new ThreadA();
            a.start();
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>输出：
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在Main线程中取值=1553519734861
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值
在ThreadA线程中取值=1553519734861 加上子线程自己的值</code></pre><h2 id="三、Lock的使用"><a href="#三、Lock的使用" class="headerlink" title="三、Lock的使用"></a>三、<code>Lock</code>的使用</h2><h3 id="1-ReentrantLock类"><a href="#1-ReentrantLock类" class="headerlink" title="1.ReentrantLock类"></a>1.<code>ReentrantLock</code>类</h3><p><code>ReentrantLock</code>的<code>lock()</code>方法获取锁，<code>unlock()</code>方法释放锁。</p>
<pre><code>public class MyService {
    private Lock lock = new ReentrantLock();

    public void testMethod() {
        lock.lock();
        for (int i = 0; i &lt; 5; i++) {
            System.out.println(Thread.currentThread().getName() + " " + (i + 1));
        }
        lock.unlock();
    }
}</code></pre><pre><code>public class MyThread extends Thread {
    private MyService service;

    public MyThread(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.testMethod();
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        MyService service = new MyService();
        MyThread a1 = new MyThread(service);
        MyThread a2 = new MyThread(service);
        MyThread a3 = new MyThread(service);
        MyThread a4 = new MyThread(service);
        MyThread a5 = new MyThread(service);
        a1.start();
        a2.start();
        a3.start();
        a4.start();
        a5.start();
    }
}</code></pre><h3 id="2-Condition实现等待-通知"><a href="#2-Condition实现等待-通知" class="headerlink" title="2.Condition实现等待/通知"></a>2.<code>Condition</code>实现等待/通知</h3><p>关键字<code>synchronized</code>与<code>wait()</code>和<code>notify()/notifyAlI()</code>方法相结合可以实现等待/通知模式，类<code>ReentrantLock</code>也可以实现同样的功能，但需要借助于<code>Condition</code>对象。<code>Condition</code>类是在JDK5中出现的技术，使用它有更好的灵活性，比如可以实现多路通知功能，也就是在一个<code>Lock</code>对象里面可以创建多个<code>Condition</code> (即对象监视器)实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程却是由JVM随机选择的。但使用<code>ReentrantLock</code>结合<code>Condition</code>类是可以实现前面介绍过的“选择性通知”，这个功能是非常重要的，而且在<code>Condition</code>类中是默认提供的。而<code>synchronized</code>就相当于整个<code>Lock</code>对象中只有一个单一的<code>Condition</code>对象，所有的线程都注册在它一个对象的身上。线程开始<code>notifyAll()</code>时，需要通知所有的WAITING线程，没有选择权。</p>
<p>一个<code>Condition</code>实现方法</p>
<pre><code>public class MyService {
    private Lock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void await() {
        try {
            lock.lock();
            System.out.println(" await时间为" + System.currentTimeMillis());
            condition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void signal() {
        try {
            lock.lock();
            System.out.println("signal时间为" + System.currentTimeMillis());
            condition.signal();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    private MyService service;

    public ThreadA(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.await();
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        ThreadA a = new ThreadA(service);
        a.start();
        Thread.sleep(3000);
        service.signal();
    }
}</code></pre><pre><code>输出：
await时间为1553603466000
signal时间为1553603469000</code></pre><p>多个<code>Condition</code>实现方法（指定唤醒线程）</p>
<pre><code>public class MyService {
    private Lock lock = new ReentrantLock();
    private Condition conditionA = lock.newCondition();
    private Condition conditionB = lock.newCondition();

    public void awaitA() {
        try {
            lock.lock();
            System.out.println("begin awaitA时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
            conditionA.await();
            System.out.println("  end awaitA时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void awaitB() {
        try {
            lock.lock();
            System.out.println("begin awaitB时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
            conditionB.await();
            System.out.println("  end awaitB时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void signalAll_A() {
        try {
            lock.lock();
            System.out.println("  signalAll_A时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
            conditionA.signalAll();
        } finally {
            lock.unlock();
        }
    }

    public void signalAll_B() {
        try {
            lock.lock();
            System.out.println("  signalAll_B时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());
            conditionB.signalAll();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    private MyService service;

    public ThreadA(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.awaitA();
    }
}</code></pre><pre><code>public class ThreadB extends Thread {
    private MyService service;

    public ThreadB(MyService service) {
        this.service = service;
    }

    @Override
    public void run() {
        service.awaitB();
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        MyService service = new MyService();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
        Thread.sleep(3000);
        service.signalAll_A();
    }
}</code></pre><pre><code>输出：
begin awaitA时间为1553605530840 ThreadName=A
begin awaitB时间为1553605530841 ThreadName=B
   signalAll_A时间为1553605533840 ThreadName=main
   end awaitA时间为1553605533840 ThreadName=A</code></pre><p>由此可见，我只唤醒了线程A，线程B并没有被唤醒，使用<code>ReentrantLock</code>对象可以唤醒指定种类的线程是很方便的。</p>
<h3 id="3-公平锁和非公平锁"><a href="#3-公平锁和非公平锁" class="headerlink" title="3.公平锁和非公平锁"></a>3.公平锁和非公平锁</h3><p>锁<code>Lock</code>分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，所以是不公平的。</p>
<pre><code>public class Service {
    private Lock lock;

    public Service(boolean isFair) {
        lock = new ReentrantLock(isFair);
    }

    public void serviceMethod() {
        try {
            lock.lock();
            System.out.println("ThreadName=" + Thread.currentThread().getName() + "获得锁定");
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        // 传入true是公平锁，false是非公平锁
        final Service service = new Service(true);
        Runnable runnable = () -&gt; {
            System.out.println("线程" + Thread.currentThread().getName() + "运行了");
            service.serviceMethod();
        };
        Thread[] threads = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            threads[i] = new Thread(runnable);
        }
        for (int i = 0; i &lt; 10; i++) {
            threads[i].start();
        }
    }
}</code></pre><pre><code>公平锁输出：

线程Thread-1运行了
线程Thread-6运行了
ThreadName=Thread-1获得锁定
线程Thread-0运行了
线程Thread-5运行了
线程Thread-2运行了
线程Thread-3运行了
线程Thread-9运行了
线程Thread-4运行了
线程Thread-7运行了
ThreadName=Thread-6获得锁定
ThreadName=Thread-0获得锁定
ThreadName=Thread-5获得锁定
ThreadName=Thread-2获得锁定
线程Thread-8运行了
ThreadName=Thread-3获得锁定
ThreadName=Thread-9获得锁定
ThreadName=Thread-4获得锁定
ThreadName=Thread-7获得锁定
ThreadName=Thread-8获得锁定

非公平锁输出：

线程Thread-0运行了
线程Thread-3运行了
线程Thread-4运行了
ThreadName=Thread-0获得锁定
线程Thread-1运行了
ThreadName=Thread-1获得锁定
线程Thread-7运行了
ThreadName=Thread-7获得锁定
线程Thread-8运行了
线程Thread-2运行了
线程Thread-5运行了
线程Thread-6运行了
线程Thread-9运行了
ThreadName=Thread-8获得锁定
ThreadName=Thread-3获得锁定
ThreadName=Thread-4获得锁定
ThreadName=Thread-2获得锁定
ThreadName=Thread-5获得锁定
ThreadName=Thread-6获得锁定
ThreadName=Thread-9获得锁定</code></pre><h3 id="4-getHoldCount"><a href="#4-getHoldCount" class="headerlink" title="4.getHoldCount()"></a>4.<code>getHoldCount()</code></h3><p>查询当前线程保持此锁定的个数，也就是调用<code>lock()</code>方法的次数。</p>
<p>示例：</p>
<pre><code>public class Service {
    private ReentrantLock lock = new ReentrantLock();

    public void serviceMethod1() {
        try {
            lock.lock();
            System.out.println("serviceMethod1 getHoldCount=" + lock.getHoldCount());
            serviceMethod2();
        } finally {
            lock.unlock();
        }
    }

    public void serviceMethod2() {
        try {
            lock.lock();
            System.out.println("serviceMethod2 getHoldCount=" + lock.getHoldCount());
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) {
        Service service = new Service();
        service.serviceMethod1();
    }
}</code></pre><pre><code>输出：
serviceMethod1 getHoldCount=1
serviceMethod2 getHoldCount=2</code></pre><h3 id="5-getQueueLength"><a href="#5-getQueueLength" class="headerlink" title="5.getQueueLength()"></a>5.<code>getQueueLength()</code></h3><p>返回正等待获取此锁定的线程估计数。比如有5个线程，1个线程首先执行<code>await()</code>方法，那么在调用<code>getQueueLength()</code>方法后返回值是4，说明有4个线程同时在等待<code>lock</code>的释放。</p>
<p>示例：</p>
<pre><code>public class Service {
    public ReentrantLock lock = new ReentrantLock();

    public void serviceMethod1() {
        try {
            lock.lock();
            System.out.println("ThreadName=" + Thread.currentThread().getName() + "进入方法！");
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service.serviceMethod1();
            }
        };

        Thread[] threadArray = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i].start();
        }
        Thread.sleep(2000);
        System.out.println("有线程数：" + service.lock.getQueueLength() + "在等待获取锁！");

    }
}</code></pre><pre><code>输出：
ThreadName=Thread-0进入方法！
有线程数：9在等待获取锁！</code></pre><h3 id="6-getWaitQueueLength-Condition-condition"><a href="#6-getWaitQueueLength-Condition-condition" class="headerlink" title="6.getWaitQueueLength(Condition condition)"></a>6.<code>getWaitQueueLength(Condition condition)</code></h3><p>返回等待与此锁定相关的给定条件<code>Condition</code>的线程估计数。比如5个线程，每个线程都执行同一个<code>condition</code>对象的<code>await()</code>方法，则调用<code>getWaitQueueLength(Condition condition)</code>方法时返回的值是5.</p>
<p>示例：</p>
<pre><code>public class Service {
    private ReentrantLock lock = new ReentrantLock();
    private Condition newCondition = lock.newCondition();

    public void waitMethod() {
        try {
            lock.lock();
            newCondition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void notityMethod() {
        try {
            lock.lock();
            System.out.println("有" + lock.getWaitQueueLength(newCondition) + "个线程正在等待newCondition");
            newCondition.signal();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service.waitMethod();
            }
        };

        Thread[] threadArray = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i].start();
        }
        Thread.sleep(2000);
        service.notityMethod();
    }
}</code></pre><pre><code>输出：
有10个线程正在等待newCondition</code></pre><h3 id="7-hasQueuedThread-Thread-thread-和hasQueuedThread"><a href="#7-hasQueuedThread-Thread-thread-和hasQueuedThread" class="headerlink" title="7.hasQueuedThread(Thread thread)和hasQueuedThread()"></a>7.<code>hasQueuedThread(Thread thread)</code>和<code>hasQueuedThread()</code></h3><p><code>hasQueuedThread(Thread thread)</code> 查询指定线程是否正在等待获取此锁定</p>
<p><code>hasQueuedThread()</code> 查询是否有线程正在等待获取此锁定</p>
<p>示例：</p>
<pre><code>public class Service {
    public ReentrantLock lock = new ReentrantLock();
    public Condition newCondition = lock.newCondition();

    public void waitMethod() {
        try {
            lock.lock();
            Thread.sleep(Integer.MAX_VALUE);
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service.waitMethod();
            }
        };

        Thread threadA = new Thread(runnable);
        threadA.start();

        Thread.sleep(500);

        Thread threadB = new Thread(runnable);
        threadB.start();

        Thread.sleep(500);
        System.out.println(service.lock.hasQueuedThread(threadA)); // false
        System.out.println(service.lock.hasQueuedThread(threadB)); // true，线程B在等待获取锁
        System.out.println(service.lock.hasQueuedThreads()); // true
    }
}</code></pre><h3 id="8-hasWaiters-Condition-condition"><a href="#8-hasWaiters-Condition-condition" class="headerlink" title="8.hasWaiters(Condition condition)"></a>8.<code>hasWaiters(Condition condition)</code></h3><p>查询是否有线程正在等待与此锁定有关的<code>condition</code>条件。</p>
<pre><code>public class Service {
    private ReentrantLock lock = new ReentrantLock();
    private Condition newCondition = lock.newCondition();

    public void waitMethod() {
        try {
            lock.lock();
            newCondition.await();
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            lock.unlock();
        }
    }

    public void notityMethod() {
        try {
            lock.lock();
            System.out.println("有没有线程正在等待newCondition？"
                    + lock.hasWaiters(newCondition) + " 线程数是多少？"
                    + lock.getWaitQueueLength(newCondition));
            newCondition.signal();
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();

        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service.waitMethod();
            }
        };

        Thread[] threadArray = new Thread[10];
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i] = new Thread(runnable);
        }
        for (int i = 0; i &lt; 10; i++) {
            threadArray[i].start();
        }
        Thread.sleep(2000);
        service.notityMethod();
    }
}</code></pre><pre><code>输出：
有没有线程正在等待newCondition？true 线程数是多少？10</code></pre><h3 id="9-isFair"><a href="#9-isFair" class="headerlink" title="9.isFair()"></a>9.<code>isFair()</code></h3><p>判读是不是公平锁。</p>
<p>示例：</p>
<pre><code>public class Service {
    private ReentrantLock lock;

    public Service(boolean isFair) {
        super();
        lock = new ReentrantLock(isFair);
    }

    public void serviceMethod() {
        try {
            lock.lock();
            System.out.println("公平锁情况：" + lock.isFair());
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service1 = new Service(true);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service1.serviceMethod();
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();

        final Service service2 = new Service(false);
        runnable = new Runnable() {
            @Override
            public void run() {
                service2.serviceMethod();
            }
        };
        thread = new Thread(runnable);
        thread.start();

    }
}</code></pre><pre><code>输出：
公平锁情况：true
公平锁情况：false</code></pre><h3 id="10-isHeldByCurrentThread"><a href="#10-isHeldByCurrentThread" class="headerlink" title="10.isHeldByCurrentThread()"></a>10.<code>isHeldByCurrentThread()</code></h3><p>查询当前线程是否保持此锁定。</p>
<pre><code>public class Service {
    private ReentrantLock lock;

    public Service(boolean isFair) {
        super();
        lock = new ReentrantLock(isFair);
    }

    public void serviceMethod() {
        try {
            System.out.println(lock.isHeldByCurrentThread()); // false
            lock.lock();
            System.out.println(lock.isHeldByCurrentThread()); // true
        } finally {
            lock.unlock();
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service1 = new Service(true);
        Runnable runnable = new Runnable() {
            @Override
            public void run() {
                service1.serviceMethod();
            }
        };
        Thread thread = new Thread(runnable);
        thread.start();
    }
}</code></pre><h3 id="11-isLocked"><a href="#11-isLocked" class="headerlink" title="11.isLocked()"></a>11.<code>isLocked()</code></h3><p>查询此锁定是否由任意线程保持。</p>
<pre><code>public class Service {

    private ReentrantLock lock;

    public Service(boolean isFair) {
        super();
        lock = new ReentrantLock(isFair);
    }

    public void serviceMethod() {
        try {
            System.out.println(lock.isLocked()); // false
            lock.lock();
            System.out.println(lock.isLocked()); // true
        } finally {
            lock.unlock();
        }
    }

}</code></pre><h3 id="12-lockInterruptibly"><a href="#12-lockInterruptibly" class="headerlink" title="12.lockInterruptibly()"></a>12.<code>lockInterruptibly()</code></h3><p>如果当前线程未被中断，则获取此锁定，如果已经中断则出现异常。</p>
<p>先看这个示例：</p>
<pre><code>public class Service {
    public ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void waitMethod() {
        try {
            lock.lock();
            System.out
                    .println("lock begin " + Thread.currentThread().getName());
            for (int i = 0; i &lt; Integer.MAX_VALUE / 10; i++) {
                String newString = new String();
                Math.random();
            }
            System.out
                    .println("lock   end " + Thread.currentThread().getName());
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();
        Runnable runnableRef = new Runnable() {
            @Override
            public void run() {
                service.waitMethod();
            }
        };

        Thread threadA = new Thread(runnableRef);
        threadA.setName("A");
        threadA.start();
        Thread.sleep(500);
        Thread threadB = new Thread(runnableRef);
        threadB.setName("B");
        threadB.start();
        threadB.interrupt(); // 打标记，并没有停止
        System.out.println("main end!");
    }
}</code></pre><pre><code>输出：
lock begin A
main end!
lock   end A
lock begin B
lock   end B</code></pre><p>可见，执行<code>lock()</code>方法没有出现异常，正常执行，因为<code>interrupt</code>没有停止线程。</p>
<p>将<code>lock()</code>方法改成<code>lockInterruptibly()</code>之后，</p>
<pre><code>public class Service {
    public ReentrantLock lock = new ReentrantLock();
    private Condition condition = lock.newCondition();

    public void waitMethod() {
        try {
            lock.lockInterruptibly();
            System.out.println("lock " + Thread.currentThread().getName());
            for (int i = 0; i &lt; Integer.MAX_VALUE / 10; i++) {
                String newString = new String();
                Math.random();
            }
        } catch (InterruptedException e) {
            System.out.println("线程"+Thread.currentThread().getName()+"进入catch");
            //e.printStackTrace();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}</code></pre><pre><code>输出：
lock A
main end!
线程B进入catch</code></pre><h3 id="13-tryLock-和tryLock-long-timeout-TimeUnit-unit"><a href="#13-tryLock-和tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="13.tryLock()和tryLock(long timeout,TimeUnit unit)"></a>13.<code>tryLock()</code>和<code>tryLock(long timeout,TimeUnit unit)</code></h3><p><code>tryLock()</code> 在调用时如果锁没有被其他线程保持，就获取该锁。</p>
<p><code>tryLock(long timeout,TimeUnit unit)</code> 如果锁在给定时间内没有被其他线程保持，且当前线程没被中断，就获取该锁。</p>
<p>示例：</p>
<pre><code>public class Service {
    public ReentrantLock lock = new ReentrantLock();

    public void waitMethod() {
        try {
            if (lock.tryLock(3, TimeUnit.SECONDS)) {
                System.out.println("      " + Thread.currentThread().getName()
                        + "获得锁的时间：" + System.currentTimeMillis());
                Thread.sleep(10000);
            } else {
                System.out.println("      " + Thread.currentThread().getName()
                        + "没有获得锁");
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        } finally {
            if (lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        final Service service = new Service();

        Runnable runnableRef = new Runnable() {
            @Override
            public void run() {
                System.out.println(Thread.currentThread().getName()
                        + "调用waitMethod时间：" + System.currentTimeMillis());
                service.waitMethod();
            }
        };

        Thread threadA = new Thread(runnableRef);
        threadA.setName("A");
        threadA.start();
        Thread threadB = new Thread(runnableRef);
        threadB.setName("B");
        threadB.start();
    }
}</code></pre><pre><code>输出：
A调用waitMethod时间：1553654723504
B调用waitMethod时间：1553654723504
        A获得锁的时间：1553654723505
        B没有获得锁</code></pre><p>由于线程A获取锁后<code>sleep</code>了10秒，所以B再次获取锁，在规定时间3秒内还没能等到A释放锁，因此B没有获取锁。</p>
<h3 id="14-ReentrantReadWriteLock类"><a href="#14-ReentrantReadWriteLock类" class="headerlink" title="14.ReentrantReadWriteLock类"></a>14.<code>ReentrantReadWriteLock</code>类</h3><p>类<code>Reentrantlock</code>具有完全互斥排他的效果，即同一时间只能有一个线程在执行<code>Rentrantlock.lock()</code>方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的，所以JDK提供了一种读写锁<code>ReentrantReadWriteLock</code>类,使用它可以加快运行效率,在某些不需要操作实例变量的方法中，完全可以使用读写锁<code>ReentrantReadWriteLock</code>来提升该方法的代码运行速度。</p>
<p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程<code>Thread</code>进行写入操作时,进行读取操作的多个<code>Thread</code>都可以获取读锁，而进行写入操作的<code>Thread</code>只有在获取写锁后才能进行写入操作。即多个<code>Thread</code>可以同时进行读取操作,但是同一时刻只允许一个<code>Thread</code>进行写入操作。</p>
<h4 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h4><pre><code>public class Service {
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void read() {
        try {
            try {
                lock.readLock().lock();
                System.out.println("获得读锁" + Thread.currentThread().getName()
                        + " " + System.currentTimeMillis());
                Thread.sleep(10000);
            } finally {
                lock.readLock().unlock();
            }
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.read();
    }
}</code></pre><pre><code>public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.read();
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {
        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        ThreadB b = new ThreadB(service);
        b.setName("B");
        a.start();
        b.start();
    }
}</code></pre><pre><code>输出：
获得读锁A 1553656843746
获得读锁B 1553656843747</code></pre><p>由输出可见，两个线程几乎同时进入<code>lock()</code>方法后面的代码，而不需要和之前一样，等待A线程10秒后才执行B线程，提高了运行效率。</p>
<h4 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h4><pre><code>public class Service {
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void write() {
        try {
            try {
                lock.writeLock().lock();
                System.out.println("获得写锁" + Thread.currentThread().getName()
                        + " " + System.currentTimeMillis());
                Thread.sleep(10000);
            } finally {
                lock.writeLock().unlock();
            }
        } catch (InterruptedException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>输出：
获得写锁A 1553657146589
获得写锁B 1553657156591</code></pre><p>使用写锁<code>lock.writeLock()</code>的效果就是同一时间只允许一个线程执行<code>lock()</code>后面的代码，必须等A执行完，才能执行B。</p>
<h4 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h4><pre><code>public class Service {
    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();

    public void read() {
        try {
            try {
                lock.readLock().lock();
                System.out.println("获得读锁" + Thread.currentThread().getName()
                        + " " + System.currentTimeMillis());
                Thread.sleep(10000);
            } finally {
                lock.readLock().unlock();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    public void write() {
        try {
            try {
                lock.writeLock().lock();
                System.out.println("获得写锁" + Thread.currentThread().getName()
                        + " " + System.currentTimeMillis());
                Thread.sleep(10000);
            } finally {
                lock.writeLock().unlock();
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}</code></pre><pre><code>public class ThreadA extends Thread {
    private Service service;

    public ThreadA(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.read();
    }
}</code></pre><pre><code>public class ThreadB extends Thread {
    private Service service;

    public ThreadB(Service service) {
        super();
        this.service = service;
    }

    @Override
    public void run() {
        service.write();
    }
}</code></pre><pre><code>public class Run {
    public static void main(String[] args) throws InterruptedException {

        Service service = new Service();
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();
        Thread.sleep(1000);
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
    }
}</code></pre><pre><code>输出：
获得读锁A 1553657413075
获得写锁B 1553657423075</code></pre><p>由此可见，读写操作也是互斥的。</p>
<h4 id="写读互斥"><a href="#写读互斥" class="headerlink" title="写读互斥"></a>写读互斥</h4><pre><code>public class Run {

    public static void main(String[] args) throws InterruptedException {

        Service service = new Service();
        ThreadB b = new ThreadB(service);
        b.setName("B");
        b.start();
        Thread.sleep(1000);
        ThreadA a = new ThreadA(service);
        a.setName("A");
        a.start();

    }
}</code></pre><pre><code>输出：
获得写锁B 1561709743838
获得读锁A 1561709753839</code></pre><p>由此可见，只要有写操作，就是互斥的。</p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://feichaoyu.com" rel="external nofollow noreferrer">feichaoyu</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://feichaoyu.com/2019/08/10/duo-xian-cheng-bi-ji/">https://feichaoyu.com/2019/08/10/duo-xian-cheng-bi-ji/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="https://feichaoyu.com" target="_blank">feichaoyu</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                                    <span class="chip bg-color">多线程</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">

<div id="article-share">
    
    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>
            
        </div>
    </div>

    
        <link rel="stylesheet" href="/libs/gitalk/gitalk.css">
<link rel="stylesheet" href="/css/my-gitalk.css">

<div class="card gitalk-card" data-aos="fade-up">
    <div class="comment_headling" style="font-size: 20px; font-weight: 700; position: relative; left: 20px; top: 15px; padding-bottom: 5px;">
        <i class="fas fa-comments fa-fw" aria-hidden="true"></i>
        <span>评论</span>
    </div>
    <div id="gitalk-container" class="card-content"></div>
</div>

<script src="/libs/gitalk/gitalk.min.js"></script>
<script>
    let gitalk = new Gitalk({
        clientID: '5d532a15ac3d0c7b3a64',
        clientSecret: '572d78e2f0d397d21bb65eddd0ffcc740197553d',
        repo: 'feichaoyu.github.io',
        owner: 'feichaoyu',
        admin: ["feichaoyu"],
        id: '2019-08-10T00-00-00',
        distractionFreeMode: false  // Facebook-like distraction free mode
    });

    gitalk.render('gitalk-container');
</script>
    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/2019/08/10/java-she-ji-mo-shi-yu-an-li/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/2.jpg" class="responsive-img" alt="Java设计模式与案例">
                        
                        <span class="card-title">Java设计模式与案例</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            介绍Java的设计模式以及相应的案例
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2019-08-10
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">
                        <span class="chip bg-color">设计模式</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                本篇&nbsp;<i class="far fa-dot-circle"></i>
            </div>
            <div class="card">
                <a href="/2019/08/10/duo-xian-cheng-bi-ji/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/18.jpg" class="responsive-img" alt="Java多线程编程核心技术读书笔记">
                        
                        <span class="card-title">Java多线程编程核心技术读书笔记</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            总结了《Java多线程编程核心技术》的知识点
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2019-08-10
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Java/" class="post-category">
                                    Java
                                </a>
                            
                            
                        </span>
                    </div>
                </div>

                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/">
                        <span class="chip bg-color">多线程</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>


<script>
    $('#articleContent').on('copy', function (e) {
        // IE8 or earlier browser is 'undefined'
        if (typeof window.getSelection === 'undefined') return;

        var selection = window.getSelection();
        // if the selection is short let's not annoy our users.
        if (('' + selection).length < Number.parseInt('120')) {
            return;
        }

        // create a div outside of the visible area and fill it with the selected text.
        var bodyElement = document.getElementsByTagName('body')[0];
        var newdiv = document.createElement('div');
        newdiv.style.position = 'absolute';
        newdiv.style.left = '-99999px';
        bodyElement.appendChild(newdiv);
        newdiv.appendChild(selection.getRangeAt(0).cloneContents());

        // we need a <pre> tag workaround.
        // otherwise the text inside "pre" loses all the line breaks!
        if (selection.getRangeAt(0).commonAncestorContainer.nodeName === 'PRE') {
            newdiv.innerHTML = "<pre>" + newdiv.innerHTML + "</pre>";
        }

        var url = document.location.href;
        newdiv.innerHTML += '<br />'
            + '来源: feichaoyu<br />'
            + '文章作者: feichaoyu<br />'
            + '文章链接: <a href="' + url + '">' + url + '</a><br />'
            + '本文章著作权归作者所有，任何形式的转载都请注明出处。';

        selection.selectAllChildren(newdiv);
        window.setTimeout(function () {bodyElement.removeChild(newdiv);}, 200);
    });
</script>


<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>



    <footer class="page-footer bg-color">
    <div class="container row center-align" style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2019</span>
            <a href="https://feichaoyu.com" target="_blank">feichaoyu</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">50.5k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/FeiChaoyu" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:979331856@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>



    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc("/" + "search.xml", 'searchInput', 'searchResult');
});
</script>
    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Global site tag (gtag.js) - Google Analytics -->


    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    
    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
