<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gradle控制台输出乱码解决方法</title>
      <link href="/2019/12/14/gradle-kong-zhi-tai-shu-chu-luan-ma-jie-jue-fang-fa/"/>
      <url>/2019/12/14/gradle-kong-zhi-tai-shu-chu-luan-ma-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>1、打开工具栏 Help-&gt;Edit Custom VM Options </p><p>2、在最后一行加上<code>-Dfile.encoding=utf-8</code></p><p>3、重启</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库的三范式</title>
      <link href="/2019/11/25/mysql/shu-ju-ku-san-fan-shi-ju-li/"/>
      <url>/2019/11/25/mysql/shu-ju-ku-san-fan-shi-ju-li/</url>
      
        <content type="html"><![CDATA[<h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>有如下表格：</p><p><img src="/images/image-20191125220832916.png" alt="image-20191125220832916"></p><p><strong>第一范式</strong></p><ul><li>数据库表中的所有字段都只具有单一属性</li><li>单一属性的列是由基本的数据类型所构成的</li><li>设计出来的表都是简单的二维表</li></ul><p>由第一范式，可以设计成如下两张表：</p><p><img src="/images/image-20191126101840177.png" alt="image-20191126101840177"></p><p><strong>第二范式</strong></p><p>要求一个表中只具有一个业务主键，不在主键中的列必须完全依赖于主键列，即主键能唯一确定其他非主键值。</p><p>因为在上述第二张表中，同一个商品ID不能唯一确定数量，因此不符合第二范式，需要重新设计。</p><p>由第二范式，可以设计成如下：</p><p><img src="/images/image-20191125221307358.png" alt="image-20191125221307358"></p><p><strong>第三范式</strong></p><p>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖</p><p>可以看到在上述第一张表中，客户名称可以由报表ID确定，还可以由客户ID确定。如果先通过报表ID找到客户ID，再通过客户ID找到客户名称，那么这就出现了传递依赖。</p><p>由第三范式，可以设计成如下：</p><p><img src="/images/image-20191125221405334.png" alt="image-20191125221405334"></p><p>至此，整个表设计完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三范式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker中容器之间通信的方式</title>
      <link href="/2019/11/19/docker/docker-rong-qi-zhi-jian-tong-xin/"/>
      <url>/2019/11/19/docker/docker-rong-qi-zhi-jian-tong-xin/</url>
      
        <content type="html"><![CDATA[<p>在docker中，容器之间的通信方式无非就是两种：</p><ul><li>容器之间通过宿主机通信</li><li>容器之间直接通信</li></ul><p>场景：</p><blockquote><p>我有两个容器，容器1放的是 Java 应用，容器2放的是 MySQL 和 Redis 数据库。</p><p>现在我需要让容器1连接容器2。</p></blockquote><h2 id="容器之间通过宿主机通信"><a href="#容器之间通过宿主机通信" class="headerlink" title="容器之间通过宿主机通信"></a>容器之间通过宿主机通信</h2><p>容器之间通过宿主机通信，就是把宿主机的 hosts 配置拷贝到容器中，如下：</p><pre class="line-numbers language-yml"><code class="language-yml">version: '3'services:  app:    hostname: app    image: app    container_name: app # 指定容器名称，如果不设置此参数，则由系统自动生成    restart: always # 设置容器自启模式    extra_hosts:       - "master:192.168.2.110"       - "slave1:192.168.2.111"       - "slave2:192.168.2.112"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中<code>extra_hosts</code>表示的就是容器中用到宿主机中的 host 配置。</p><h2 id="容器之间直接通信"><a href="#容器之间直接通信" class="headerlink" title="容器之间直接通信"></a>容器之间直接通信</h2><p>容器之间直接通信，需要配置网络，这里我就给出具体配置，原理就不阐述了。</p><pre class="line-numbers language-yml"><code class="language-yml">version: '3'services:  app:        # 服务名    hostname: app    image: app    container_name: app # 指定容器名称，如果不设置此参数，则由系统自动生成    restart: always # 设置容器自启模式    networks:       - default       - db_defaultnetworks:    db_default:        external: true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>关于这里的<code>default</code>和<code>db_default</code>：</p><p><code>default</code>：如果加上，就会创建一个新的网络，名称为<strong>当前目录名_default</strong>，这里不加也没事。</p><p><code>db_default</code>：需要通信容器2的网络，可以通过<code>docker network ls</code>查看。</p><p><img src="" alt="/images/Snipaste_2019-11-19_15-34-42.png"></p><blockquote><p>当然还有一种方法就是创建一个新的网络，然后两个容器都加入这个网络是最好的。</p></blockquote><p>容器2的 <code>docker-compose.yml</code> ：</p><pre class="line-numbers language-yml"><code class="language-yml">version: '3'services:  mysql:        # 服务名    hostname: mysql    image: mysql:5.7.26    # network_mode: "host" # 如果需要容器使用宿主机IP(内网IP)，则可以配置此项    container_name: mysql # 指定容器名称，如果不设置此参数，则由系统自动生成    restart: unless-stopped # 设置容器自启模式    command: mysqld --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci # 设置utf8字符集    environment:      - TZ=Asia/Shanghai # 设置容器时区与宿主机保持一致      - MYSQL_ROOT_PASSWORD=123456 # 设置root密码    volumes:       - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致       - ./mysql/data:/var/lib/mysql/data # 映射数据库保存目录到宿主机，防止数据丢失       - ./mysql/my.cnf:/etc/mysql/my.cnf # 映射数据库配置文件    ports:        - "3306:3306"  redis:  # 服务名    hostname: redis    image: redis:5.0.4    container_name: redis    restart: unless-stopped    command: redis-server /etc/redis.conf # 启动redis命令    environment:      - TZ=Asia/Shanghai    volumes:      - /etc/localtime:/etc/localtime:ro # 设置容器时区与宿主机保持一致      - ./redis/data:/data      - ./redis/redis.conf:/etc/redis.conf    ports:        - "6379:6379"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我这里想提醒大家的是，配置完容器之间直接通信后，可以在 Java 应用中使用：</p><pre><code>jdbc:mysql://mysql:3306/xxx</code></pre><pre><code>redis:    host: redis    port: 6379</code></pre><p>这里使用的<code>mysql</code>和<code>redis</code>需要和上面<code>docker-compose.yml</code>服务名对应，也就是<strong>容器以服务名作为 hostname 被其他容器访问</strong>。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>docker中redis容器无限重启问题</title>
      <link href="/2019/11/19/docker/docker-pei-zhi-redis/"/>
      <url>/2019/11/19/docker/docker-pei-zhi-redis/</url>
      
        <content type="html"><![CDATA[<p>今天用<code>docker-compose</code>启动 redis 容器时，发现一直启动不了，找了很久发现我的 <code>redis.conf</code>中的<code>daemonize</code>配置成了<code>yes</code>，这在平时服务器上一点问题没有，因为本来就需要后台运行，但是在 docker 中就不行了。</p><p>如果 redis 配置成了后台运行，那么 docker 发现自己没有任务可做，那么它就会退出，而我在<code>docker-compose.yml</code>中又配置了自动重启，所以一直在 restarting。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>&lt;mvc:default-servlet-handler/&gt;的作用</title>
      <link href="/2019/11/03/spring/default-servlet-handler-biao-qian-de-zuo-yong/"/>
      <url>/2019/11/03/spring/default-servlet-handler-biao-qian-de-zuo-yong/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>优雅 REST 风格的资源 URL 是不希望带类似 <code>.html</code> 或 <code>.do</code> 这样的后缀。由于早期的 Spring MVC 不能很好地处理静态资源，所以在 web.xml 中配置 DispatcherServlet 的请求映射，往往使用 <code>*.do</code> 、 <code>*.xhtml</code>等方式。这就决定了请求 URL 必须是一个带后缀的 URL，而无法采用真正的 REST 风格的 URL。</p><p>如果将 DispatcherServlet 请求映射配置为<code>"/"</code>，则 Spring MVC 将捕获 Web 容器所有的请求，包括静态资源的请求，Spring MVC 会将它们当成一个普通请求处理，因此找不到对应处理器将导致错误。</p><p>如何让 Spring 框架能够捕获所有 URL 的请求，同时又将静态资源的请求转由 Web 容器处理，是可将DispatcherServlet 的请求映射配置为<code>"/"</code>的前提。由于 REST 是 Spring3.0 最重要的功能之一，所以 Spring 团队很看重静态资源处理这项任务，给出了以下两种解决方案。</p><p>先调整 web.xml 中的 DispatcherServlet 的配置，使其可以捕获所有的请求：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-class</span><span class="token punctuation">></span></span>org.springframework.web.servlet.DispatcherServlet<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-class</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>load-on-startup</span><span class="token punctuation">></span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>load-on-startup</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-mapping</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>servlet-name</span><span class="token punctuation">></span></span>springMVC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-name</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>url-pattern</span><span class="token punctuation">></span></span>/<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>url-pattern</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>servlet-mapping</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> 通过上面<code>url-pattern</code>的配置，所有 URL 请求都将被 Spring MVC 的 DispatcherServlet 截获。 </p><h2 id="使用-lt-mvc-default-servlet-handler-gt"><a href="#使用-lt-mvc-default-servlet-handler-gt" class="headerlink" title="使用  <mvc:default-servlet-handler />"></a>使用  <code>&lt;mvc:default-servlet-handler /&gt;</code></h2><p>在 <code>springMVC-servlet.xml</code> 中配置<code>&lt;mvc:default-servlet-handler /&gt;</code>后，会在 Spring MVC 上下文中定义一个<code>org.springframework.web.servlet.resource.DefaultServletHttpRequestHandler</code>，它会像一个检查员，对进入 DispatcherServlet 的 URL 进行筛查，如果发现是静态资源的请求，就将该请求转由 Web 应用服务器默认的 Servlet 处理，如果不是静态资源的请求，才由 DispatcherServlet 继续处理。</p><p>一般 Web 应用服务器默认的 Servlet 名称是 “default”，因此 DefaultServletHttpRequestHandler 可以找到它。如果你所有的Web应用服务器的默认 Servlet 名称不是 “default”，则需要通过 <code>default-servlet-name</code> 属性显示指定：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>default-servlet-handler</span> <span class="token attr-name">default-servlet-name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>所使用的Web服务器默认使用的Servlet名称<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="使用-lt-mvc-resources-gt"><a href="#使用-lt-mvc-resources-gt" class="headerlink" title="使用  <mvc:resources  />"></a>使用  <code>&lt;mvc:resources  /&gt;</code></h2><p><code>&lt;mvc:default-servlet-handler /&gt;</code>将静态资源的处理经由 Spring MVC 框架交回 Web 应用服务器处理。而<code>&lt;mvc:resources /&gt;</code>更进一步，由 Spring MVC 框架自己处理静态资源，并添加一些有用的附加值功能。</p><p>首先，<code>&lt;mvc:resources /&gt;</code>允许静态资源放在任何地方，如 WEB-INF 目录下、类路径下等，你甚至可以将JavaScript 等静态文件打到 JAR 包中。通过 <code>location</code> 属性指定静态资源的位置，由于 <code>location</code> 属性是 Resources 类型，因此可以使用诸如 “classpath:” 等的资源前缀指定资源位置。传统 Web 容器的静态资源只能放在 Web 容器的根路径下，<code>&lt;mvc:resources /&gt;</code>完全打破了这个限制。</p><p>其次，<code>&lt;mvc:resources /&gt;</code>依据当前著名的 Page Speed、YSlow 等浏览器优化原则对静态资源提供优化。你可以通过<code>cacheSeconds</code>属性指定静态资源在浏览器端的缓存时间，一般可将该时间设置为一年，以充分利用浏览器端的缓存。在输出静态资源时，会根据配置设置好响应报文头的 Expires 和 Cache-Control 值。</p><p>在接收到静态资源的获取请求时，会检查请求头的 Last-Modified 值，如果静态资源没有发生变化，则直接返回 303 相应状态码，提示客户端使用浏览器缓存的数据，而非将静态资源的内容输出到客户端，以充分节省带宽，提高程序性能。</p><p>在<code>springMVC-servlet.xml</code>中添加如下配置：</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span><span class="token namespace">mvc:</span>resources</span> <span class="token attr-name">location</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/,classpath:/META-INF/publicResources/<span class="token punctuation">"</span></span> <span class="token attr-name">mapping</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/resources/**<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以上配置将 Web 根路径 <code>"/"</code> 及类路径下 <code>/META-INF/publicResources/</code> 的目录映射为<code>/resources</code>路径。假设 Web 根路径下拥有 images、js 这两个资源目录，在 images 下面有 bg.gif 图片，在 js 下面有 test.js 文件，则可以通过 <code>/resources/images/bg.gif</code> 和 <code>/resources/js/test.js</code> 访问这二个静态资源。</p><p>转自 <a href="https://www.cnblogs.com/dflmg/p/6393416.html" target="_blank" rel="noopener">https://www.cnblogs.com/dflmg/p/6393416.html</a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring Framwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot中前端获取日期少8小时的原因</title>
      <link href="/2019/11/03/spring/hou-duan-date-shi-jian-chuan-dao-qian-duan-xiang-chai-8-xiao-shi/"/>
      <url>/2019/11/03/spring/hou-duan-date-shi-jian-chuan-dao-qian-duan-xiang-chai-8-xiao-shi/</url>
      
        <content type="html"><![CDATA[<h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>Spring 中对于加上 <code>@RestController</code> 或者 <code>@Controller+@ResponseBody</code> 注解的方法，返回值默认是Json格式，所以当对于<code>Date</code>类型的数据，在返回浏览器端是会被 Spring Boot 默认的 Jackson 框架转换，而Jackson 框架默认的时区是 GMT（相对于中国是少了8小时）。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p><strong>方法一：</strong></p><p>在<code>application.properties</code>中配置如下：</p><pre class="line-numbers language-properties"><code class="language-properties"><span class="token attr-name">spring.jackson.time-zone</span><span class="token punctuation">=</span><span class="token attr-value">GMT+8</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>方法二：</strong></p><p>在实体类中， 使用<code>@JsonFormat</code>格式化：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@JsonFormat</span><span class="token punctuation">(</span>pattern <span class="token operator">=</span> <span class="token string">"yyyy-MM-dd HH:mm:ss"</span><span class="token punctuation">,</span> timezone <span class="token operator">=</span> <span class="token string">"GMT+8"</span><span class="token punctuation">)</span><span class="token keyword">private</span> Date createTime<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring Framwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>nginx 配置 proxy_pass URL 末尾加与不加(斜线)的区别</title>
      <link href="/2019/10/21/nginx-pei-zhi-proxy-pass-url-mo-wei-jia-yu-bu-jia-xie-xian-de-qu-bie/"/>
      <url>/2019/10/21/nginx-pei-zhi-proxy-pass-url-mo-wei-jia-yu-bu-jia-xie-xian-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<p>假设访问路径是 <code>/test/a.html</code> </p><p>请看以下两种情况：</p><p><strong>1. proxy_pass 加 / 斜线的情况</strong></p><pre><code>location /test/ {    proxy_pass http://127.0.0.1:8080/;}</code></pre><p> 被代理的真实访问路径为：<a href="http://127.0.0.1:8080/a.html" target="_blank" rel="noopener">http://127.0.0.1:8080/a.html</a></p><p><strong>2. proxy_pass 不加 / 斜线的情况</strong> </p><pre><code>location /test/ {    proxy_pass http://127.0.0.1:8080;}</code></pre><p>  被代理的真实访问路径为：<a href="http://127.0.0.1:8080/test/a.html" target="_blank" rel="noopener">http://127.0.0.1:8080/test/a.html</a> </p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Vue路由history模式刷新后退出现404或500的解决方案</title>
      <link href="/2019/10/21/jie-jue-vue-lu-you-history-mo-shi-shua-xin-hou-404-de-wen-ti/"/>
      <url>/2019/10/21/jie-jue-vue-lu-you-history-mo-shi-shua-xin-hou-404-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>nginx 的配置文件部分如下：</p><pre><code>server {        listen       80;        server_name  localhost;        root   html/dist;        #charset koi8-r;        #access_log  logs/host.access.log  main;        location / {            try_files $uri $uri/ @router;  # 需要指向下面的@router否则会出现vue的路由在nginx中刷新出现404            index  index.html index.htm;        }        # 对应上面的@router，主要原因是路由的路径资源并不是一个真实的路径，所以无法找到具体的文件        # 因此需要rewrite到index.html中，然后交给路由在处理请求资源        location @router {            rewrite ^.*$ /index.html last;        }  }</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> nginx </category>
          
          <category> vue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Spring中Scope的陷阱</title>
      <link href="/2019/10/16/spring/scope-de-xian-jing/"/>
      <url>/2019/10/16/spring/scope-de-xian-jing/</url>
      
        <content type="html"><![CDATA[<p>有如下情景：</p><blockquote><p>在 Spring 的诸多应用场景中 bean 都是单例形式，当一个单例 bean 需要和一个非单例 bean 组合使用或者一个非单例 bean 和另一个非单例 bean 组合使用时，我们通常都是将依赖以属性的方式放到 bean 中来引用，然后以 <code>@Autowired</code> 来标记需要注入的属性。但是这种方式在 bean 的生命周期不同时将会出现很明显的问题。</p><p>假设单例 beanA 需要一个非单例 beanB，我们在 beanA 中注入 beanB，每次调用 beanA 中的方法时都会用到 beanB，我们知道 Spring Ioc 容器只在容器初始化时执行一次，也就是 beanA 中的依赖 beanB 只有一次注入的机会，但是实际上 beanB 我们需要的是每次调用方法时都获取一个新的对象。所以问题就是：我们需要的 beanB 是一个原型 bean，而事实上 beanB 的依赖只注入了一次，即变成了单例 bean。 </p></blockquote><p>先定义如下几个类：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanA</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    BeanB beanB<span class="token punctuation">;</span>    BeanFactory beanFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> BeanB <span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanB</span><span class="token punctuation">(</span>BeanB beanB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanB <span class="token operator">=</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>SCOPE_PROTOTYPE<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanB</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token annotation punctuation">@ComponentScan</span><span class="token punctuation">(</span>basePackages <span class="token operator">=</span> <span class="token string">"com.feichaoyu.beans"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanConfig</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>为了解决上述问题，Spring 提供了以下两种方式来解决：</p><p><strong>1. 利用<code>@Lookup</code>注解</strong></p><p>修改 <code>BeanA</code> </p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanA</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    BeanB beanB<span class="token punctuation">;</span>    BeanFactory beanFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Lookup</span>    <span class="token keyword">public</span> BeanB <span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanB</span><span class="token punctuation">(</span>BeanB beanB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanB <span class="token operator">=</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在<code>getBeanB</code>方法上标注<code>@Lookup</code>注解，被其标注的方法会被重写，然后根据其返回值的类型，Spring 会调用 <code>BeanFactory</code> 的 <code>getBean()</code> 方法来返回一个新的 bean。</p><p><strong>2. 通过<code>ApplicationContext</code>或者<code>BeanFactory</code>获取对象</strong></p><p>方法1：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanA</span> <span class="token keyword">implements</span> <span class="token class-name">BeanFactoryAware</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    BeanB beanB<span class="token punctuation">;</span>    BeanFactory beanFactory<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> BeanB <span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> beanFactory<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BeanB<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanB</span><span class="token punctuation">(</span>BeanB beanB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanB <span class="token operator">=</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanFactory</span><span class="token punctuation">(</span>BeanFactory beanFactory<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanFactory <span class="token operator">=</span> beanFactory<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>方法2：</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BeanA</span> <span class="token keyword">implements</span> <span class="token class-name">ApplicationContextAware</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Autowired</span>    BeanB beanB<span class="token punctuation">;</span>    ApplicationContext applicationContext<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> BeanB <span class="token function">getBeanB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> applicationContext<span class="token punctuation">.</span><span class="token function">getBean</span><span class="token punctuation">(</span>BeanB<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setBeanB</span><span class="token punctuation">(</span>BeanB beanB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>beanB <span class="token operator">=</span> beanB<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setApplicationContext</span><span class="token punctuation">(</span>ApplicationContext applicationContext<span class="token punctuation">)</span> <span class="token keyword">throws</span> BeansException <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>applicationContext <span class="token operator">=</span> applicationContext<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring Framwork </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VirtualBox中.vdi的迁移</title>
      <link href="/2019/09/29/virtualbox-zhong.vdi-de-qian-yi/"/>
      <url>/2019/09/29/virtualbox-zhong.vdi-de-qian-yi/</url>
      
        <content type="html"><![CDATA[<p>当你需要重装系统，想把原有的虚拟机转移过去。也就是从 VirtualBox 中将已有的<code>.vdi</code>文件转移。这时候不是简单的拷贝一下就行了，需要按照如下操作：</p><blockquote><p>假设源文件路径是 <code>D:/xxx.vdi</code></p></blockquote><ol><li>将该文件拷贝到<code>H:</code>目录下</li><li>在之前的虚拟机中通过<code>设置/存储---控制器：SATA</code>下选中<code>xxx.vdi</code>，在其<code>属性</code>下的<code>虚拟硬盘</code>中选择<code>选择一个虚拟磁盘...</code>，选择<code>H:/xxx.vdi</code></li><li>这时候会出现错误，进入 VirtualBox 的安装目录，在此处打开命令行，输入<code>VBoxManage internalcommands sethduuid H:\xxx.vdi</code>，提示<code>UUID changed to:......(一串16进制码)</code></li><li>重启 VirtualBox，再次执行步骤1，2即可</li></ol><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      
        <tags>
            
            <tag> VirtualBox </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>9.MySQL联合查询</title>
      <link href="/2019/09/26/mysql/lian-he-cha-xun/"/>
      <url>/2019/09/26/mysql/lian-he-cha-xun/</url>
      
        <content type="html"><![CDATA[<blockquote><p>union 关键字默认去重，如果使用 union all 可以包含重复项</p></blockquote><p>查询部门编号 &gt;90 或邮箱包含 a 的员工信息（去重）</p><pre><code>SELECT    * FROM    employees WHERE    email LIKE '%a%' UNIONSELECT    * FROM    employees WHERE    department_id &gt; 90;</code></pre><p>不去重</p><pre><code>SELECT    * FROM    employees WHERE    email LIKE '%a%' UNION ALLSELECT    * FROM    employees WHERE    department_id &gt; 90;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>8.MySQL子查询</title>
      <link href="/2019/09/25/mysql/zi-cha-xun/"/>
      <url>/2019/09/25/mysql/zi-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h2><p>标量子查询是指子查询返回的是单一值的标量，如一个数字或一个字符串，也是子查询中最简单的返回形式。</p><p>返回 job_id 与141号员工相同，salary 比143号员工多的员工姓名、job_id 和工资</p><pre><code>SELECT    last_name,    job_id,    salary FROM    employees WHERE    job_id = ( SELECT job_id FROM employees WHERE employee_id = 141 )     AND salary &gt; ( SELECT salary FROM employees WHERE employee_id = 143 );</code></pre><p>返回大于50号部门最低工资的部门 id 和其最低工资</p><pre><code>SELECT    MIN( salary ),    department_id FROM    employees GROUP BY    department_id HAVING    MIN( salary ) &gt; ( SELECT MIN( salary ) FROM employees WHERE department_id = 50 );</code></pre><p>select 后面仅仅支持标量子查询，比如查询每个部门的员工个数</p><pre><code>SELECT    d.*,    ( SELECT COUNT( * ) FROM employees e WHERE e.department_id = d.`department_id` ) 个数 FROM    departments d;</code></pre><h2 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h2><p>列子查询是指子查询返回的结果集是 N 行一列，该结果通常来自对表的某个字段查询返回。</p><p>返回 location_id 是1400或1700的部门中的所有员工姓名</p><pre><code>SELECT    last_name FROM    employees WHERE    department_id IN ( SELECT DISTINCT department_id FROM departments WHERE location_id IN ( 1400, 1700 ) );</code></pre><h2 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h2><p>行子查询是指子查询返回的结果集是一行 N 列，该子查询的结果通常是对表的某行数据进行查询而返回的结果集。</p><p>查询员工编号最小并且工资最高的员工信息</p><pre><code>SELECT    * FROM    employees WHERE    employee_id = ( SELECT MIN( employee_id ) FROM employees )     AND salary = ( SELECT MAX( salary ) FROM employees );</code></pre><h2 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h2><p>表子查询是指子查询返回的结果是多行多列的二维表。</p><p>查询每个部门的平均工资的工资等级</p><pre><code>SELECT    ag_dep.*,    g.`grade_level` FROM    ( SELECT AVG( salary ) ag, department_id FROM employees GROUP BY department_id ) ag_dep    INNER JOIN job_grades g ON ag_dep.ag BETWEEN lowest_sal     AND highest_sal;</code></pre><h2 id="相关子查询"><a href="#相关子查询" class="headerlink" title="相关子查询"></a>相关子查询</h2><p>相关子查询是指内部查询的执行依赖于外部查询的数据，外部查询每执行一次，内部查询也会执行一次。</p><p>查询有员工的部门名</p><pre><code>SELECT    department_name FROM    departments d WHERE    d.`department_id` IN ( SELECT department_id FROM employees )</code></pre><pre><code>SELECT    department_name FROM    departments d WHERE    EXISTS ( SELECT * FROM employees e WHERE d.`department_id` = e.`department_id` );</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2.MySQL条件查询</title>
      <link href="/2019/09/25/mysql/tiao-jian-cha-xun/"/>
      <url>/2019/09/25/mysql/tiao-jian-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="按条件表达式筛选"><a href="#按条件表达式筛选" class="headerlink" title="按条件表达式筛选"></a>按条件表达式筛选</h2><p>查询工资&gt;12000的员工信息</p><pre><code>SELECT     *FROM    employeesWHERE    salary&gt;12000;</code></pre><p>查询部门编号不等于90号的员工名和部门编号</p><pre><code>SELECT     last_name,    department_idFROM    employeesWHERE    department_id&lt;&gt;90;  # 或者department_id!=90</code></pre><h2 id="按逻辑表达式筛选"><a href="#按逻辑表达式筛选" class="headerlink" title="按逻辑表达式筛选"></a>按逻辑表达式筛选</h2><p>查询员工编号在100到120之间的员工信息</p><pre><code>SELECT    *FROM    employeesWHERE    employee_id &gt;= 120 AND employee_id&lt;=100;</code></pre><pre><code>SELECT    *FROM    employeesWHERE    employee_id BETWEEN 120 AND 100;</code></pre><p>查询部门编号不是在90到110之间，或者工资高于15000的员工信息</p><pre><code>SELECT    *FROM    employeesWHERE    NOT(department_id&gt;=90 AND  department_id&lt;=110) OR salary&gt;15000;</code></pre><h2 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h2><blockquote><p>通配符：<br>% 任意多个字符,包含0个字符<br>_ 任意单个字符</p></blockquote><p>查询员工名中包含字符a的员工信息</p><pre><code>select     *from    employeeswhere    last_name like '%a%';</code></pre><p>查询员工名中第三个字符为 n，第五个字符为 l 的员工名和工资</p><pre><code>select    last_name,    salaryFROM    employeesWHERE    last_name LIKE '__n_l%';</code></pre><p>查询员工名中第二个字符为 _ 的员工名</p><pre><code>SELECT    last_nameFROM    employeesWHERE    last_name LIKE '_\_%';  # 转移字符\</code></pre><pre><code>SELECT    last_nameFROM    employeesWHERE    last_name LIKE '_$_%' ESCAPE '$'; # 自定义转义字符$</code></pre><h2 id="IN-列表"><a href="#IN-列表" class="headerlink" title="IN 列表"></a>IN 列表</h2><p>查询员工的工种编号是 IT_PROG、AD_VP、AD_PRES 中的任意一个的员工名和工种编号</p><pre><code>SELECT    last_name,    job_idFROM    employeesWHERE    job_id = 'IT_PROT' OR job_id = 'AD_VP' OR JOB_ID ='AD_PRES';</code></pre><pre><code>SELECT    last_name,    job_idFROM    employeesWHERE    job_id IN( 'IT_PROT' ,'AD_VP','AD_PRES');</code></pre><h2 id="IS-NULL"><a href="#IS-NULL" class="headerlink" title="IS NULL"></a>IS NULL</h2><blockquote><p>= 或 &lt;&gt; 不能用于判断 null 值<br>is null 或 is not null 可以判断 null 值</p></blockquote><p>查询没有奖金的员工名和奖金率</p><pre><code>SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct IS NULL;</code></pre><p>查询有奖金的员工名和奖金率</p><pre><code>SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct IS NOT NULL;</code></pre><h2 id="安全等于-lt-gt"><a href="#安全等于-lt-gt" class="headerlink" title="安全等于 <=>"></a>安全等于 &lt;=&gt;</h2><blockquote><p>&lt;=&gt; 既可以判断 null 值，又可以判断普通的数值，但是可读性较低</p></blockquote><p>查询没有奖金的员工名和奖金率</p><pre><code>SELECT    last_name,    commission_pctFROM    employeesWHERE    commission_pct &lt;=&gt; NULL;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>6.MySQL连接查询</title>
      <link href="/2019/09/25/mysql/lian-jie-cha-xun/"/>
      <url>/2019/09/25/mysql/lian-jie-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL92-标准"><a href="#SQL92-标准" class="headerlink" title="SQL92 标准"></a>SQL92 标准</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><p>查询员工名和对应的部门名</p><pre><code>SELECT    last_name,    department_name FROM    employees,    departments WHERE    employees.`department_id` = departments.`department_id`;</code></pre><p>查询员工名、工种号、工种名（起别名）</p><pre><code>SELECT    e.last_name,    e.job_id,    j.job_title FROM    employees e,    jobs j WHERE    e.`job_id` = j.`job_id`;</code></pre><p>查询有奖金的员工名、部门名</p><pre><code>SELECT    last_name,    department_name,    commission_pct FROM    employees e,    departments d WHERE    e.`department_id` = d.`department_id`     AND e.`commission_pct` IS NOT NULL;</code></pre><p>查询有奖金部门的部门名和部门的领导编号以及该部门的最低工资</p><pre><code>SELECT    department_name,    d.manager_id,    MIN( salary ) FROM    departments d,    employees e WHERE    d.`department_id` = e.`department_id`     AND commission_pct IS NOT NULL GROUP BY    department_name,    d.`manager_id`;</code></pre><p>查询每个工种的工种名和员工的个数，并且按员工个数降序</p><pre><code>SELECT    job_title,    COUNT( * ) FROM    employees e,    jobs j WHERE    e.`job_id` = j.`job_id` GROUP BY    job_title ORDER BY    COUNT( * ) DESC;</code></pre><p>查询员工名、部门名和所在的城市（三表连接）</p><pre><code>SELECT    last_name,    department_name,    city FROM    employees e,    departments d,    locations l WHERE    e.`department_id` = d.`department_id`     AND d.`location_id` = l.`location_id` </code></pre><h4 id="非等值连接"><a href="#非等值连接" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>先创建一张表，并插入几条数据。</p><pre><code>CREATE TABLE job_grades ( grade_level VARCHAR ( 3 ), lowest_sal INT, highest_sal INT );INSERT INTO job_gradesVALUES    ( 'A', 1000, 2999 );INSERT INTO job_gradesVALUES    ( 'B', 3000, 5999 );INSERT INTO job_gradesVALUES    ( 'C', 6000, 9999 );INSERT INTO job_gradesVALUES    ( 'D', 10000, 14999 );INSERT INTO job_gradesVALUES    ( 'E', 15000, 24999 );INSERT INTO job_gradesVALUES    ( 'F', 25000, 40000 );</code></pre><p>查询员工的工资和工资级别</p><pre><code>SELECT    salary,    grade_level FROM    employees e,    job_grades g WHERE    salary BETWEEN g.`lowest_sal`     AND g.`highest_sal`;</code></pre><h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><p>查询员工名和对应上级的名称</p><pre><code>SELECT    e.employee_id,    e.last_name,    m.employee_id,    m.last_name FROM    employees e,    employees m WHERE    e.`manager_id` = m.`employee_id`;</code></pre><h2 id="SQL99-标准"><a href="#SQL99-标准" class="headerlink" title="SQL99 标准"></a>SQL99 标准</h2><blockquote><p>语法：<br>   select 查询列表<br>   from 表1 别名 【连接类型】<br>   join 表2 别名<br>   on 连接条件<br>   【where 筛选条件】<br>   【group by 分组】<br>   【having 筛选条件】<br>   【order by 排序列表】</p><p>连接类型：</p><p>内连接：inner<br>外连接<br>   左外：left 【outer】<br>   右外：right 【outer】<br>   全外：full【outer】<br>交叉连接：cross</p></blockquote><h3 id="内连接-1"><a href="#内连接-1" class="headerlink" title="内连接"></a>内连接</h3><h4 id="等值连接-1"><a href="#等值连接-1" class="headerlink" title="等值连接"></a>等值连接</h4><p>查询名字中包含 e 的员工名和工种名</p><pre><code>SELECT    last_name,    job_title FROM    employees e    INNER JOIN jobs j ON e.`job_id` = j.`job_id` WHERE    e.`last_name` LIKE '%e%';</code></pre><p>查询部门个数 &gt;3 的城市名和部门个数</p><pre><code>SELECT    city,    COUNT( * ) 部门个数 FROM    departments d    INNER JOIN locations l ON d.`location_id` = l.`location_id` GROUP BY    city HAVING    COUNT( * ) &gt; 3;</code></pre><p>查询员工名、部门名、工种名，并按部门名降序（三表连接）</p><pre><code>SELECT    last_name,    department_name,    job_title FROM    employees e    INNER JOIN departments d ON e.`department_id` = d.`department_id`    INNER JOIN jobs j ON e.`job_id` = j.`job_id` ORDER BY    department_name DESC;</code></pre><h4 id="非等值连接-1"><a href="#非等值连接-1" class="headerlink" title="非等值连接"></a>非等值连接</h4><p>查询员工的工资级别</p><pre><code>SELECT    salary,    grade_level FROM    employees e    JOIN job_grades g ON e.`salary` BETWEEN g.`lowest_sal`     AND g.`highest_sal`;</code></pre><h4 id="自连接-1"><a href="#自连接-1" class="headerlink" title="自连接"></a>自连接</h4><p>查询员工名和对应上级的名称</p><pre><code>SELECT    e.last_name,    m.last_name FROM    employees e    JOIN employees m ON e.`manager_id` = m.`employee_id`;</code></pre><h3 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h3><p>用于查询一个表中有，另一个表没有的记录</p><blockquote><p>特点：</p><ul><li>外连接的查询结果为主表中的所有记录<ul><li>如果从表中有和它匹配的，则显示匹配的值</li><li>如果从表中没有和它匹配的，则显示 null</li><li>外连接查询结果 = 内连接结果 + 主表中有而从表没有的记录</li></ul></li><li>左外连接，left join 左边的是主表</li><li>右外连接，right join 右边的是主表</li><li>左外和右外交换两个表的顺序，可以实现同样的效果 </li><li>全外连接 = 内连接的结果 + 表1中有但表2没有的 + 表2中有但表1没有的</li></ul></blockquote><h4 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h4><p>查询没有员工的部门</p><pre><code>SELECT    d.*,    e.employee_id FROM    departments d    LEFT JOIN employees e ON d.`department_id` = e.`department_id` WHERE    e.`employee_id` IS NULL;</code></pre><h4 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h4><p>查询没有员工的部门</p><pre><code>SELECT    d.*,    e.employee_id FROM    employees e    RIGHT JOIN departments d ON d.`department_id` = e.`department_id` WHERE    e.`employee_id` IS NULL;</code></pre><h4 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h4><p>先导入 girl 表<a href="https://www.lanzous.com/i6eag1c" target="_blank" rel="noopener">下载地址</a></p><p>MySQL 不支持 full join，但是我们可以通过 union 来实现全外连接。</p><pre><code>SELECT    * FROM    beauty b    LEFT JOIN boys bo ON b.`boyfriend_id` = bo.id UNIONSELECT    * FROM    beauty b    RIGHT JOIN boys bo ON b.`boyfriend_id` = bo.id;</code></pre><h3 id="交叉连接（笛卡尔积）"><a href="#交叉连接（笛卡尔积）" class="headerlink" title="交叉连接（笛卡尔积）"></a>交叉连接（笛卡尔积）</h3><pre><code>SELECT    b.*,    bo.* FROM    beauty b    CROSS JOIN boys bo;</code></pre><h2 id="SQL-JOIN-图"><a href="#SQL-JOIN-图" class="headerlink" title="SQL-JOIN 图"></a>SQL-JOIN 图</h2><p><img src="/images/sql-join.jpg" alt=""></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>1.MySQL基础查询</title>
      <link href="/2019/09/25/mysql/ji-chu-cha-xun/"/>
      <url>/2019/09/25/mysql/ji-chu-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>导入表 <a href="https://www.lanzous.com/i6eag1c" target="_blank" rel="noopener">下载地址</a></p><h2 id="查询表中的单个字段"><a href="#查询表中的单个字段" class="headerlink" title="查询表中的单个字段"></a>查询表中的单个字段</h2><pre><code>SELECT    last_name FROM    employees;</code></pre><h2 id="查询表中的多个字段"><a href="#查询表中的多个字段" class="headerlink" title="查询表中的多个字段"></a>查询表中的多个字段</h2><pre><code>SELECT    last_name,    salary,    email FROM    employees;</code></pre><h2 id="查询表中的所有字段"><a href="#查询表中的所有字段" class="headerlink" title="查询表中的所有字段"></a>查询表中的所有字段</h2><pre><code>SELECT    `employee_id`,    `first_name`,    `last_name`,    `phone_number`,    `last_name`,    `job_id`,    `phone_number`,    `job_id`,    `salary`,    `commission_pct`,    `manager_id`,    `department_id`,    `hiredate` FROM    employees;</code></pre><pre><code>SELECT    * FROM    employees;</code></pre><h2 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h2><h3 id="使用-AS"><a href="#使用-AS" class="headerlink" title="使用 AS"></a>使用 AS</h3><pre><code>SELECT    last_name AS 姓,    first_name AS 名 FROM    employees;</code></pre><h3 id="使用空格"><a href="#使用空格" class="headerlink" title="使用空格"></a>使用空格</h3><pre><code>SELECT    last_name 姓,    first_name 名 FROM    employees;</code></pre><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><p>查询员工表中涉及到的所有的部门编号</p><pre><code>SELECT DISTINCT    department_id FROM    employees;</code></pre><h2 id="号运算符"><a href="#号运算符" class="headerlink" title="+ 号运算符"></a>+ 号运算符</h2><blockquote><p>select 100+90;   两个操作数都为数值型，则做加法运算</p><p>select ‘123’+90;   只要其中一方为字符型，试图将字符型数值转换成数值型。如果转换成功，则继续做加法运算<br>select ‘john’+90;   如果转换失败，则将字符型数值转换成0</p><p>select null+10;   只要其中一方为 null，则结果肯定为 null</p></blockquote><p>查询员工名和姓连接成一个字段，并显示为姓名</p><pre><code>SELECT    CONCAT( last_name, first_name ) AS 姓名 FROM    employees;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>4.MySQL常见函数</title>
      <link href="/2019/09/25/mysql/chang-jian-han-shu/"/>
      <url>/2019/09/25/mysql/chang-jian-han-shu/</url>
      
        <content type="html"><![CDATA[<h2 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h2><p><code>length</code> 获取参数值的字节个数</p><pre><code>SELECT    LENGTH( 'john' );</code></pre><p><code>concat</code> 拼接字符串</p><pre><code>SELECT    CONCAT( last_name, '_', first_name ) 姓名 FROM    employees;</code></pre><p><code>upper</code>、<code>lower</code>将姓变大写，名变小写，然后拼接</p><pre><code>SELECT    CONCAT( UPPER( last_name ), LOWER( first_name ) ) 姓名 FROM    employees;</code></pre><p><code>substr</code>、<code>substring</code></p><p>截取从指定索引处后面所有字符（注意：索引是从1开始的）</p><pre><code>SELECT    SUBSTR( '李莫愁爱上了陆展元', 7 ) out_put;</code></pre><p>截取从指定索引处指定字符长度的字符</p><pre><code>SELECT    SUBSTR( '李莫愁爱上了陆展元', 1, 3 ) out_put;</code></pre><p>姓名中首字符大写，其他字符小写然后用_拼接，显示出来</p><pre><code>SELECT    CONCAT( UPPER( SUBSTR( last_name, 1, 1 ) ), '_', LOWER( SUBSTR( last_name, 2 ) ) ) out_put FROM    employees;</code></pre><p><code>instr</code> 返回子串第一次出现的索引，如果找不到返回0</p><pre><code>SELECT    INSTR( '杨不殷六侠悔爱上了殷六侠', '殷六侠' ) AS out_put;</code></pre><p><code>trim</code>去除首尾空格，<code>ltrim</code>和<code>rtrim</code>分别是去除左边和右边的空格</p><pre><code>SELECT    TRIM( '    张翠   山  ' ) AS out_put;</code></pre><p><code>lpad</code> 用指定的字符实现左填充指定长度，<code>rpad</code> 用指定的字符实现右填充指定长度</p><pre><code>SELECT    RPAD( '殷素素', 12, 'ab' ) AS out_put;</code></pre><p><code>replace</code> 替换</p><pre><code>SELECT REPLACE    ( '周芷若周芷若周芷若周芷若张无忌爱上了周芷若', '周芷若', '赵敏' ) AS out_put;</code></pre><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><p><code>round</code> 四舍五入</p><pre><code>SELECT    ROUND( - 1.55 );</code></pre><pre><code>SELECT    ROUND( 1.567, 2 );</code></pre><p><code>ceil</code> 向上取整，返回 &gt;= 该参数的最小整数</p><pre><code>SELECT    CEIL( - 1.02 );</code></pre><p><code>floor</code> 向下取整，返回 &lt;= 该参数的最大整数</p><pre><code>SELECT    FLOOR( - 9.99 );</code></pre><p><code>truncate</code> 截断</p><pre><code>SELECT TRUNCATE    ( 1.69999, 1 );</code></pre><p><code>mod</code>取模</p><pre><code>SELECT MOD    ( 10,- 3 );</code></pre><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><p><code>now</code> 返回当前系统日期+时间</p><pre><code>SELECT    NOW( );</code></pre><p><code>curdate</code> 返回当前系统日期，不包含时间</p><pre><code>SELECT    CURDATE( );</code></pre><p><code>curtime</code> 返回当前时间，不包含日期</p><pre><code>SELECT    CURTIME( );</code></pre><p>可以获取指定的部分，年、月、日、小时、分钟、秒</p><pre><code>SELECT YEAR    ( hiredate ) 年 FROM    employees;</code></pre><p><code>str_to_date</code> 将字符通过指定的格式转换成日期</p><pre><code>SELECT    STR_TO_DATE( '1998-3-2', '%Y-%c-%d' ) AS out_put;</code></pre><p>查询入职日期为1992-4-3的员工信息</p><pre><code>SELECT    * FROM    employees WHERE    hiredate = '1992-4-3';</code></pre><pre><code>SELECT    * FROM    employees WHERE    hiredate = STR_TO_DATE( '4-3 1992', '%c-%d %Y' );</code></pre><p><code>date_format</code> 将日期转换成字符</p><pre><code>SELECT    DATE_FORMAT( NOW( ), '%y年%m月%d日' ) AS out_put;</code></pre><p>查询有奖金的员工名和入职日期(xx月/xx日 xx年)</p><pre><code>SELECT    last_name,    DATE_FORMAT( hiredate, '%m月/%d日 %y年' ) 入职日期 FROM    employees WHERE    commission_pct IS NOT NULL;</code></pre><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><p><code>if</code> 函数</p><pre><code>SELECTIF    ( 10 &lt; 5, '大', '小' );</code></pre><pre><code>SELECT    last_name,    commission_pct,IF    ( commission_pct IS NULL, '没奖金，呵呵', '有奖金，嘻嘻' ) 备注 FROM    employees;</code></pre><p><code>case</code> 函数</p><blockquote><p>case 要判断的字段或表达式<br>when 常量1 then 要显示的值1或语句1;<br>when 常量2 then 要显示的值2或语句2;<br>…<br>else 要显示的值n或语句n;<br>end</p></blockquote><p>查询员工的工资，要求：部门号=30，显示的工资为1.1倍；部门号=40，显示的工资为1.2倍；部门号=50，显示的工资为1.3倍；其他部门，显示的工资为原工资。</p><pre><code>SELECT    salary 原始工资,    department_id,CASE        department_id         WHEN 30 THEN        salary * 1.1         WHEN 40 THEN        salary * 1.2         WHEN 50 THEN        salary * 1.3 ELSE salary     END AS 新工资 FROM    employees;</code></pre><p>查询员工的工资的情况，如果工资&gt;20000,显示A级别；如果工资&gt;15000,显示B级别；如果工资&gt;10000，显示C级别；否则，显示D级别。</p><pre><code>SELECT    salary,CASE        WHEN salary &gt; 20000 THEN        'A'         WHEN salary &gt; 15000 THEN        'B'         WHEN salary &gt; 10000 THEN        'C' ELSE 'D'     END AS 工资级别 FROM    employees;</code></pre><h2 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h2><pre><code>SELECT    SUM( salary ) 和,    ROUND( AVG( salary ), 2 ) 平均,    MAX( salary ) 最高,    MIN( salary ) 最低,    COUNT( salary ) 个数 FROM    employees;</code></pre><pre><code>SELECT    COUNT( * ) FROM    employees;</code></pre><pre><code>SELECT    COUNT( 1 ) FROM    employees;</code></pre><blockquote><p>效率： MYISAM 存储引擎下 ， COUNT( * ) 的效率高 INNODB 存储引擎下， COUNT( * ) 和 COUNT( 1 ) 的效率差不多，比 COUNT( 字段 ) 要高一些</p></blockquote><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>5.MySQL分组查询</title>
      <link href="/2019/09/25/mysql/fen-zu-cha-xun/"/>
      <url>/2019/09/25/mysql/fen-zu-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="简单的分组"><a href="#简单的分组" class="headerlink" title="简单的分组"></a>简单的分组</h2><p>查询每个工种的员工平均工资</p><pre><code>SELECT    AVG( salary ),    job_id FROM    employees GROUP BY    job_id;</code></pre><p>查询每个位置的部门个数</p><pre><code>SELECT    COUNT( * ),    location_id FROM    departments GROUP BY    location_id;</code></pre><h2 id="分组前的筛选"><a href="#分组前的筛选" class="headerlink" title="分组前的筛选"></a>分组前的筛选</h2><p>查询邮箱中包含 a 字符的每个部门的最高工资</p><pre><code>SELECT    MAX( salary ),    department_id FROM    employees WHERE    email LIKE '%a%' GROUP BY    department_id;</code></pre><p>查询有奖金的每个领导手下员工的平均工资</p><pre><code>SELECT    AVG( salary ),    manager_id FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    manager_id;</code></pre><h2 id="分组后的筛选"><a href="#分组后的筛选" class="headerlink" title="分组后的筛选"></a>分组后的筛选</h2><p>查询员工个数 &gt;5 的部门并统计员工个数</p><pre><code>SELECT    COUNT( * ),    department_id FROM    employees GROUP BY    department_id HAVING    COUNT( * ) &gt; 5;</code></pre><p>查询有奖金员工并且最高工资 &gt;12000 的员工并统计工种编号和最高工资</p><pre><code>SELECT    job_id,    MAX( salary ) FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    job_id HAVING    MAX( salary ) &gt; 12000;</code></pre><h2 id="添加排序"><a href="#添加排序" class="headerlink" title="添加排序"></a>添加排序</h2><p>统计每个工种有奖金员工的最高工资 &gt;6000 的工种编号和最高工资，按最高工资升序</p><pre><code>SELECT    job_id,    MAX( salary ) m FROM    employees WHERE    commission_pct IS NOT NULL GROUP BY    job_id HAVING    m &gt; 6000 ORDER BY    m;</code></pre><h2 id="按多个字段分组"><a href="#按多个字段分组" class="headerlink" title="按多个字段分组"></a>按多个字段分组</h2><p>查询每个工种每个部门的最低工资，并按最低工资降序</p><pre><code>SELECT    MIN( salary ),    job_id,    department_id FROM    employees GROUP BY    department_id,    job_id ORDER BY    MIN( salary ) DESC;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>3.MySQL排序查询</title>
      <link href="/2019/09/25/mysql/pai-xu-cha-xun/"/>
      <url>/2019/09/25/mysql/pai-xu-cha-xun/</url>
      
        <content type="html"><![CDATA[<h2 id="按单个字段排序"><a href="#按单个字段排序" class="headerlink" title="按单个字段排序"></a>按单个字段排序</h2><pre><code>SELECT    * FROM    employees ORDER BY    salary DESC;</code></pre><h2 id="添加筛选条件再排序"><a href="#添加筛选条件再排序" class="headerlink" title="添加筛选条件再排序"></a>添加筛选条件再排序</h2><p>查询部门编号&gt;=90的员工信息，并按员工编号降序</p><pre><code>SELECT    * FROM    employees WHERE    department_id &gt;= 90 ORDER BY    employee_id DESC;</code></pre><h2 id="按表达式排序"><a href="#按表达式排序" class="headerlink" title="按表达式排序"></a>按表达式排序</h2><p>查询员工信息，按年薪降序</p><pre><code>SELECT    *,    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) FROM    employees ORDER BY    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) DESC;</code></pre><h2 id="按别名排序"><a href="#按别名排序" class="headerlink" title="按别名排序"></a>按别名排序</h2><p>查询员工信息，按年薪升序</p><pre><code>SELECT    *,    salary * 12 * ( 1+ IFNULL( commission_pct, 0 ) ) 年薪 FROM    employees ORDER BY    年薪 ASC;</code></pre><h2 id="按函数排序"><a href="#按函数排序" class="headerlink" title="按函数排序"></a>按函数排序</h2><p>查询员工名，并且按名字的长度降序</p><pre><code>SELECT    LENGTH( last_name ),    last_name FROM    employees ORDER BY    LENGTH( last_name ) DESC;</code></pre><h2 id="按多个字段排序"><a href="#按多个字段排序" class="headerlink" title="按多个字段排序"></a>按多个字段排序</h2><p>查询员工信息，要求先按工资降序，再按 employee_id 升序</p><pre><code>SELECT    * FROM    employees ORDER BY    salary DESC,    employee_id ASC;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>7.MySQL分页查询</title>
      <link href="/2019/09/25/mysql/fen-ye-cha-xun/"/>
      <url>/2019/09/25/mysql/fen-ye-cha-xun/</url>
      
        <content type="html"><![CDATA[<p><code>offset</code> 要显示条目的起始索引（起始索引从0开始）</p><p><code>size</code> 要显示的条目个数</p><p><code>limit</code> 语句放在查询语句的最后</p><p>如果要显示的页数为 <code>page</code>，每页的条目数为 <code>size</code>，那么当前页的公式为：</p><pre><code>select 查询列表from 表limit (page-1)*size,size;</code></pre><p>查询前五条员工信息</p><pre><code>SELECT    * FROM    employees     LIMIT 5;</code></pre><p>查询第11条记录到第25条记录</p><pre><code>SELECT    * FROM    employees     LIMIT 10,    15;</code></pre><p>查询有奖金的员工信息，并且工资较高的前10名显示出来</p><pre><code>SELECT    * FROM    employees WHERE    commission_pct IS NOT NULL ORDER BY    salary DESC     LIMIT 10;</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MySQL行列转换</title>
      <link href="/2019/09/25/mysql/xing-lie-zhuan-huan/"/>
      <url>/2019/09/25/mysql/xing-lie-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<p>有如下 t_score 表：</p><pre><code>CREATE TABLE t_score (    id INT PRIMARY KEY auto_increment,    name VARCHAR ( 20 ) NOT NULL,        #名字    subject VARCHAR ( 10 ) NOT NULL,    #科目    score DOUBLE DEFAULT 0                 #分数);</code></pre><p>我们插入几条数据：</p><pre><code>INSERT INTO `t_score` ( name, subject, score )VALUES    ( '张三', '语文', 86 ),    ( '张三', '数学', 83 ),    ( '张三', '英语', 93 ),    ( '李四', '语文', 88 ),    ( '李四', '数学', 84 ),    ( '李四', '英语', 94 ),    ( '王五', '语文', 80 ),    ( '王五', '数学', 86 ),    ( '王五', '英语', 88 ),    ( '赵六', '语文', 89 ),    ( '赵六', '数学', 80 ),    ( '赵六', '英语', 87 );</code></pre><p>原来的表格是这样的：</p><table><thead><tr><th>id</th><th>name</th><th>subject</th><th>score</th></tr></thead><tbody><tr><td>1</td><td>张三</td><td>语文</td><td>86</td></tr><tr><td>2</td><td>张三</td><td>数学</td><td>83</td></tr></tbody></table><p>希望转换成这样的：</p><table><thead><tr><th>姓名</th><th>语文</th><th>数学</th><th>英文</th><th>总分</th></tr></thead><tbody><tr><td>张三</td><td>86</td><td>83</td><td>93</td><td></td></tr><tr><td>李四</td><td>88</td><td>84</td><td>94</td><td></td></tr><tr><td>科目平均分</td><td></td><td></td><td></td><td></td></tr></tbody></table><pre><code>SELECT     name AS 姓名,    sum( IF ( subject = '语文', score, 0 ) ) AS 语文,    sum( IF ( subject = '数学', score, 0 ) ) AS 数学,    sum( IF ( subject = '英语', score, 0 ) ) AS 英语,    sum( score ) AS 总分 FROM    t_score GROUP BY name UNIONSELECT     name AS 姓名,    round( AVG( chinese ), 2 ),    round( AVG( math ), 2 ),    round( AVG( english ), 2 ),    "" FROM    (    SELECT        '科目平均分' AS NAME,        sum( IF ( subject = '语文', score, 0 ) ) AS chinese,        sum( IF ( subject = '数学', score, 0 ) ) AS math,        sum( IF ( subject = '英语', score, 0 ) ) AS english,        sum( score ) AS 总分     FROM        t_score     GROUP BY subject     ) t</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java内存区域划分</title>
      <link href="/2019/09/11/java-nei-cun-qu-yu/"/>
      <url>/2019/09/11/java-nei-cun-qu-yu/</url>
      
        <content type="html"><![CDATA[<p>Java虚拟机所管理的内存将会包括以下几个运行时数据区域。</p><p><img src="/images/Snipaste_2019-09-11_16-38-08.png" alt=""></p><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p><p>由于 Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）都只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</p><p>如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 Native 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OutOfMemoryError 情况的区域。</p><h2 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h2><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。</p><p>所谓的“栈内存”就是指虚拟机栈，或者说虚拟机栈中局部变量表部分。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。</p><p>在 Java 虚拟机规范中，对这个区域规定了两种异常状况：</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError 异常；</li><li>如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出 OutOfMemoryError 异常。</li></ul><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈所发挥的作用是非常相似的，它们之间的区别不过是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</p><p>在虚拟机规范中对本地方法栈中方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机直接就把本地方法栈和虚拟机栈合二为一。</p><p>与虚拟机栈一样，本地方法栈区域也会抛出 StackOverflowError 和 OutOfMemoryError 异常。</p><h2 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h2><p>Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（Garbage Collected Heap）。从内存回收的角度来看，由于现在收集器基本都采用分代收集算法，所以 Java 堆中还可以细分为：新生代和老年代；再细致一点的有 Eden 空间、From Survivor 空间、To Survivor 空间等。</p><p>不过无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的。</p><p>如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出 OutOfMemoryEror 异常。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 Non-Heap（非堆），目的应该是与 Java 堆区分开来。</p><p>当方法区无法满足内存分配需求时，将抛出 OutOfMemoryError 异常。</p><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池（Constant Pool Table），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浏览器地址栏输入URL发生了什么</title>
      <link href="/2019/09/10/liu-lan-qi-shang-shu-ru-url-fa-sheng-liao-shi-me/"/>
      <url>/2019/09/10/liu-lan-qi-shang-shu-ru-url-fa-sheng-liao-shi-me/</url>
      
        <content type="html"><![CDATA[<p>整个Web请求分为两个步骤，分别为资源获取和页面渲染。</p><p><img src="/images/Snipaste_2019-09-10_19-10-55.png" alt=""></p><p>资源获取流程：</p><p>（1）把待请求URL放入队列</p><p>（2）解析URL中域名的IP地址<strong>（A）</strong></p><p>（3）建立与目标主机的TCP连接<strong>（B）</strong></p><p>（4）如果是HITPS请求，初始化并完成TLS握手<strong>（C）</strong></p><p>（5）向页面对应的URL发送请求</p><p><img src="/images/Snipaste_2019-09-10_19-11-11.png" alt=""></p><p>页面渲染流程：</p><p>（6）接收响应</p><p>（7）如果（接收的）是主体HTML，那么解析它，并针对页面中的资源触发优先获取机制<strong>（A）</strong></p><p>（8）如果页面上的关键资源已经接收到，就开始渲染页面<strong>（B）</strong></p><p>（9）接收其他资源，继续解析渲染，直到结束<strong>（C）</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DNS解析和负载均衡</title>
      <link href="/2019/09/09/dns-jie-xi-he-fu-zai-jun-heng/"/>
      <url>/2019/09/09/dns-jie-xi-he-fu-zai-jun-heng/</url>
      
        <content type="html"><![CDATA[<h1 id="DNS-解析"><a href="#DNS-解析" class="headerlink" title="DNS 解析"></a>DNS 解析</h1><p>DNS解析过程如下：</p><ol><li>浏览器首先检查缓存中有没有这个域名对应的解析过的 IP 地址，如果缓存中有，这个解析过程就会结束。</li><li>如果用户的浏览器缓存中没有，浏览器会查找操作系统缓存中是否存在这个域名对应的 DNS 解析结果。</li><li>请求真正的域名服务器，通常是 LDNS ，也就是本地区的域名服务器。</li><li>如果 LDNS 仍然没有命中，就直接到 Root Server 域名服务器请求解析。</li><li>根域名服务器返回给本地域名服务器一个所查询域的主域名服务器（gTLD国际顶级域名服务器）地址。</li><li>本地域名服务器再向上一步返回的 gTLD 服务器发送请求。</li><li>接收请求的 gTLD 服务器查找并返回此域名对应的 Name Server 域名服务器的地址，这个Name Server 通常就是你注册的域名服务器。</li><li>Name Server 域名服务器会查询存储的域名和 IP 的映射关系表，在正常情况下都根据域名得到目标 IP 记录，连同一个TTL 值返回给 DNS Server 域名服务器。</li><li>返回该域名对应的 IP 和 TTL 值，LDNS 会缓存这个域名和 IP 的对应关系，缓存的时间由 TTL 控制。</li><li>把解析的结果返回给用户，用户根据 TTL 值缓存在本地系统缓存中，域名解析过程结束。</li></ol><h1 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h1><h2 id="负载均衡作用"><a href="#负载均衡作用" class="headerlink" title="负载均衡作用"></a>负载均衡作用</h2><p>负载均衡的作用主要有如下两点：</p><ul><li>提高服务器的响应速度</li><li>避免软件或硬件出现单点故障</li></ul><h2 id="负载均衡架构"><a href="#负载均衡架构" class="headerlink" title="负载均衡架构"></a>负载均衡架构</h2><h3 id="链路负载均衡"><a href="#链路负载均衡" class="headerlink" title="链路负载均衡"></a>链路负载均衡</h3><p>所谓链路负载均衡，是指通过 DNS 解析成不同 IP，然后用户根据这个 IP 来访问不同的目标服务器。</p><p>负载均衡是由 DNS 解析来完成的，用户最终访问哪个 Web Server 是由 DNS Server 来动态解析域名的。</p><p><strong>优点：</strong></p><p>用户会直接访问目标服务器，而不需要经过其他的代理服务器，通常访问速度会更快。</p><p><strong>缺点：</strong></p><p>由于 DNS 在用户本地和 Local DNS Server 都有缓存，一旦某台 Web Server 挂掉，就很难及时更新用户的域名解析结构。如果用户的域名没有及时更新，那么用户无法访问这个域名，带来后果非常严重。</p><p>DNS 负载均衡参考如下：</p><p><img src="/images/Snipaste_2019-09-09_14-31-38.png" alt=""></p><h3 id="集群负载均衡"><a href="#集群负载均衡" class="headerlink" title="集群负载均衡"></a>集群负载均衡</h3><p>集群负载均衡分为硬件负载均衡和软件负载均衡。</p><h4 id="硬件负载均衡"><a href="#硬件负载均衡" class="headerlink" title="硬件负载均衡"></a>硬件负载均衡</h4><p>硬件负载均衡就是用一个硬件一个基础网络设备，类似我们的交换机啊这样的硬件，来实现负载均衡。常见的硬件有 F5、A10。</p><p><strong>优点：</strong></p><ul><li>功能强大，支持全局负载均衡提供全面的复杂均衡算法。</li><li>性能强悍，支持百万以上的并发。</li><li>提供安全功能，例如防火墙，防 DDos 攻击等。</li></ul><p><strong>缺点：</strong></p><ul><li>价格昂贵</li><li>扩展能力差</li></ul><h4 id="软件负载均衡"><a href="#软件负载均衡" class="headerlink" title="软件负载均衡"></a>软件负载均衡</h4><p>软件负载均衡是通过负载均衡功能的软件来实现负载均衡，常见的软件有 LVS、Nginx、HAProxy。</p><p>软件负载负载均衡又分四层和七层负载均衡。</p><p>四层负载均衡就是在网络层利用 IP 地址+端口进行请求的转发。通过发布三层的 IP 地址（VIP），然后加四层的端口号，来决定哪些流量需要做负载均衡，对需要处理的流量进行 NAT 处理，转发至后台服务器，并记录下这个 TCP 或者 UDP 的流量是由哪台服务器处理的，后续这个连接的所有流量都同样转发到同一台服务器处理。</p><p>七层负载均衡就是可以根据访问用户的 HTTP 请求头、URL 信息将请求转发到特定的主机。也就是在四层的基础上，再考虑应用层的特征，比如同一个Web服务器的负载均衡，除了根据 VIP 加 80 端口辨别是否需要处理的流量，还可根据七层的 URL、浏览器类别、语言来决定是否要进行负载均衡。举个例子，如果你的 Web 服务器分成两组，一组是中文语言的，一组是英文语言的，那么七层负载均衡就可以当用户来访问你的域名时，自动辨别用户语言，然后选择对应的语言服务器组进行负载均衡处理。</p><p>常见的 LVS 为四层负载均衡，Nginx 和 HAProxy 可以作为四层负载均衡，也可以作为七层负载均衡。</p><p>软件负载均衡参考如下：</p><p><img src="/images/Snipaste_2019-09-09_14-24-09.png" alt=""></p><p><strong>优点：</strong></p><p>使用成本低，直接使用廉价的 PC 就可以搭建。</p><p><strong>缺点：</strong></p><ul><li><p>一次访问请求要经过多次代理服务器，会增加网络延时。</p></li><li><p>没有防火墙或者防DDos攻击等安全性功能。</p></li></ul><h3 id="操作系统负载均衡"><a href="#操作系统负载均衡" class="headerlink" title="操作系统负载均衡"></a>操作系统负载均衡</h3><p>利用操作系统级别的软中断或者硬件中断来达到负载均衡，如可以设置多队列网卡来实现。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> DNS </tag>
            
            <tag> CDN </tag>
            
            <tag> 负载均衡 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSRF攻击</title>
      <link href="/2019/09/06/csrf-gong-ji/"/>
      <url>/2019/09/06/csrf-gong-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><img src="/images/Snipaste_2019-09-06_17-43-41.png" alt=""></p><p>由于浏览器会带上用户C的 cookie，站点A不知道步骤5的请求是B发出的，因此站点A会根据用户C的权限处理步骤5的请求，这样B就达到了伪造用户C请求的目的。</p><h2 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h2><p><strong>将 cookie 设置为 HttpOnly</strong></p><p>Java的 Servlet 设置 cookie 为 HttpOnly 的代码如下：</p><pre><code>response.setHeader("Set-Cookie", "cookiename=cookievalue;HttpOnly");</code></pre><p><strong>增加token</strong></p><p>在 Http 请求中加入一个随机产生的 token，并在服务器端进行 token 校验，如果请求中没有 token 或者 token 内容不正确，则认为是 CSRF 攻击而拒绝该请求。</p><p><strong>通过 Referer 识别</strong></p><p>取得 Http 请求 Referer：</p><pre><code>String referer = request.getHeader("Referer");</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 网络 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Netty线程模型</title>
      <link href="/2019/09/05/netty-xian-cheng-mo-xing/"/>
      <url>/2019/09/05/netty-xian-cheng-mo-xing/</url>
      
        <content type="html"><![CDATA[<p>Netty 的线程模型是基于 NIO 的 Selector 构建的，使用了异步驱动的 Reactor 模式来构建的线程模型。</p><p>Reactor线程模型分为以下三种。</p><h2 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h2><p>  <img src="/images/Snipaste_2019-09-05_19-19-24.png" alt=""></p><p> 所有操作都在同一个NIO线程处理，在这个单线程中要负责接收请求，处理IO，编解码所有操作，相当于一个饭馆只有一个人，同时负责前台和后台服务，效率低。</p><h2 id="多线程模型"><a href="#多线程模型" class="headerlink" title="多线程模型"></a>多线程模型</h2><p><img src="/images/Snipaste_2019-09-05_19-24-49.png" alt=""></p><p>多线程的优点在于有单独的一个线程去处理请求，另外有一个线程池创建多个NIO线程去处理IO。相当于一个饭馆有一个前台负责接待，有很多服务员去做后面的工作，这样效率就比单线程模型提高很多。</p><h2 id="主从线程模型"><a href="#主从线程模型" class="headerlink" title="主从线程模型"></a>主从线程模型</h2><p><img src="/images/Snipaste_2019-09-05_19-25-44.png" alt=""></p><p>多线程模型的缺点在于并发量很高的情况下，只有一个Reactor单线程去处理是来不及的，就像饭馆只有一个前台接待很多客人也是不够的。为此需要使用主从线程模型。</p><p>主从线程模型：一组线程池接收请求，一组线程池处理IO。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Netty </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>《原则》感悟</title>
      <link href="/2019/08/25/yuan-ze-gan-wu/"/>
      <url>/2019/08/25/yuan-ze-gan-wu/</url>
      
        <content type="html"><![CDATA[<p><strong>你要自己去思考现实是什么</strong></p><p><strong>拥抱现实，处理现实</strong></p><p><strong>事实是产生好结果的必要部分</strong></p><p><strong>dream + reality + determination = a successful life</strong></p><p><strong>pain + reflection = progress</strong></p><p><strong>拥抱现实，并与之打交道，我得到了回报和快乐，痛苦也消失了。反思自己身边的环境，反思自己的个人进步</strong></p><p><strong>成功的五个步骤：</strong></p><ol><li>了解你的目标，然后朝其努力</li><li>找到那些阻碍实现目标的问题</li><li>识别出这些问题的根本原因，不要太快提出解决方案，要退一步思考，以区分出病状和病因</li><li>设计一个解决问题的方案</li><li>执行这些方案，向自己的目标前进</li></ol><p><strong>每个人都会面临的两大障碍：</strong></p><ul><li>自我障碍：阻止你客观承认弱点的那部分大脑</li><li>盲点障碍：人们无法欣赏他们看不到的东西</li></ul><p>用<strong>学习什么是事实</strong>取代<strong>证明自己是对的</strong>。因此需要找到那些<strong>善于思考</strong>，而又<strong>不同意自己观点</strong>的人。我们<strong>不关心他们的结论</strong>，我们只是想<strong>通过他们的眼睛看事物</strong>，并让他们<strong>透过我们的眼睛看事物</strong>，这样我们就可以把事情搞清楚，来确定什么是真相。换句话说，我们更想从他们那里得到的是<strong>深思熟虑后的反对意见</strong>。不仅是用自己的角度看事情，还通过这些<strong>有思想的人看事物</strong>。就像看事物的正反面，从而看到<strong>事物的全貌</strong>。</p><p><strong>与有洞察力、但看待事物角度不同的人一同前行</strong></p><p><strong>成功不是要实现目标，而是达到更高的成功层次</strong></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>spring5.0.x源码编译问题</title>
      <link href="/2019/08/13/spring/spring5.0.x-yuan-ma-bian-yi-wen-ti/"/>
      <url>/2019/08/13/spring/spring5.0.x-yuan-ma-bian-yi-wen-ti/</url>
      
        <content type="html"><![CDATA[<p>在<code>spring-beans.gradle</code>中第30行出现</p><blockquote><p>What went wrong:<br>A problem occurred evaluating project ‘:spring-beans’.<br>No such property: values for class: org.gradle.api.internal.tasks.DefaultTaskDependency<br>Possible solutions: values</p></blockquote><p>解决方法：网上有说是把<code>compileGroovy.dependsOn = compileGroovy.taskDependencies.values - "compileJava"</code>注释掉。<br>但当你注释完后还会出现如下错误：</p><blockquote><p>What went wrong:<br>Circular dependency between the following tasks:<br>:spring-beans:compileGroovy<br>-– :spring-beans:compileJava<br>   -– :spring-beans:compileKotlin<br>        -– :spring-beans:compileGroovy (*)</p></blockquote><p>真正的解决方法是：<br>注释掉</p><pre><code>compileGroovy.dependsOn = compileGroovy.taskDependencies.values - "compileJava"</code></pre><p>添加</p><pre><code>def deps = compileGroovy.taskDependencies.immutableValues + compileGroovy.taskDependencies.mutableValuescompileGroovy.dependsOn = deps - 'compileJava'</code></pre><p>如果出现控制台中文乱码，可以在VM options中添加<code>-Dfile.encoding=UTF-8</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring Framwork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础操作</title>
      <link href="/2019/08/10/mysql-ji-chu-cao-zuo/"/>
      <url>/2019/08/10/mysql-ji-chu-cao-zuo/</url>
      
        <content type="html"><![CDATA[<p>information_schema：存储系统中一些数据库对象信息，比如用户表信息、列信息、权限信息、字符集信息、分区信息</p><p>cluster：存储了系统的集群信息</p><p>mysql：存储了系统的用户权限信息</p><p>test：系统自动创建的测试数据库，任何用户都可以使用</p><h2 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h2><p><code>create database 数据库名</code>：创建数据库</p><p><code>use 数据库名</code>：选择数据库</p><p><code>show tables</code>：查看数据库中的数据表</p><p><code>drop database 数据库名</code>：删除数据库</p><p><code>create table 表名(内容)</code>：创建表</p><p><code>drop table 表名</code>：删除表</p><p><code>desc 表名</code>：用于显示表信息</p><p>为了更全面的查看表信息，可以使用</p><p><code>show create table 表名 \G</code></p><p>\G表示使记录按照字段竖向排列，以便更好地显示内容较长的记录</p><p>alter可用于修改、新增、删除，如下</p><p>修改表字段：</p><p><code>alter table 表名 modify 修改字段名 修改类型</code></p><p>新增表字段：</p><p><code>alter table 表名 add 字段名 类型</code></p><p>删除表字段：</p><p><code>alter table 表名 drop 字段名</code></p><p>字段改名：</p><p><code>alter table 表名 change 原来字段名 修改字段名 修改类型</code></p><p><strong>注意：change和modify都可以修改表定义，不同的是change后面需要写两次列名，不方便，但是change可以修改修改列名称，modify不能</strong></p><p>修改字段排列顺序：</p><p><code>alter table 表名 add 字段名 类型 after 字段名</code></p><p>修改字段放在最前面</p><p><code>alter table 表名 modify 字段名 类型 first</code></p><p>修改表名</p><p><code>alter table 表名 rename 新的表名</code></p><h2 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h2><h3 id="插入记录"><a href="#插入记录" class="headerlink" title="插入记录"></a>插入记录</h3><p><code>insert into 表名(字段1，字段2，字段3) values (值1，值2，值3)</code></p><p>也可以不用指定字段名，但是values后面的顺序需要和字段排列顺序一致</p><p><code>insert into 表名 values(值1，值2，...)</code></p><p>含可空字段、非空但有默认值、自增字段，可以不用写在insert里</p><p>一次插入多条记录，之间用逗号分隔</p><p><code>insert into 表名(字段1，字段2，字段3) values (值1，值2，值3),(值11，值12，值13),...</code></p><h3 id="更新记录"><a href="#更新记录" class="headerlink" title="更新记录"></a>更新记录</h3><p><code>update 表名 set 字段1=值1，字段2=值2,... [where condition]</code></p><h3 id="删除记录"><a href="#删除记录" class="headerlink" title="删除记录"></a>删除记录</h3><p><code>delete from 表名 [where condition]</code></p><p>一次性删除多表</p><p><code>delete t1,t2,...from t1,t2,...[where condition]</code></p><h3 id="查询记录"><a href="#查询记录" class="headerlink" title="查询记录"></a>查询记录</h3><p><code>select * from 表名 [where condition]</code></p><p>查询不重复记录</p><p><code>select distinct 字段名 from 表名</code></p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p><code>select * from 表名 order by 字段1,字段2,... asc/desc</code></p><p><code>select * from 表名 order by 字段1 asc/desc,字段2 asc/desc,...</code></p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p><code>select ... limit 起始偏移量,显示记录数</code>，默认起始偏移量为0，只需要写显示记录数</p><p>排序后只显示前面n条记录</p><p><code>select * from 表名 order by 字段1,字段2,... asc/desc limit n</code></p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p>下面通过例子说明：</p><p>例如，在emp表中统计公司的总人数</p><p><img src="/images/Snipaste_2019-05-27_11-20-57.png" alt=""></p><p><code>select count(1) from 表名</code></p><p>统</p><p>在此基础上，要统计各个部门的人数</p><p><img src="/images/Snipaste_2019-05-27_11-24-22.png" alt=""></p><p>既要统计各部门人数，又要统计总人数</p><p><img src="/images/Snipaste_2019-05-27_11-26-17.png" alt=""></p><p>统计人数大于1的部门</p><p><img src="/images/Snipaste_2019-05-27_11-27-37.png" alt=""></p><p><strong>having和where的区别：having是对聚合后的结果进行条件过滤，where是在聚合前就对记录进行过滤</strong></p><p>统计所有人的薪水总额，最高和最低薪水</p><p><img src="/images/Snipaste_2019-05-27_11-32-32.png" alt=""></p><h3 id="表连接"><a href="#表连接" class="headerlink" title="表连接"></a>表连接</h3><p>当需要显示多个表中的字段时，就可以使用表连接。从大类上分为<strong>内连接和外连接</strong>，它们之间的区别是，内连接仅选出两张表中互相匹配的记录，而外连接会选出其他不匹配的记录。</p><p>查询所有员工的名字和所在部门，因为员工名称和部门分别存放在表emp和dept中，因此 ，需要使用表连接来进行查询（内连接）：</p><p><img src="/images/Snipaste_2019-05-27_13-25-14.png" alt=""></p><p>外连接又分为<strong>左连接和右连接</strong></p><ul><li><p>左连接：包含所有左边表中的记录甚至是右边表中没有和它匹配的记录</p></li><li><p>右连接：包含所有的右边表中的记录甚至是左边表中没有和它匹配的记录</p></li></ul><p>查询emp中所有用户名和所在部门名称：</p><p>再次之前，先插入一条数据<code>insert into emp values("dony","2005-02-05","2000".4);</code></p><p><img src="G:%5CStudy%5C%E7%AC%94%E8%AE%B0%5CMysql/images/Snipaste_2019-05-27_13-38-17.png" alt=""></p><p>注意到dony为NULL，也就是说，即使emp中的没有对应dept的记录，也会把emp中的信息都列出来</p><p>右连接和左连接类似，两者之间可以互相转化，例如上面的可以改写成下面的右连接：</p><p><img src="/images/Snipaste_2019-05-27_16-04-24.png" alt=""></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><p>某些情况下，当进行查询的时候，需要的条件是另外一个select语句的结果，这个时候，就要用到子查询。用于子查询的关键字包括in、not in、=、!=、exists、not exists等。</p><p>从emp表中查询出所有部门在dept表中的所有记录：</p><p><code>select * from emp where deptno in(select deptno from dept);</code></p><p><img src="/images/Snipaste_2019-05-27_16-14-50.png" alt=""></p><p>上面的子查询还可以转化成表连接：</p><p><code>select emp.* from emp,dept where emp.deptno=dept.deptno;</code></p><p><img src="/images/Snipaste_2019-05-27_16-21-46.png" alt=""></p><h3 id="记录联合"><a href="#记录联合" class="headerlink" title="记录联合"></a>记录联合</h3><p>当我们将两个表的数据按照一定的条件查询出来后，需要将结果合并到一起显示出来，这时，就需要用到union和union all关键字来实现这样的功能。</p><p>union和union all的区别是union all是把结果集直接合并在一起，而union是将union all后的结果进行一次distinct，去除重复记录后的结果。</p><p>将emp和dept表中的部门编号的集合显示出来：</p><p><code>select deptno from emp union all select deptno from dept;</code></p><p><img src="/images/Snipaste_2019-05-27_16-39-36.png" alt=""></p><p>将结果去重后：</p><p><code>select deptno from emp union select deptno from dept;</code></p><p><img src="/images/Snipaste_2019-05-27_16-40-15.png" alt=""></p><h2 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h2><p>创建一个数据库用户u1，具有对我现在操作的数据库(study)所有表的select/insert权限：</p><p><code>grant select,insert on study.* to 'u1'@'localhost' identified by '123';</code></p><p><img src="/images/Snipaste_2019-05-27_17-01-04.png" alt=""></p><p>由于权限变更，现在需要将用户u1的insert权限撤回，只保留select权限</p><p><code>revoke insert on study.* from 'u1'@'localhost';</code></p><p><img src="G:%5CStudy%5C%E7%AC%94%E8%AE%B0%5CMysql/images/Snipaste_2019-05-27_17-05-19.png" alt=""></p><h2 id="查询元数据信息"><a href="#查询元数据信息" class="headerlink" title="查询元数据信息"></a>查询元数据信息</h2><p>在日常工作中,我们经常会遇到类似下面的应用场景：</p><ul><li><p>删除数据库test1下所有前缀为tmp的表</p></li><li><p>将数据库testl下所有存储引擎为myisam的表改为innodb</p><p>对于这类需求，在MySQL 5.0之前只能通过<code>show tables</code>, <code>show create table</code>或者<code>show table status</code>等命令来得到指定数据库下的表名和存储引擎，但这些命令显示内容有限且不适合进行字符串的批量编辑。如果表很多，则操作起来非常低效。</p><p>MySQL 5.0之后，提供了一个新的数据库information schema，用来记录MySQL中的元数据信息。元数据指的是数据的数据，比如表名、列名、列类型、索引名等表的各种属性名称。这个库比较特殊，它是一个虚拟数据库，物理上并不存在相关的目录和文件；库里<code>show tables</code>显示的各种“表”也并不是实际存在的物理表，而全部是视图。对于上面的两个需求，可以简单地通过两个命令得到需要的SQL语句:</p></li></ul><p><img src="/images/Snipaste_2019-05-27_17-12-56.png" alt=""></p><p>下面列出一些比较常用的视图：</p><ul><li><p><strong>SCHEMATA</strong>：该表提供了当前mysql实例中所有数据库的信息，<code>show databases</code>的结果取之此表</p></li><li><p><strong>TABLES</strong>：该表提供了关于数据库中的表的信息(包括视图)，详细表述了某个表属于哪个schema、表类型、表引擎、创建时间等信息。<code>show tables from schemaname</code>的结果取之此表</p></li><li><p><strong>COLUMNS</strong>：该表提供了表中的列信息，详细表述了某张表的所有列以及每个列的信息。 <code>show columns from schemaname.tablename</code>的结果取之此表</p></li><li><p><strong>STATISTICS</strong>：该表提供了关于表索引的信息。<code>show index from schemaname.tablename</code>的结果取之此表</p></li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程编程核心技术读书笔记</title>
      <link href="/2019/08/10/duo-xian-cheng-bi-ji/"/>
      <url>/2019/08/10/duo-xian-cheng-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="一、多线程基础"><a href="#一、多线程基础" class="headerlink" title="一、多线程基础"></a>一、多线程基础</h2><h3 id="1-实现多线程的三种方式"><a href="#1-实现多线程的三种方式" class="headerlink" title="1.实现多线程的三种方式"></a>1.实现多线程的三种方式</h3><p>①继承Thread类</p><pre><code>public class MyThread extends Thread {    @Override    public void run() {        super.run();        //......    }}//使用MyThreadMyThread thread = new MyThread();thread.start();</code></pre><p>②实现Runnable接口</p><pre><code>public class MyRunnable implements Runnable {    @Override    public void run() {        //......    }}//使用MyRunnableRunnable runnable = new MyRunnable();Thread thread = new Thread(runnable);thread.start();</code></pre><p>比较这两个方法，用实现<code>Runnable</code>接口的优点在于，如果线程类已经有一个父类了，这时不能再继承自<code>Thread</code>类了，因为Java不支持多继承，但是可以实现<code>Runnable</code>接口来处理。</p><p>由于<code>Thread</code>类也实现了<code>Runnable</code>接口，所以构造函数<code>Thread(Runnable target)</code>不光可以传入<code>Runnable</code>接口的对象，还可以传入<code>Thread</code>类的对象，这告诉我们，可以把一个<code>Thread</code>对象中的<code>run</code>方法交给其他线程调用。</p><p>③实现Callable接口</p><pre><code>public class MyThread implements Callable {    @Override    public Object call() throws Exception {        try {            Thread.sleep(1000);        }catch (InterruptedException e){            e.printStackTrace();        }        System.out.println("这是线程B");        return "thread B";    }}public class Run {    public static void main(String[] args) {        MyThread myThread = new MyThread();        FutureTask futureTask = new FutureTask(myThread);        new Thread(futureTask).start();        System.out.println("这是主线程：begin");        try {            System.out.println("返回结果："+futureTask.get());        }catch (InterruptedException e){            e.printStackTrace();        } catch (ExecutionException e) {            e.printStackTrace();        }        System.out.println("这是主线程：end");    }}//输出：这是主线程：begin这是线程B返回结果：thread B这是主线程：end</code></pre><h3 id="2-实例变量的线程安全"><a href="#2-实例变量的线程安全" class="headerlink" title="2.实例变量的线程安全"></a>2.实例变量的线程安全</h3><p>多线程安全问题三要素: </p><ul><li><p>是否存在多线程环境</p></li><li><p>是否存在共享的数据</p></li><li><p>是否有多条语句同时操作这条数据</p></li></ul><p>经典的抢票示例</p><pre><code>public class MyThread extends Thread {    private int count=5;    @Override    synchronized public void run() {        super.run();        count--;        System.out.println(this.currentThread().getName()+" count="+count);    }}public static void main(String[] args) {        MyThread myThread = new MyThread();        Thread a = new Thread(myThread, "A");        Thread b = new Thread(myThread, "B");        Thread c = new Thread(myThread, "C");        Thread d = new Thread(myThread, "D");        Thread e = new Thread(myThread, "E");        a.start();        b.start();        c.start();        d.start();        e.start();}//打印输出A count=4D count=3E count=2C count=1B count=0</code></pre><p>通过在<code>run</code>方法前加入<code>synchronized</code>关键字后，多个线程会排队处理。当一个线程想要执行同步方法里面的代码时，线程首先尝试去拿这把锁，如果拿到了这把锁，那么这个线程就可以执行<code>synchronized</code>里面的代码，否则多个线程会同时去抢这把锁。</p><p>打印语句是线程安全的，但是如果在打印语句中加入某些在打印之前执行的操作，可能会非线程安全。</p><p>如果将线程对象以构造参数的方式传递给<code>Thread</code>对象时，<code>Thread.currentThread()</code>和<code>this</code>是不同的</p><h3 id="3-停止线程的方法"><a href="#3-停止线程的方法" class="headerlink" title="3.停止线程的方法"></a>3.停止线程的方法</h3><p>（1）使用退出标志，当<code>run</code>方法完成中止线程</p><pre><code>public class RunThread extends Thread {    //退出标志    private boolean isRunning = true;    public boolean isRunning() {        return isRunning;    }    public void setRunning(boolean isRunning) {        this.isRunning = isRunning;    }    @Override    public void run() {        System.out.println("进入run了");        while (isRunning == true) {            System.out.println(Thread.currentThread().getName());            try {                Thread.sleep(1000);            } catch (InterruptedException e) {                e.printStackTrace();            }        }    }}public class Run {    public static void main(String[] args) {        try {            RunThread thread = new RunThread();            thread.start();            Thread.sleep(5000);            thread.setRunning(false);            System.out.println("退出");        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>（2）使用interrupt中断线程（还需要其他条件）</p><p>判断线程停止的方法：</p><ul><li><p>interrupted()方法：测试<strong>当前线程</strong>是否是中断状态，执行完后变为false</p><pre><code>public static boolean interrupted() {        return currentThread().isInterrupted(true);}</code></pre></li><li><p>isinterrupted()方法：测试线程Thread对象是否已经是中断状态，默认不清除状态标志,可以通过重载方法设置清除</p><pre><code>public boolean isInterrupted() {        return isInterrupted(false);}</code></pre><p>①异常法</p><pre><code>public class MyThread extends Thread {    @Override    public void run() {        super.run();        try {            for (int i = 0; i &lt; 500_000; i++) {                if (this.isInterrupted()) {                    System.out.println("已经停止，我要退出");                    throw new InterruptedException();                }                System.out.println("i="+(i+1));            }        } catch (InterruptedException e) {            System.out.println("我被抓了");            e.printStackTrace();        }    }}</code></pre><p>②return法</p><pre><code>public class MyThread extends Thread {    @Override    public void run() {        super.run();        while (true){            if (this.isInterrupted()){                System.out.println("停止");                return;            }        }    }}</code></pre><p>建议使用异常法来停止线程，因为异常可以向上抛，使事件得到传播。</p></li></ul><h3 id="4-线程的暂停和恢复"><a href="#4-线程的暂停和恢复" class="headerlink" title="4.线程的暂停和恢复"></a>4.线程的暂停和恢复</h3><p>暂停<code>suspend()</code>，恢复<code>resume()</code></p><p>缺点：</p><ul><li><p>造成公共的同步对象的独占，使得其他线程无法访问公共同步对象</p><pre><code>public class SynchronizedObject {    synchronized public void sameMethod(){        if (Thread.currentThread().getName().equals("A")){            // A线程永远suspend，其他线程无法进来            Thread.currentThread().suspend();        }    }}</code></pre></li><li><p>暂停导致数据不同步</p></li></ul><h3 id="5-线程的优先级"><a href="#5-线程的优先级" class="headerlink" title="5.线程的优先级"></a>5.线程的优先级</h3><p>Java中线程的优先级分为1~10这10个等级，如果小于1或大于10，那么会抛出异常。</p><p>使用3个常量来预置定义优先级的值</p><pre><code>public final static int MIN_PRIORITY = 1;public final static int NORM_PRIORITY = 5;public final static int MAX_PRIORITY = 10;</code></pre><ul><li><p>继承性</p><p>  在Java中，线程优先级具有继承性，当A线程启动B线程，那么B线程的优先级和A线程相同。当优先级被修改后再继承的话，会继承修改后的优先级</p></li><li><p>规则性</p><p>  高优先级总是大部分先执行完</p></li><li><p>随机性</p><p>  高优先级总是大部分先执行完，但不代表高优先级一定全部都先执行完</p></li></ul><h3 id="6-守护线程（Daemon）"><a href="#6-守护线程（Daemon）" class="headerlink" title="6.守护线程（Daemon）"></a>6.守护线程（Daemon）</h3><p>守护线程是一种特殊的线程，典型的守护线程就是垃圾回收线程（GC），当进程中不存在非守护线程了，则垃圾回收线程就会自动销毁。当最后一个非守护线程结束，守护线程才随着JVM一同结束工作。</p><h3 id="7-私有变量是线程安全的原因"><a href="#7-私有变量是线程安全的原因" class="headerlink" title="7.私有变量是线程安全的原因"></a>7.私有变量是线程安全的原因</h3><p>因为新建类的时候它只会为类中的成员变量开辟空间，而方法只在方法区开辟一个内存空间并且只存一份共用的代码段（变量在堆区，引用在栈区），而方法中的私有变量不会先开辟出内存空间，而是等调用时在对应调用线程中为方法中的变量申请空间，所以有几个线程调用则每个线程就会在自己的线程空间的栈为局部变量申请几个引用同时在堆中为变量再申请对应的空间（即方法内的私有变量有几个线程就在栈中申请几个引用，在堆中申请几个空间），所以多线程在调用时只会处理自己线程内的方法的私有变量，因此，方法内的私有变量是线程安全的。</p><h3 id="8-锁对象"><a href="#8-锁对象" class="headerlink" title="8.锁对象"></a>8.锁对象</h3><p>多个对象多把锁不是同步的，因为<code>synchronized</code>关键字取得的锁是对象锁，不是一段代码或方法当作锁，哪个线程先执行带<code>synchronized</code>的方法，哪个线程就持有该方法所属对象的锁，其他对象就只能等待，前提是多个线程访问同一个对象。</p><p>A线程先持有对象锁，B线程可以异步调用对象中非<code>synchronized</code>类型的方法。</p><p>A线程先持有对象锁，B线程如果调用对象中<code>synchronized</code>类型的其他方法则需等待，等到A线程执行完释放锁才可以调用，也就是同步。</p><p>只要对象不变，对象的属性改变，结果还是同步的。</p><h3 id="9-锁重入"><a href="#9-锁重入" class="headerlink" title="9.锁重入"></a>9.锁重入</h3><p>当一个<code>synchronized</code>方法/块的内部调用本类的其他<code>synchronized</code>方法/块时，可以得到锁。</p><p>当存在父子类继承关系时，子类完全可以通过“可重入锁”调用父类的同步方法。</p><p>这里需要注意，如果父类有<code>synchronized</code>同步方法，子类没有，那么子类是无法继承父类的synchronized的，也就是说<strong>同步无法继承</strong>。</p><h3 id="10-异常释放锁"><a href="#10-异常释放锁" class="headerlink" title="10.异常释放锁"></a>10.异常释放锁</h3><p>当一个线程执行的代码出现异常时，其所持有的锁会自动释放。</p><h3 id="11-synchronized同步代码块"><a href="#11-synchronized同步代码块" class="headerlink" title="11.synchronized同步代码块"></a>11.<code>synchronized</code>同步代码块</h3><p>用关键字<code>synchronized</code>声明的方法在某些情况下是有弊端的，比如A线程调用同步方法执行一个长时间任务，那么B线程必须等待比较长的时间，这种情况可以使用<code>synchronized</code>同步代码块解决。</p><p>同步代码块加在需要地方，如下示例</p><pre><code>public class Task {    private String getData1;    private String getData2;    public void doLongTimeTask(){        try {            System.out.println("start task");            Thread.sleep(3000);            String privateGetData1=Thread.currentThread().getName();            String privateGetData2=Thread.currentThread().getName();            synchronized (this){                getData1=privateGetData1;                getData2=privateGetData2;            }            System.out.println(getData1);            System.out.println(getData2);            System.out.println("end task");        }catch (InterruptedException e){            e.printStackTrace();        }    }}</code></pre><p>上面代码如果用原来的方法将<code>synchronized</code>加在方法上，那么执行两个线程的话，需要执行6s，但是用了<code>synchronized</code>同步代码块后，执行时间只需要3s，这是因为在<code>synchronized</code>同步代码块外的代码是异步的，这样多个线程可以去抢，并不会把Thread.sleep(3000)这条语句锁起来。</p><p>在使用<code>synchronized</code>同步代码块时需要注意，当一个线程访问<code>synchronized</code>同步代码块时，其他线程对同一个对象中所有其他的<code>synchronized</code>同步代码块的访问将被阻塞。</p><h3 id="12-任意对象锁"><a href="#12-任意对象锁" class="headerlink" title="12.任意对象锁"></a>12.任意对象锁</h3><p>之前都是使用synchronized (this)来同步代码块，其实Java还支持对任意对象作为对象监视器来实现同步功能，格式为<code>synchronized</code> (非this对象)</p><p>锁非this对象的好处是：<code>synchronized</code> (非<code>this</code>对象)代码块中的程序与其他同步方法是异步的，不会和其他锁<code>this</code>同步方法争抢<code>this</code>锁，因为我可以创建很多对象，这些对象锁之间是异步的，但是需要注意，对象一定在方法外部，这样才能确保用的是同一个对象锁。</p><p>有如下示例</p><pre><code>public class Example {    private Object anyObject = new Object();    public void a(){        try {            synchronized (anyObject){                System.out.println("a begin");                Thread.sleep(1000);                System.out.println("a end");            }        }catch (InterruptedException e){            e.printStackTrace();        }    }    synchronized public void b(){        System.out.println("b begin");        System.out.println("b end");    }}</code></pre><p>由于<code>a()</code>方法和<code>b()</code>方法的对象监视器不同，a方法是<code>anyObject</code>，b方法是<code>this</code>，所以会出现异步执行的结果。</p><p>同步代码块放在非同步<code>synchronized</code>方法中进行声明并不能保证调用方法的线程的执行顺序性，也就是线程调用方法的顺序是无序的，这样会产生“脏读”问题，使用<code>synchronized</code>(非<code>this</code>对象)同步代码块可以解决“脏读”问题。</p><h3 id="13-静态synchronized同步代码块"><a href="#13-静态synchronized同步代码块" class="headerlink" title="13.静态synchronized同步代码块"></a>13.静态<code>synchronized</code>同步代码块</h3><p><code>synchronized</code>加到<code>static</code>静态方法上是对<code>Class</code>类加锁，加到非<code>static</code>静态方法是给对象加锁。</p><p>即使给的不是同一个对象，在静态同步代码块中，都是同步的，因为<code>Class</code>锁可以对类的所有对象实例起作用。</p><p><code>synchronized(class)</code>代码块的作用和<code>synchronized static</code>方法的作用一样。</p><p>静态同步代码块或方法可以用于创建多个线程时，由于每个线程的对象锁是不一样的，但是Class锁是一样的。</p><h3 id="14-String的常量池特性"><a href="#14-String的常量池特性" class="headerlink" title="14.String的常量池特性"></a>14.<code>String</code>的常量池特性</h3><p>在JVM中具有<code>String</code>常量池缓存的功能，所以下面的结果是<code>true</code></p><pre><code>String a = "a";String b = "a";System.out.println(a == b); // true</code></pre><p>如果把<code>synchronized(string)</code>同步块与<code>String</code>结合使用时，需要注意以下问题：</p><pre><code>public class Service {    public static void print(String stringParam){        try {            synchronized (stringParam){                while (true){                    System.out.println(Thread.currentThread().getName());                    Thread.sleep(1000);                }            }        }catch (InterruptedException e){            e.printStackTrace();        }    }}public class ThreadA extends Thread {    private Service service;    public ThreadA(Service service){        super();        this.service=service;    }    @Override    public void run() {        Service.print("a");    }}public class ThreadB extends Thread {    private Service service;    public ThreadB(Service service){        super();        this.service=service;    }    @Override    public void run() {        Service.print("a");    }}public class Run {    public static void main(String[] args) {        Service service = new Service();        ThreadA a = new ThreadA(service);        a.setName("A");        a.start();        ThreadB b = new ThreadB(service);        b.setName("B");        b.start();    }}</code></pre><p>此时只有A线程执行，出现这样的原因是<code>String</code>的两个值都是a，两个线程持有相同的锁，所以造成线程B不能执行。这就是<code>String</code>常量池带来的问题，因此<code>synchronized</code>代码块不用<code>String</code>作为锁对象，而用其他<code>Object</code>对象。</p><p>现修改代码如下，此时AB线程都可以执行，因为这时候AB持有不同的锁：</p><pre><code>public class Service {    public static void print(Object object){        try {          //用Object作为锁            synchronized (object){                while (true){                    System.out.println(Thread.currentThread().getName());                    Thread.sleep(1000);                }            }        }catch (InterruptedException e){            e.printStackTrace();        }    }}public class ThreadA extends Thread {    private Service service;    public ThreadA(Service service){        super();        this.service=service;    }    @Override    public void run() {      // 这里new Object        Service.print(new Object());    }}</code></pre><h3 id="15-多线程的死锁"><a href="#15-多线程的死锁" class="headerlink" title="15.多线程的死锁"></a>15.多线程的死锁</h3><p>示例如下：</p><pre><code>public class DeadLockThread implements Runnable {    public String name;    public Object lock1 = new Object();    public Object lock2 = new Object();    public void setName(String name) {        this.name = name;    }    @Override    public void run() {        if (name.equals("a")) {            synchronized (lock1) {                System.out.println("name=" + name);                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (lock2) {                    System.out.println("lock1-&gt;lock2");                }            }        }        if (name.equals("b")) {            synchronized (lock2) {                System.out.println("name=" + name);                try {                    Thread.sleep(3000);                } catch (InterruptedException e) {                    e.printStackTrace();                }                synchronized (lock1) {                    System.out.println("lock2-&gt;lock1");                }            }        }    }}public class Run {    public static void main(String[] args) {        try {            DeadLockThread deadLockThread = new DeadLockThread();            deadLockThread.setName("a");            Thread thread1 = new Thread(deadLockThread);            thread1.start();            Thread.sleep(1000);            deadLockThread.setName("b");            Thread thread2 = new Thread(deadLockThread);            thread2.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p>由于<code>lock1</code>在等<code>lock2</code>释放锁，而<code>lock2</code>在等<code>lock1</code>释放锁，从而构成了死锁。</p><h3 id="16-volatile关键字"><a href="#16-volatile关键字" class="headerlink" title="16.volatile关键字"></a>16.<code>volatile</code>关键字</h3><p><code>volatile</code>关键字的作用：使变量在多个线程间可见。</p><p>下面这个示例说明<code>volatile</code>的作用：</p><pre><code>public class RunThread extends Thread {    private boolean isRunning = true;    public boolean isRunning() {        return isRunning;    }    public void setRunning(boolean isRunning) {        this.isRunning = isRunning;    }    @Override    public void run() {        System.out.println("进入run了");        while (isRunning) {            //这里传入任意synchronized同步方法都是可以解决死循环的        }        System.out.println("线程被停止了");    }}public class Run {    public static void main(String[] args) {        try {            RunThread thread = new RunThread();            thread.start();            Thread.sleep(1000);            thread.setRunning(false);            System.out.println("已经赋值为false了");        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><p><img src="/images/1553137318653.png" alt="1553137318653">可以看到程序并没有停止，一直在<code>while</code>死循环中。</p><p>出现这样的结果是因为启动线程时，变量<code>private boolean isRunning = true;</code>存在于公共堆栈及线程的私有堆栈中。但在run中，线程一直在私有堆栈中取得<code>isRunning</code>的值<code>true</code>，而<code>thread.setRunning(false);</code>虽然被执行了，更新的却是公共堆栈中的<code>isRunning</code>变量值<code>false</code>，所以一直都是死循环状态。归根结底，是私有堆栈中的值和公共堆栈中的值不同步造成的，解决办法是使用<code>volatile</code>关键字，让线程强制从公共堆栈中取值。</p><pre><code>volatile private boolean isRunning = true;</code></pre><p>注意到我上面在<code>while</code>循环中的注释，传入任意<code>synchronized</code>同步方法都是可以解决死循环的，这说明<strong>synchronized也能将私有堆栈和公共堆栈中的数据做同步。</strong></p><p>比较<code>synchronized</code>和<code>volatile</code>：</p><ul><li><code>volatile</code>是线程同步的轻量级实现，所以volatile性能比<code>synchronized</code>好，但<code>volatile</code>只能修饰变量，而<code>synchronized</code>可以修饰方法和代码块</li><li>多线程访问<code>volatile</code>不会发生阻塞，而<code>synchronized</code>会出现阻塞</li><li><code>volatile</code>能保证数据的可见性，但不能保证原子性，<code>synchronized</code>可以保证间接可见性和原子性</li><li><code>volatile</code>解决的是变量在多个线程间的可见性，<code>synchronized</code>解决的是多个线程之间访问资源的同步性</li></ul><p>JVM有主内存(Main Memory)和工作内存(Working Memory)，主内存其实就是我们平时说的Java堆内存，存放程序中所有的类实例、静态数据等变量，是多个线程共享的，而工作内存存放的是该线程从主内存中拷贝过来的变量以及访问方法所取得的局部变量，是每个线程私有的其他线程不能访问，每个线程对变量的操作都是以先从主内存将其拷贝到工作内存再对其进行操作的方式进行,多个线程之间不能直接互相传递数据通信,只能通过共享变量来进行。</p><p><img src="/images/1553154446508.png" alt="1553154446508"></p><p>如图：</p><p>read和load阶段：从主存复制变量到当前线程工作内存</p><p>use和assign阶段：执行代码，改变共享变量值</p><p>store和write阶段：用工作内存数据刷新主存对应变量的值</p><p>在多线程环境中，use和assign是多次出现的，但这一操作并不是原子性，也就是在read和load后，如果主内存count变量发生变化后，线程工作内存由于已经load，不会产生对应的变化，也就是私有内存和公共内存中的变量不同步，所以计算出来的结果和预期不一样，也就是出现了非线程安全问题。</p><h3 id="17-原子类"><a href="#17-原子类" class="headerlink" title="17.原子类"></a>17.原子类</h3><p>在进行<code>i++</code>这种操作时，除了使用<code>synchronized</code>关键字实现同步外，还可以使用<code>AtomicInteger</code>原子类进行实现。</p><pre><code>public class AddCountThread extends Thread {    private AtomicInteger count = new AtomicInteger(0);    @Override    public void run() {        for (int i = 0; i &lt; 100; i++) {            System.out.println(count.incrementAndGet());        }    }}public class Run {    public static void main(String[] args) {        AddCountThread addCountThread = new AddCountThread();        Thread t1 = new Thread(addCountThread);        t1.start();        Thread t2 = new Thread(addCountThread);        t2.start();    }}</code></pre><p>但是需要注意，虽然<code>incrementAndGet()</code>方法是原子的，但方法和方法之间的调用却不是原子的，解决的办法是用<code>synchronized</code>做同步。</p><p>如下所示</p><pre><code>public class AddCountThread extends Thread {    private AtomicInteger count = new AtomicInteger(0);    @Override    public void run() {        synchronized (this){            for (int i = 0; i &lt; 100; i++) {                System.out.println(count.incrementAndGet());                System.out.println(count.incrementAndGet());            }        }    }}</code></pre><p>必须加上<code>synchronized</code>代码块或方法，否则原子方法的调用是异步的。</p><h3 id="18-线程的生命周期及状态切换"><a href="#18-线程的生命周期及状态切换" class="headerlink" title="18.线程的生命周期及状态切换"></a>18.线程的生命周期及状态切换</h3><p><img src="/images/1553400692450.png" alt="1553400692450"></p><p>如图所示，</p><p>（1）新创建一个新的线程对象后，再调用它的<code>start()</code>方法，系统会为此线程分配CPU资源，使其处于<code>Runnable</code> (可运行)状态，这是一个准备运行的阶段。如果线程抢占到CPU资源，此线程就处于<code>Running</code> (运行)状态。</p><p>（2） <code>Runnable</code>状态和<code>Running</code>状态可相互切换，因为有可能线程运行一段时间后,有其他高优先级的线程抢占了CPU资源，这时此线程就从<code>Running</code>状态变成<code>Runnable</code>状态。线程进入<code>Rurnable</code>状态大体分为如下5种情况：</p><ul><li><p>调用<code>sleep()</code>方法后经过的时间超过了指定的休眠时间</p></li><li><p>线程调用的阻塞IO已经返回，阻塞方法执行完毕</p></li><li><p>线程成功地获得了试图同步的监视器</p></li><li><p>线程正在等待某个通知,其他线程发出了通知</p></li><li><p>处于挂起状态的线程调用了<code>resume()</code>恢复方法</p></li></ul><p>（3） <code>Blocked</code>是阻塞的意思，例如遇到了一个IO操作，此时CPU处于空闲状态，可能会转而把CPU时间片分配给其他线程，这时也可以称为“暂停”状态。<code>Blocked</code>状态结束后，进入<code>Runnable</code>状态，等待系统重新分配资源。出现阻塞的情况大体分为如下5种：</p><ul><li><p>线程调用<code>sleep</code>方法，主动放弃占用的处理器资源</p></li><li><p>线程调用了阻塞式IO方法，在该方法返回前，该线程被阻塞</p></li><li><p>线程试图获得一个同步监视器，但该同步监视器正被其他线程所持有</p></li><li><p>线程等待某个通知</p></li><li><p>程序调用了<code>suspend</code>方法将该线程挂起。此方法容易导致死锁,尽量避免使用该方法</p></li></ul><p>（4）run()方法运行结束后进入销毁阶段,整个线程执行完毕。</p><p>每个锁对象都有两个队列，一个是就绪队列，一个是阻塞队列。就绪队列存储了将要获得锁的线程，阻塞队列存储了被阻塞的线程。一个线程被唤醒后，才会进入就绪队列，等待CPU的调度；反之，一个线程被wait后，就会进入阻塞队列，等待下一次被唤醒。</p><h3 id="19-线程组"><a href="#19-线程组" class="headerlink" title="19.线程组"></a>19.线程组</h3><p>线程组是为了方便管理线程，线程组机制允许我们通过分组来区分有不同安全特性的线程，对不同组的线程进行不同的管理，还可以通过线程组的分层结构来支持不对等安全措施的采用。</p><p>线程组和线程池的区别：前者是为了方便线程的管理，后者是为了管理线程的生命周期，复用线程，减少创建销毁线程的开销。</p><h3 id="20-线程的异常处理"><a href="#20-线程的异常处理" class="headerlink" title="20.线程的异常处理"></a>20.线程的异常处理</h3><p>对于<code>checked exception</code>我们一般在程序中直接<code>try catch</code>即可，但是遇到<code>unchecked exception</code>，我们就需要自定义一个异常处理器专门去处理非检查型异常，示例如下：</p><pre><code>public class MyThreadExceptionHandler implements Thread.UncaughtExceptionHandler {    @Override    public void uncaughtException(Thread t, Throwable e) {        System.out.println("An exception has been captured");        System.out.printf("Exception: %s: %s\n", e.getClass().getName(), e.getMessage());        System.out.println("Stack Trace");        e.printStackTrace(System.out);        System.out.printf("Thread status: %s\n", t.getState());    }}public class MyThread implements Runnable {    @Override    public void run() {        int a = Integer.parseInt("a");        System.out.println(a);    }}public class Run {    public static void main(String[] args) {        MyThread myThread = new MyThread();        Thread thread = new Thread(myThread);        thread.setUncaughtExceptionHandler(new MyThreadExceptionHandler());        thread.start();    }}//输出An exception has been capturedException: java.lang.NumberFormatException: For input string: "a"Stack Tracejava.lang.NumberFormatException: For input string: "a"    at java.lang.NumberFormatException.forInputString(NumberFormatException.java:65)    at java.lang.Integer.parseInt(Integer.java:580)    at java.lang.Integer.parseInt(Integer.java:615)    at t10.MyThread.run(MyThread.java:11)    at java.lang.Thread.run(Thread.java:748)Thread status: RUNNABLE</code></pre><p>线程组的异常处理如下：</p><pre><code>public class MyThreadGroup extends ThreadGroup {    public MyThreadGroup(String name) {        super(name);    }    @Override    public void uncaughtException(Thread t, Throwable e) {        super.uncaughtException(t, e);        // 中断线程组        this.interrupt();    }}</code></pre><pre><code>public class MyThread extends Thread {    private String num;    public MyThread(ThreadGroup group, String name, String num) {        super(group, name);        this.num = num;    }    @Override    public void run() {        int numInt = Integer.parseInt(num);        while (this.isInterrupted() == false) {            System.out.println("while循环中：" + Thread.currentThread().getName());        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        MyThreadGroup group = new MyThreadGroup("我的线程组");        MyThread[] myThread = new MyThread[10];        for (int i = 0; i &lt; myThread.length; i++) {            myThread[i] = new MyThread(group, "线程" + (i + 1), "1");            myThread[i].start();        }        MyThread thread = new MyThread(group, "报错线程", "a");        thread.start();    }}</code></pre><p>只要有一个线程发生异常，那么此线程组中的所有线程都会中断。</p><h3 id="21-synchronized不同写法的性能比较"><a href="#21-synchronized不同写法的性能比较" class="headerlink" title="21.synchronized不同写法的性能比较"></a>21.<code>synchronized</code>不同写法的性能比较</h3><p>性能和执行效率从小到大：</p><pre><code>public synchronized void method(){    // 方法体}public void method(){    synchronized (this){        // 同步代码块    }}// 因为进入方法体也需要时间，同步代码块的写法更节省时间private byte[] lock = new byte[1];public void method(){    synchronized (lock){        // 自定义对象锁    }}// 因为加锁和释放锁都需要对象的资源，那肯定对象越小越好，所以造个一字节的byte对象最小</code></pre><h2 id="二、线程间的通信"><a href="#二、线程间的通信" class="headerlink" title="二、线程间的通信"></a>二、线程间的通信</h2><h3 id="1-等待-通知机制"><a href="#1-等待-通知机制" class="headerlink" title="1.等待/通知机制"></a>1.等待/通知机制</h3><p><code>wait()</code>方法的作用是使当前执行代码的线程进行等待。在调用<code>wait()</code>之前，线程必须获得该对象的对象级别锁,即只能在同步方法或同步块中调用<code>wait()</code>方法。在执行<code>wait()</code>方法后,当前线程释放锁。在从<code>wait()</code>返回前,线程与其他线程竞争重新获得锁。如果调用<code>wait()</code>时没有持有适当的锁,则抛出<code>llegalMonitorStateException</code>，它是<code>RuntimeException</code>的一个子类，因此，不需要<code>try catch</code>语句进行捕捉异常。方法<code>notify()</code>也要在同步方法或同步块中调用，即在调用前，线程也必须获得该对象的对象级别锁。如果调用<code>notify()</code>时没有持有适当的锁,也会抛出<code>llegalMonitorStateException</code>。该方法用来通知那些可能等待该对象的对象锁的其他线程,如果有多个线程等待,则由线程规划器随机挑选出其中一个呈<code>wait</code>状态的线程,对其发出通知<code>notify</code>,并使它等待获取该对象的对象锁。需要说明的是,在执行<code>notify()</code>方法后,当前线程不会马上释放该对象锁,呈<code>wait</code>状态的线程也并不能马上获取该对象锁,要等到执行<code>notify()</code>方法的线程将程序执行完，也就是退出<code>synchronized</code>代码块后,当前线程才会释放锁,而呈<code>wait</code>状态所在的线程才可以获取该对象锁。当第一个获得了该对象锁的<code>wait</code>线程运行完毕以后,它会释放掉该对象锁,此时如果该对象没有再次使用<code>notify</code>语句,则即便该对象已经空闲,其他<code>wait</code>状态等待的线程由于没有得到该对象的通知,还会继续阻塞在<code>wait</code>状态,直到这个对象发出一个<code>notify</code>或<code>notifyAll</code>。</p><p>用一句话来总结一下<code>wait</code>和<code>notify</code>：<code>wait</code>使线程停止运行，而<code>notify</code>使停止的线程继续。</p><p>请看如下示例</p><pre><code>public class MyList {    private static List list = new ArrayList();    public static void add() {        list.add("any");    }    public static int size() {        return list.size();    }}public class ThreadA extends Thread {    private Object lock;    public ThreadA(Object lock) {        super();        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                if (MyList.size() != 5) {                    System.out.println("wait begin " + System.currentTimeMillis());                    lock.wait();                    System.out.println("wait end " + System.currentTimeMillis());                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class ThreadB extends Thread {    private Object lock;    public ThreadB(Object lock) {        this.lock = lock;    }    @Override    public void run() {        try {            synchronized (lock) {                for (int i = 0; i &lt; 10; i++) {                    MyList.add();                    if (MyList.size() == 5) {                        lock.notify();                        System.out.println("has notified");                    }                    System.out.println("add " + (i + 1) + " element");                    Thread.sleep(1000);                }            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}public class Run {    public static void main(String[] args) {        Object lock = new Object();        ThreadA threadA = new ThreadA(lock);        threadA.start();        ThreadB threadB = new ThreadB(lock);        threadB.start();    }}//输出wait begin 1553399418175add 1 elementadd 2 elementadd 3 elementadd 4 elementhas notifiedadd 5 elementadd 6 elementadd 7 elementadd 8 elementadd 9 elementadd 10 elementwait end 1553399428180</code></pre><p>注意到<code>notify()</code>方法执行后并不立即释放锁，而是执行完<code>notify()</code>方法所在的<code>synchronized</code>同步代码块后才释放锁。</p><h3 id="2-wait和notify"><a href="#2-wait和notify" class="headerlink" title="2.wait和notify"></a>2.<code>wait</code>和<code>notify</code></h3><p>当线程<code>wait</code>时，此时调用<code>interrupt</code>方法会出现<code>InterruptedException</code>异常。</p><p><code>notify()</code>只能随机唤醒一个线程，<code>notifyAll()</code>能唤醒所有<code>waiting</code>的线程。</p><p>带一个参数的<code>wait(long)</code>方法会等待某一时间内是否有线程对锁进行唤醒，如果超过这个时间则自动唤醒。</p><h3 id="3-生产者-消费者模式"><a href="#3-生产者-消费者模式" class="headerlink" title="3.生产者/消费者模式"></a>3.生产者/消费者模式</h3><h4 id="一生产与一消费：操作值"><a href="#一生产与一消费：操作值" class="headerlink" title="一生产与一消费：操作值"></a>一生产与一消费：操作值</h4><pre><code>public class ValueObject {    public static String value = "";}</code></pre><pre><code>public class P {    private String lock;    public P(String lock) {        this.lock = lock;    }    public void setValue() {        try {            synchronized (lock) {                if (!ValueObject.value.equals("")) {                    lock.wait();                }                String value = "value";                System.out.println("set的值是 " + value);                ValueObject.value = value;                lock.notify();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class C {    private String lock;    public C(String lock) {        this.lock = lock;    }    public void getValue() {        try {            synchronized (lock) {                if (ValueObject.value.equals("")) {                    lock.wait();                }                System.out.println("get的值是 " + ValueObject.value);                ValueObject.value = "";                lock.notify();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ThreadP extends Thread {    private P p;    public ThreadP(P p) {        this.p = p;    }    @Override    public void run() {        while (true) {            p.setValue();        }    }}</code></pre><pre><code>public class ThreadC extends Thread {    private C c;    public ThreadC(C c) {        this.c = c;    }    @Override    public void run() {        while (true) {            c.getValue();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        String lock = new String();        P p = new P(lock);        C c = new C(lock);        ThreadP threadP = new ThreadP(p);        ThreadC threadC = new ThreadC(c);        threadP.start();        threadC.start();    }}</code></pre><pre><code>输出结果是循环交替：set的值是 valueget的值是 value</code></pre><h4 id="多生产与多消费：操作值"><a href="#多生产与多消费：操作值" class="headerlink" title="多生产与多消费：操作值"></a>多生产与多消费：操作值</h4><p>多产生与多消费时会出现“假死”的现象，所谓假死就是线程进入<code>waiting</code>等待状态。比如生产者唤醒生产者，消费者唤醒消费者，这样就会导致所有线程都是<code>waiting</code>状态。</p><p>与上面不同的程序如下：</p><pre><code>public class P {    private String lock;    public P(String lock) {        this.lock = lock;    }    public void setValue() {        try {            synchronized (lock) {                while (!ValueObject.value.equals("")) {                    System.out.println("生产者 "+Thread.currentThread().getName()+"waiting★");                    lock.wait();                }                System.out.println("生产者 "+Thread.currentThread().getName()+"runnable");                String value = "value";                ValueObject.value = value;                lock.notify();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class C {    private String lock;    public C(String lock) {        this.lock = lock;    }    public void getValue() {        try {            synchronized (lock) {                while (ValueObject.value.equals("")) {                    System.out.println("消费者 "+Thread.currentThread().getName()+"waiting☆");                    lock.wait();                }                System.out.println("消费者 "+Thread.currentThread().getName()+"runnable");                ValueObject.value = "";                lock.notify();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        String lock = new String();        P p = new P(lock);        C c = new C(lock);        ThreadP[] threadP = new ThreadP[2];        ThreadC[] threadC = new ThreadC[2];        for (int i = 0; i &lt; 2; i++) {            threadP[i] = new ThreadP(p);            threadP[i].setName("生产者" + (i + 1));            threadC[i] = new ThreadC(c);            threadC[i].setName("消费者" + (i + 1));            threadP[i].start();            threadC[i].start();        }        Thread.sleep(5000);        Thread[] threads = new Thread[Thread.currentThread().getThreadGroup().activeCount()];        Thread.currentThread().getThreadGroup().enumerate(threads);        for (Thread thread : threads) {            System.out.println(thread.getName() + " " + thread.getState());        }    }}</code></pre><pre><code>//输出结果如下1.生产者 生产者1runnable2.生产者 生产者1waiting★3.生产者 生产者2waiting★4.消费者 消费者1runnable5.消费者 消费者1waiting☆6.生产者 生产者1runnable7.生产者 生产者1waiting★8.生产者 生产者2waiting★9.消费者 消费者2runnable10.消费者 消费者2waiting☆11.消费者 消费者1waiting☆    main RUNNABLE    Monitor Ctrl-Break RUNNABLE    生产者1 WAITING    消费者1 WAITING    生产者2 WAITING    消费者2 WAITING</code></pre><p>分析结果：</p><ol><li><p>生产者1被启动，进入生产，生产完毕后发出通知，并释放锁，准备进入下一次while循环。</p></li><li><p>生产者1进入下一次循环，再次持有锁，发现产品并没有被消费，所以生产者1进入等待状态。</p></li><li><p>生产者2被启动，生产者2发现产品还没有被消费，所以生产者2也进入等待状态。</p></li><li><p>消费者1被启动，消费者1持有锁，将产品消费并发出通知（发出的通知唤醒了第6行的生产者1），运行结束后释放锁，准备进入下次循环。</p></li><li><p>消费者1进入下一次循环，发现产品还没有生产，所以释放锁并进入等待状态。</p></li><li><p>生产者1被第4行的消费者1唤醒，进入生产，生产完毕后发出通知（唤醒了第8行的生产者2）准备进入下一次循环。</p></li><li><p>生产者1再次进入循环，发现产品还没有被消费，所以生产者1进入等待状态。</p></li><li><p>生产者2被唤醒，发现产品没有消费，进入等待状态。</p></li><li><p>消费者2被启动，将产品消费完并发出通知（唤醒了第11行的消费者1），运行结束后释放锁，准备进入下一次循环。</p></li><li><p>消费者2再次进入循环，发现产品还没有生产，所以释放锁进入等待状态。</p></li><li><p>消费者1被唤醒，发现产品还没有生产，所以也释放锁进入等待状态。</p><p>至此，所有生产者和消费者都进入等待状态，出现所谓的“假死”。</p></li></ol><p>由上可知，假死出现的原因是有可能唤醒同类，只要能不光唤醒同类，也将异类也一起唤醒就可以了，解决办法就是将<code>notify()</code>方法改成<code>notifyAll()</code>方法。</p><h4 id="一生产与一消费：操作栈"><a href="#一生产与一消费：操作栈" class="headerlink" title="一生产与一消费：操作栈"></a>一生产与一消费：操作栈</h4><p>本示例是使生产者向堆栈<code>List</code>对象中放入数据，使消费者从<code>List</code>堆栈中取出数据。<code>List</code>容量为1</p><pre><code>public class MyStack {    private List list = new ArrayList();    synchronized public void push() {        try {            while (list.size() == 1) {                this.wait();            }            list.add("any");            this.notify();// 多通信时需要改成notifyAll()            System.out.println("push=" + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }    }    synchronized public String pop() {        String returnValue = "";        try {            while (list.size() == 0) {                System.out.println("pop操作中的: " + Thread.currentThread().getName() + " 线程为wait状态");                this.wait();            }            returnValue = "" + list.get(0);            list.remove(0);            this.notify();// 多通信时需要改成notifyAll()            System.out.println("pop=" + list.size());        } catch (InterruptedException e) {            e.printStackTrace();        }        return returnValue;    }}</code></pre><pre><code>public class P {    private MyStack myStack;    public P(MyStack myStack) {        this.myStack = myStack;    }    public void pushService() {        myStack.push();    }}</code></pre><pre><code>public class C {    private MyStack myStack;    public C(MyStack myStack) {        this.myStack = myStack;    }    public void popService() {        System.out.println("pop=" + myStack.pop());    }}</code></pre><pre><code>public class ThreadP extends Thread {    private P p;    public ThreadP(P p) {        this.p = p;    }    @Override    public void run() {        while (true) {            p.pushService();        }    }}</code></pre><pre><code>public class ThreadC extends Thread {    private C c;    public ThreadC(C c) {        this.c = c;    }    @Override    public void run() {        while (true) {            c.popService();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        MyStack myStack = new MyStack();        P p = new P(myStack);        C c = new C(myStack);        ThreadP threadP = new ThreadP(p);        ThreadC threadC = new ThreadC(c);        threadP.start();        threadC.start();    }}</code></pre><h4 id="一生产与多消费：操作栈"><a href="#一生产与多消费：操作栈" class="headerlink" title="一生产与多消费：操作栈"></a>一生产与多消费：操作栈</h4><p>修改上面Run中的消费者和生产者数量即可</p><h4 id="多生产与一消费：操作栈"><a href="#多生产与一消费：操作栈" class="headerlink" title="多生产与一消费：操作栈"></a>多生产与一消费：操作栈</h4><p>同上</p><h4 id="多生产与多消费：操作栈"><a href="#多生产与多消费：操作栈" class="headerlink" title="多生产与多消费：操作栈"></a>多生产与多消费：操作栈</h4><p>同上</p><h3 id="4-管道线程通信：字节流"><a href="#4-管道线程通信：字节流" class="headerlink" title="4.管道线程通信：字节流"></a>4.管道线程通信：字节流</h3><p>管道流可以在不同线程间直接传送数据，实现不同线程间的通信。</p><pre><code>public class WriteData {    public void writeMethod(PipedOutputStream out) {        try {            System.out.println("write:");            for (int i = 0; i &lt; 300; i++) {                String outData = "" + (i + 1);                out.write(outData.getBytes());                System.out.print(outData);            }            System.out.println();            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ReadData {    public void readMethod(PipedInputStream input) {        try {            System.out.println("read:");            byte[] bytes = new byte[20];            int readLength = input.read(bytes);            while (readLength != -1) {                String newData = new String(bytes, 0, readLength);                System.out.print(newData);                readLength = input.read(bytes);            }            System.out.println();            input.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ThreadWrite extends Thread {    private WriteData write;    private PipedOutputStream out;    public ThreadWrite(WriteData write, PipedOutputStream out) {        this.write = write;        this.out = out;    }    @Override    public void run() {        write.writeMethod(out);    }}</code></pre><pre><code>public class ThreadRead extends Thread {    private ReadData read;    private PipedInputStream input;    public ThreadRead(ReadData read, PipedInputStream input) {        this.read = read;        this.input = input;    }    @Override    public void run() {        read.readMethod(input);    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        try {            WriteData writeData = new WriteData();            ReadData readData = new ReadData();            PipedOutputStream outputStream = new PipedOutputStream();            PipedInputStream inputStream = new PipedInputStream();            // 连接两个管道，进行数据的输入输出            outputStream.connect(inputStream);            ThreadRead threadRead = new ThreadRead(readData, inputStream);            threadRead.start();            Thread.sleep(2000);            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);            threadWrite.start();        } catch (IOException e) {            e.printStackTrace();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="5-管道线程通信：字符流"><a href="#5-管道线程通信：字符流" class="headerlink" title="5.管道线程通信：字符流"></a>5.管道线程通信：字符流</h3><p><code>inputstream</code>和<code>outputstream</code>更改成<code>reader</code>和<code>writer</code>即可</p><pre><code>public class WriteData {    public void writeMethod(PipedWriter out) {        try {            System.out.println("write:");            for (int i = 0; i &lt; 300; i++) {                String outData = "" + (i + 1);                out.write(outData);                System.out.print(outData);            }            System.out.println();            out.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ReadData {    public void readMethod(PipedReader input) {        try {            System.out.println("read:");            char[] bytes = new char[20];            int readLength = input.read(bytes);            while (readLength != -1) {                String newData = new String(bytes, 0, readLength);                System.out.print(newData);                readLength = input.read(bytes);            }            System.out.println();            input.close();        } catch (IOException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ThreadWrite extends Thread {    private WriteData write;    private PipedWriter out;    public ThreadWrite(WriteData write, PipedWriter out) {        this.write = write;        this.out = out;    }    @Override    public void run() {        write.writeMethod(out);    }}</code></pre><pre><code>public class ThreadRead extends Thread {    private ReadData read;    private PipedReader input;    public ThreadRead(ReadData read, PipedReader input) {        this.read = read;        this.input = input;    }    @Override    public void run() {        read.readMethod(input);    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        try {            WriteData writeData = new WriteData();            ReadData readData = new ReadData();            PipedWriter outputStream = new PipedWriter();            PipedReader inputStream = new PipedReader();            outputStream.connect(inputStream);            ThreadRead threadRead = new ThreadRead(readData, inputStream);            threadRead.start();            Thread.sleep(2000);            ThreadWrite threadWrite = new ThreadWrite(writeData, outputStream);            threadWrite.start();        } catch (IOException e) {            e.printStackTrace();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><h3 id="6-join方法"><a href="#6-join方法" class="headerlink" title="6.join方法"></a>6.<code>join</code>方法</h3><p>在很多情况下，主线程创建并启动子线程，如果子线程中要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。这时，如果主线程想等待子线程执行完成之后再结束，比如子线程处理一个数据，主线程要取得这个数据中的值，就要用到<code>join()</code>方法。</p><p>方法<code>join</code>的作用是使所属的线程对象x正常执行<code>run()</code>方法中的任务，而使当前线程z进行无限期的阻塞 ，等待线程x销毁后再继续执行线程z后面的代码。</p><p>方法<code>join</code>具有使线程排队的作用，有些类似同步的运行效果。</p><p><code>join</code>与<code>synchronized</code>的区别是：<code>join</code>在内部使用<code>wait()</code>方法进行等待，<code>synchronized</code>使用的是对象监视器做同步。</p><p>在<code>join</code>过程中，如果当前线程对象被中断则当前线程出现异常。</p><p><code>join(time)</code>和<code>sleep(time)</code>的区别：<code>join</code>由于内部使用<code>wait</code>等待，所以会释放锁，而<code>sleep</code>不能。</p><h3 id="7-ThreadLocal类"><a href="#7-ThreadLocal类" class="headerlink" title="7.ThreadLocal类"></a>7.<code>ThreadLocal</code>类</h3><p>类<code>ThreadLocal</code>解决了每个线程绑定自己的值的问题，可以将<code>ThreadLocal</code>类比喻成全局存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p>验证变量隔离性，同时赋予<code>get</code>默认值，示例如下：</p><pre><code>public class Tools {    public static ThreadLocalExt t1 = new ThreadLocalExt();}</code></pre><pre><code>public class ThreadLocalExt extends ThreadLocal {    @Override    protected Object initialValue() {        return System.currentTimeMillis();    }}</code></pre><pre><code>public class ThreadA extends Thread {    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            System.out.println("在ThreadA线程中取值=" + Tools.t1.get());        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        try {            for (int i = 0; i &lt; 10; i++) {                System.out.println("在Main线程中取值=" + Tools.t1.get());            }            Thread.sleep(5000);            ThreadA a = new ThreadA();            a.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>输出：在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在Main线程中取值=1553519014020在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023在ThreadA线程中取值=1553519019023</code></pre><h3 id="8-InheritableThreadLocal类"><a href="#8-InheritableThreadLocal类" class="headerlink" title="8.InheritableThreadLocal类"></a>8.<code>InheritableThreadLocal</code>类</h3><p>类<code>InheritableThreadLocal</code>可以让子线程从父线程中取得值。</p><p>除了继承之，还可以修改继承的值，示例如下：</p><pre><code>public class Tools {    public static InheritableThreadLocalExt t1 = new InheritableThreadLocalExt();}</code></pre><pre><code>public class InheritableThreadLocalExt extends InheritableThreadLocal {    @Override    protected Object childValue(Object parentValue) {        return parentValue+" 加上子线程自己的值";    }    @Override    protected Object initialValue() {        return System.currentTimeMillis();    }}</code></pre><pre><code>public class ThreadA extends Thread {    @Override    public void run() {        for (int i = 0; i &lt; 10; i++) {            System.out.println("在ThreadA线程中取值=" + Tools.t1.get());        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        try {            for (int i = 0; i &lt; 10; i++) {                System.out.println("在Main线程中取值=" + Tools.t1.get());            }            Thread.sleep(5000);            ThreadA a = new ThreadA();            a.start();        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>输出：在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在Main线程中取值=1553519734861在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值在ThreadA线程中取值=1553519734861 加上子线程自己的值</code></pre><h2 id="三、Lock的使用"><a href="#三、Lock的使用" class="headerlink" title="三、Lock的使用"></a>三、<code>Lock</code>的使用</h2><h3 id="1-ReentrantLock类"><a href="#1-ReentrantLock类" class="headerlink" title="1.ReentrantLock类"></a>1.<code>ReentrantLock</code>类</h3><p><code>ReentrantLock</code>的<code>lock()</code>方法获取锁，<code>unlock()</code>方法释放锁。</p><pre><code>public class MyService {    private Lock lock = new ReentrantLock();    public void testMethod() {        lock.lock();        for (int i = 0; i &lt; 5; i++) {            System.out.println(Thread.currentThread().getName() + " " + (i + 1));        }        lock.unlock();    }}</code></pre><pre><code>public class MyThread extends Thread {    private MyService service;    public MyThread(MyService service) {        this.service = service;    }    @Override    public void run() {        service.testMethod();    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        MyService service = new MyService();        MyThread a1 = new MyThread(service);        MyThread a2 = new MyThread(service);        MyThread a3 = new MyThread(service);        MyThread a4 = new MyThread(service);        MyThread a5 = new MyThread(service);        a1.start();        a2.start();        a3.start();        a4.start();        a5.start();    }}</code></pre><h3 id="2-Condition实现等待-通知"><a href="#2-Condition实现等待-通知" class="headerlink" title="2.Condition实现等待/通知"></a>2.<code>Condition</code>实现等待/通知</h3><p>关键字<code>synchronized</code>与<code>wait()</code>和<code>notify()/notifyAlI()</code>方法相结合可以实现等待/通知模式，类<code>ReentrantLock</code>也可以实现同样的功能，但需要借助于<code>Condition</code>对象。<code>Condition</code>类是在JDK5中出现的技术，使用它有更好的灵活性，比如可以实现多路通知功能，也就是在一个<code>Lock</code>对象里面可以创建多个<code>Condition</code> (即对象监视器)实例，线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性地进行线程通知，在调度线程上更加灵活。在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程却是由JVM随机选择的。但使用<code>ReentrantLock</code>结合<code>Condition</code>类是可以实现前面介绍过的“选择性通知”，这个功能是非常重要的，而且在<code>Condition</code>类中是默认提供的。而<code>synchronized</code>就相当于整个<code>Lock</code>对象中只有一个单一的<code>Condition</code>对象，所有的线程都注册在它一个对象的身上。线程开始<code>notifyAll()</code>时，需要通知所有的WAITING线程，没有选择权。</p><p>一个<code>Condition</code>实现方法</p><pre><code>public class MyService {    private Lock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void await() {        try {            lock.lock();            System.out.println(" await时间为" + System.currentTimeMillis());            condition.await();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void signal() {        try {            lock.lock();            System.out.println("signal时间为" + System.currentTimeMillis());            condition.signal();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class ThreadA extends Thread {    private MyService service;    public ThreadA(MyService service) {        this.service = service;    }    @Override    public void run() {        service.await();    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        MyService service = new MyService();        ThreadA a = new ThreadA(service);        a.start();        Thread.sleep(3000);        service.signal();    }}</code></pre><pre><code>输出：await时间为1553603466000signal时间为1553603469000</code></pre><p>多个<code>Condition</code>实现方法（指定唤醒线程）</p><pre><code>public class MyService {    private Lock lock = new ReentrantLock();    private Condition conditionA = lock.newCondition();    private Condition conditionB = lock.newCondition();    public void awaitA() {        try {            lock.lock();            System.out.println("begin awaitA时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());            conditionA.await();            System.out.println("  end awaitA时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void awaitB() {        try {            lock.lock();            System.out.println("begin awaitB时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());            conditionB.await();            System.out.println("  end awaitB时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void signalAll_A() {        try {            lock.lock();            System.out.println("  signalAll_A时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());            conditionA.signalAll();        } finally {            lock.unlock();        }    }    public void signalAll_B() {        try {            lock.lock();            System.out.println("  signalAll_B时间为" + System.currentTimeMillis() + " ThreadName=" + Thread.currentThread().getName());            conditionB.signalAll();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class ThreadA extends Thread {    private MyService service;    public ThreadA(MyService service) {        this.service = service;    }    @Override    public void run() {        service.awaitA();    }}</code></pre><pre><code>public class ThreadB extends Thread {    private MyService service;    public ThreadB(MyService service) {        this.service = service;    }    @Override    public void run() {        service.awaitB();    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        MyService service = new MyService();        ThreadA a = new ThreadA(service);        a.setName("A");        a.start();        ThreadB b = new ThreadB(service);        b.setName("B");        b.start();        Thread.sleep(3000);        service.signalAll_A();    }}</code></pre><pre><code>输出：begin awaitA时间为1553605530840 ThreadName=Abegin awaitB时间为1553605530841 ThreadName=B   signalAll_A时间为1553605533840 ThreadName=main   end awaitA时间为1553605533840 ThreadName=A</code></pre><p>由此可见，我只唤醒了线程A，线程B并没有被唤醒，使用<code>ReentrantLock</code>对象可以唤醒指定种类的线程是很方便的。</p><h3 id="3-公平锁和非公平锁"><a href="#3-公平锁和非公平锁" class="headerlink" title="3.公平锁和非公平锁"></a>3.公平锁和非公平锁</h3><p>锁<code>Lock</code>分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程加锁的顺序来分配的，即先来先得的FIFO顺序。而非公平锁就是一种获取锁的抢占机制，是随机获得锁的，和公平锁不一样的是先来的不一定先得到锁，这个方式可能造成某些线程一直拿不到锁，所以是不公平的。</p><pre><code>public class Service {    private Lock lock;    public Service(boolean isFair) {        lock = new ReentrantLock(isFair);    }    public void serviceMethod() {        try {            lock.lock();            System.out.println("ThreadName=" + Thread.currentThread().getName() + "获得锁定");        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        // 传入true是公平锁，false是非公平锁        final Service service = new Service(true);        Runnable runnable = () -&gt; {            System.out.println("线程" + Thread.currentThread().getName() + "运行了");            service.serviceMethod();        };        Thread[] threads = new Thread[10];        for (int i = 0; i &lt; 10; i++) {            threads[i] = new Thread(runnable);        }        for (int i = 0; i &lt; 10; i++) {            threads[i].start();        }    }}</code></pre><pre><code>公平锁输出：线程Thread-1运行了线程Thread-6运行了ThreadName=Thread-1获得锁定线程Thread-0运行了线程Thread-5运行了线程Thread-2运行了线程Thread-3运行了线程Thread-9运行了线程Thread-4运行了线程Thread-7运行了ThreadName=Thread-6获得锁定ThreadName=Thread-0获得锁定ThreadName=Thread-5获得锁定ThreadName=Thread-2获得锁定线程Thread-8运行了ThreadName=Thread-3获得锁定ThreadName=Thread-9获得锁定ThreadName=Thread-4获得锁定ThreadName=Thread-7获得锁定ThreadName=Thread-8获得锁定非公平锁输出：线程Thread-0运行了线程Thread-3运行了线程Thread-4运行了ThreadName=Thread-0获得锁定线程Thread-1运行了ThreadName=Thread-1获得锁定线程Thread-7运行了ThreadName=Thread-7获得锁定线程Thread-8运行了线程Thread-2运行了线程Thread-5运行了线程Thread-6运行了线程Thread-9运行了ThreadName=Thread-8获得锁定ThreadName=Thread-3获得锁定ThreadName=Thread-4获得锁定ThreadName=Thread-2获得锁定ThreadName=Thread-5获得锁定ThreadName=Thread-6获得锁定ThreadName=Thread-9获得锁定</code></pre><h3 id="4-getHoldCount"><a href="#4-getHoldCount" class="headerlink" title="4.getHoldCount()"></a>4.<code>getHoldCount()</code></h3><p>查询当前线程保持此锁定的个数，也就是调用<code>lock()</code>方法的次数。</p><p>示例：</p><pre><code>public class Service {    private ReentrantLock lock = new ReentrantLock();    public void serviceMethod1() {        try {            lock.lock();            System.out.println("serviceMethod1 getHoldCount=" + lock.getHoldCount());            serviceMethod2();        } finally {            lock.unlock();        }    }    public void serviceMethod2() {        try {            lock.lock();            System.out.println("serviceMethod2 getHoldCount=" + lock.getHoldCount());        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) {        Service service = new Service();        service.serviceMethod1();    }}</code></pre><pre><code>输出：serviceMethod1 getHoldCount=1serviceMethod2 getHoldCount=2</code></pre><h3 id="5-getQueueLength"><a href="#5-getQueueLength" class="headerlink" title="5.getQueueLength()"></a>5.<code>getQueueLength()</code></h3><p>返回正等待获取此锁定的线程估计数。比如有5个线程，1个线程首先执行<code>await()</code>方法，那么在调用<code>getQueueLength()</code>方法后返回值是4，说明有4个线程同时在等待<code>lock</code>的释放。</p><p>示例：</p><pre><code>public class Service {    public ReentrantLock lock = new ReentrantLock();    public void serviceMethod1() {        try {            lock.lock();            System.out.println("ThreadName=" + Thread.currentThread().getName() + "进入方法！");            Thread.sleep(Integer.MAX_VALUE);        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnable = new Runnable() {            @Override            public void run() {                service.serviceMethod1();            }        };        Thread[] threadArray = new Thread[10];        for (int i = 0; i &lt; 10; i++) {            threadArray[i] = new Thread(runnable);        }        for (int i = 0; i &lt; 10; i++) {            threadArray[i].start();        }        Thread.sleep(2000);        System.out.println("有线程数：" + service.lock.getQueueLength() + "在等待获取锁！");    }}</code></pre><pre><code>输出：ThreadName=Thread-0进入方法！有线程数：9在等待获取锁！</code></pre><h3 id="6-getWaitQueueLength-Condition-condition"><a href="#6-getWaitQueueLength-Condition-condition" class="headerlink" title="6.getWaitQueueLength(Condition condition)"></a>6.<code>getWaitQueueLength(Condition condition)</code></h3><p>返回等待与此锁定相关的给定条件<code>Condition</code>的线程估计数。比如5个线程，每个线程都执行同一个<code>condition</code>对象的<code>await()</code>方法，则调用<code>getWaitQueueLength(Condition condition)</code>方法时返回的值是5.</p><p>示例：</p><pre><code>public class Service {    private ReentrantLock lock = new ReentrantLock();    private Condition newCondition = lock.newCondition();    public void waitMethod() {        try {            lock.lock();            newCondition.await();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void notityMethod() {        try {            lock.lock();            System.out.println("有" + lock.getWaitQueueLength(newCondition) + "个线程正在等待newCondition");            newCondition.signal();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnable = new Runnable() {            @Override            public void run() {                service.waitMethod();            }        };        Thread[] threadArray = new Thread[10];        for (int i = 0; i &lt; 10; i++) {            threadArray[i] = new Thread(runnable);        }        for (int i = 0; i &lt; 10; i++) {            threadArray[i].start();        }        Thread.sleep(2000);        service.notityMethod();    }}</code></pre><pre><code>输出：有10个线程正在等待newCondition</code></pre><h3 id="7-hasQueuedThread-Thread-thread-和hasQueuedThread"><a href="#7-hasQueuedThread-Thread-thread-和hasQueuedThread" class="headerlink" title="7.hasQueuedThread(Thread thread)和hasQueuedThread()"></a>7.<code>hasQueuedThread(Thread thread)</code>和<code>hasQueuedThread()</code></h3><p><code>hasQueuedThread(Thread thread)</code> 查询指定线程是否正在等待获取此锁定</p><p><code>hasQueuedThread()</code> 查询是否有线程正在等待获取此锁定</p><p>示例：</p><pre><code>public class Service {    public ReentrantLock lock = new ReentrantLock();    public Condition newCondition = lock.newCondition();    public void waitMethod() {        try {            lock.lock();            Thread.sleep(Integer.MAX_VALUE);        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnable = new Runnable() {            @Override            public void run() {                service.waitMethod();            }        };        Thread threadA = new Thread(runnable);        threadA.start();        Thread.sleep(500);        Thread threadB = new Thread(runnable);        threadB.start();        Thread.sleep(500);        System.out.println(service.lock.hasQueuedThread(threadA)); // false        System.out.println(service.lock.hasQueuedThread(threadB)); // true，线程B在等待获取锁        System.out.println(service.lock.hasQueuedThreads()); // true    }}</code></pre><h3 id="8-hasWaiters-Condition-condition"><a href="#8-hasWaiters-Condition-condition" class="headerlink" title="8.hasWaiters(Condition condition)"></a>8.<code>hasWaiters(Condition condition)</code></h3><p>查询是否有线程正在等待与此锁定有关的<code>condition</code>条件。</p><pre><code>public class Service {    private ReentrantLock lock = new ReentrantLock();    private Condition newCondition = lock.newCondition();    public void waitMethod() {        try {            lock.lock();            newCondition.await();        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            lock.unlock();        }    }    public void notityMethod() {        try {            lock.lock();            System.out.println("有没有线程正在等待newCondition？"                    + lock.hasWaiters(newCondition) + " 线程数是多少？"                    + lock.getWaitQueueLength(newCondition));            newCondition.signal();        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnable = new Runnable() {            @Override            public void run() {                service.waitMethod();            }        };        Thread[] threadArray = new Thread[10];        for (int i = 0; i &lt; 10; i++) {            threadArray[i] = new Thread(runnable);        }        for (int i = 0; i &lt; 10; i++) {            threadArray[i].start();        }        Thread.sleep(2000);        service.notityMethod();    }}</code></pre><pre><code>输出：有没有线程正在等待newCondition？true 线程数是多少？10</code></pre><h3 id="9-isFair"><a href="#9-isFair" class="headerlink" title="9.isFair()"></a>9.<code>isFair()</code></h3><p>判读是不是公平锁。</p><p>示例：</p><pre><code>public class Service {    private ReentrantLock lock;    public Service(boolean isFair) {        super();        lock = new ReentrantLock(isFair);    }    public void serviceMethod() {        try {            lock.lock();            System.out.println("公平锁情况：" + lock.isFair());        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service1 = new Service(true);        Runnable runnable = new Runnable() {            @Override            public void run() {                service1.serviceMethod();            }        };        Thread thread = new Thread(runnable);        thread.start();        final Service service2 = new Service(false);        runnable = new Runnable() {            @Override            public void run() {                service2.serviceMethod();            }        };        thread = new Thread(runnable);        thread.start();    }}</code></pre><pre><code>输出：公平锁情况：true公平锁情况：false</code></pre><h3 id="10-isHeldByCurrentThread"><a href="#10-isHeldByCurrentThread" class="headerlink" title="10.isHeldByCurrentThread()"></a>10.<code>isHeldByCurrentThread()</code></h3><p>查询当前线程是否保持此锁定。</p><pre><code>public class Service {    private ReentrantLock lock;    public Service(boolean isFair) {        super();        lock = new ReentrantLock(isFair);    }    public void serviceMethod() {        try {            System.out.println(lock.isHeldByCurrentThread()); // false            lock.lock();            System.out.println(lock.isHeldByCurrentThread()); // true        } finally {            lock.unlock();        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service1 = new Service(true);        Runnable runnable = new Runnable() {            @Override            public void run() {                service1.serviceMethod();            }        };        Thread thread = new Thread(runnable);        thread.start();    }}</code></pre><h3 id="11-isLocked"><a href="#11-isLocked" class="headerlink" title="11.isLocked()"></a>11.<code>isLocked()</code></h3><p>查询此锁定是否由任意线程保持。</p><pre><code>public class Service {    private ReentrantLock lock;    public Service(boolean isFair) {        super();        lock = new ReentrantLock(isFair);    }    public void serviceMethod() {        try {            System.out.println(lock.isLocked()); // false            lock.lock();            System.out.println(lock.isLocked()); // true        } finally {            lock.unlock();        }    }}</code></pre><h3 id="12-lockInterruptibly"><a href="#12-lockInterruptibly" class="headerlink" title="12.lockInterruptibly()"></a>12.<code>lockInterruptibly()</code></h3><p>如果当前线程未被中断，则获取此锁定，如果已经中断则出现异常。</p><p>先看这个示例：</p><pre><code>public class Service {    public ReentrantLock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void waitMethod() {        try {            lock.lock();            System.out                    .println("lock begin " + Thread.currentThread().getName());            for (int i = 0; i &lt; Integer.MAX_VALUE / 10; i++) {                String newString = new String();                Math.random();            }            System.out                    .println("lock   end " + Thread.currentThread().getName());        } finally {            if (lock.isHeldByCurrentThread()) {                lock.unlock();            }        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnableRef = new Runnable() {            @Override            public void run() {                service.waitMethod();            }        };        Thread threadA = new Thread(runnableRef);        threadA.setName("A");        threadA.start();        Thread.sleep(500);        Thread threadB = new Thread(runnableRef);        threadB.setName("B");        threadB.start();        threadB.interrupt(); // 打标记，并没有停止        System.out.println("main end!");    }}</code></pre><pre><code>输出：lock begin Amain end!lock   end Alock begin Block   end B</code></pre><p>可见，执行<code>lock()</code>方法没有出现异常，正常执行，因为<code>interrupt</code>没有停止线程。</p><p>将<code>lock()</code>方法改成<code>lockInterruptibly()</code>之后，</p><pre><code>public class Service {    public ReentrantLock lock = new ReentrantLock();    private Condition condition = lock.newCondition();    public void waitMethod() {        try {            lock.lockInterruptibly();            System.out.println("lock " + Thread.currentThread().getName());            for (int i = 0; i &lt; Integer.MAX_VALUE / 10; i++) {                String newString = new String();                Math.random();            }        } catch (InterruptedException e) {            System.out.println("线程"+Thread.currentThread().getName()+"进入catch");            //e.printStackTrace();        } finally {            if (lock.isHeldByCurrentThread()) {                lock.unlock();            }        }    }}</code></pre><pre><code>输出：lock Amain end!线程B进入catch</code></pre><h3 id="13-tryLock-和tryLock-long-timeout-TimeUnit-unit"><a href="#13-tryLock-和tryLock-long-timeout-TimeUnit-unit" class="headerlink" title="13.tryLock()和tryLock(long timeout,TimeUnit unit)"></a>13.<code>tryLock()</code>和<code>tryLock(long timeout,TimeUnit unit)</code></h3><p><code>tryLock()</code> 在调用时如果锁没有被其他线程保持，就获取该锁。</p><p><code>tryLock(long timeout,TimeUnit unit)</code> 如果锁在给定时间内没有被其他线程保持，且当前线程没被中断，就获取该锁。</p><p>示例：</p><pre><code>public class Service {    public ReentrantLock lock = new ReentrantLock();    public void waitMethod() {        try {            if (lock.tryLock(3, TimeUnit.SECONDS)) {                System.out.println("      " + Thread.currentThread().getName()                        + "获得锁的时间：" + System.currentTimeMillis());                Thread.sleep(10000);            } else {                System.out.println("      " + Thread.currentThread().getName()                        + "没有获得锁");            }        } catch (InterruptedException e) {            e.printStackTrace();        } finally {            if (lock.isHeldByCurrentThread()) {                lock.unlock();            }        }    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        final Service service = new Service();        Runnable runnableRef = new Runnable() {            @Override            public void run() {                System.out.println(Thread.currentThread().getName()                        + "调用waitMethod时间：" + System.currentTimeMillis());                service.waitMethod();            }        };        Thread threadA = new Thread(runnableRef);        threadA.setName("A");        threadA.start();        Thread threadB = new Thread(runnableRef);        threadB.setName("B");        threadB.start();    }}</code></pre><pre><code>输出：A调用waitMethod时间：1553654723504B调用waitMethod时间：1553654723504        A获得锁的时间：1553654723505        B没有获得锁</code></pre><p>由于线程A获取锁后<code>sleep</code>了10秒，所以B再次获取锁，在规定时间3秒内还没能等到A释放锁，因此B没有获取锁。</p><h3 id="14-ReentrantReadWriteLock类"><a href="#14-ReentrantReadWriteLock类" class="headerlink" title="14.ReentrantReadWriteLock类"></a>14.<code>ReentrantReadWriteLock</code>类</h3><p>类<code>Reentrantlock</code>具有完全互斥排他的效果，即同一时间只能有一个线程在执行<code>Rentrantlock.lock()</code>方法后面的任务。这样做虽然保证了实例变量的线程安全性，但效率却是非常低下的，所以JDK提供了一种读写锁<code>ReentrantReadWriteLock</code>类,使用它可以加快运行效率,在某些不需要操作实例变量的方法中，完全可以使用读写锁<code>ReentrantReadWriteLock</code>来提升该方法的代码运行速度。</p><p>读写锁表示也有两个锁，一个是读操作相关的锁，也称为共享锁；另一个是写操作相关的锁，也叫排他锁。也就是多个读锁之间不互斥，读锁与写锁互斥，写锁与写锁互斥。在没有线程<code>Thread</code>进行写入操作时,进行读取操作的多个<code>Thread</code>都可以获取读锁，而进行写入操作的<code>Thread</code>只有在获取写锁后才能进行写入操作。即多个<code>Thread</code>可以同时进行读取操作,但是同一时刻只允许一个<code>Thread</code>进行写入操作。</p><h4 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h4><pre><code>public class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void read() {        try {            try {                lock.readLock().lock();                System.out.println("获得读锁" + Thread.currentThread().getName()                        + " " + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.readLock().unlock();            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><pre><code>public class ThreadA extends Thread {    private Service service;    public ThreadA(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.read();    }}</code></pre><pre><code>public class ThreadB extends Thread {    private Service service;    public ThreadB(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.read();    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        Service service = new Service();        ThreadA a = new ThreadA(service);        a.setName("A");        ThreadB b = new ThreadB(service);        b.setName("B");        a.start();        b.start();    }}</code></pre><pre><code>输出：获得读锁A 1553656843746获得读锁B 1553656843747</code></pre><p>由输出可见，两个线程几乎同时进入<code>lock()</code>方法后面的代码，而不需要和之前一样，等待A线程10秒后才执行B线程，提高了运行效率。</p><h4 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h4><pre><code>public class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void write() {        try {            try {                lock.writeLock().lock();                System.out.println("获得写锁" + Thread.currentThread().getName()                        + " " + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.writeLock().unlock();            }        } catch (InterruptedException e) {            // TODO Auto-generated catch block            e.printStackTrace();        }    }}</code></pre><pre><code>输出：获得写锁A 1553657146589获得写锁B 1553657156591</code></pre><p>使用写锁<code>lock.writeLock()</code>的效果就是同一时间只允许一个线程执行<code>lock()</code>后面的代码，必须等A执行完，才能执行B。</p><h4 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h4><pre><code>public class Service {    private ReentrantReadWriteLock lock = new ReentrantReadWriteLock();    public void read() {        try {            try {                lock.readLock().lock();                System.out.println("获得读锁" + Thread.currentThread().getName()                        + " " + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.readLock().unlock();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }    public void write() {        try {            try {                lock.writeLock().lock();                System.out.println("获得写锁" + Thread.currentThread().getName()                        + " " + System.currentTimeMillis());                Thread.sleep(10000);            } finally {                lock.writeLock().unlock();            }        } catch (InterruptedException e) {            e.printStackTrace();        }    }}</code></pre><pre><code>public class ThreadA extends Thread {    private Service service;    public ThreadA(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.read();    }}</code></pre><pre><code>public class ThreadB extends Thread {    private Service service;    public ThreadB(Service service) {        super();        this.service = service;    }    @Override    public void run() {        service.write();    }}</code></pre><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        Service service = new Service();        ThreadA a = new ThreadA(service);        a.setName("A");        a.start();        Thread.sleep(1000);        ThreadB b = new ThreadB(service);        b.setName("B");        b.start();    }}</code></pre><pre><code>输出：获得读锁A 1553657413075获得写锁B 1553657423075</code></pre><p>由此可见，读写操作也是互斥的。</p><h4 id="写读互斥"><a href="#写读互斥" class="headerlink" title="写读互斥"></a>写读互斥</h4><pre><code>public class Run {    public static void main(String[] args) throws InterruptedException {        Service service = new Service();        ThreadB b = new ThreadB(service);        b.setName("B");        b.start();        Thread.sleep(1000);        ThreadA a = new ThreadA(service);        a.setName("A");        a.start();    }}</code></pre><pre><code>输出：获得写锁B 1561709743838获得读锁A 1561709753839</code></pre><p>由此可见，只要有写操作，就是互斥的。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用静态工厂方法代替构造器</title>
      <link href="/2019/08/10/yong-jing-tai-gong-han-fang-fa-dai-ti-gou-zao-qi/"/>
      <url>/2019/08/10/yong-jing-tai-gong-han-fang-fa-dai-ti-gou-zao-qi/</url>
      
        <content type="html"><![CDATA[<h2 id="静态工厂的优势"><a href="#静态工厂的优势" class="headerlink" title="静态工厂的优势"></a>静态工厂的优势</h2><p><img src="/images/1558507413213.png" alt=""></p><h2 id="1-有名称，可读性更好"><a href="#1-有名称，可读性更好" class="headerlink" title="1.有名称，可读性更好"></a>1.有名称，可读性更好</h2><blockquote><p>假设我们需要写一个产生随机数的类<code>RandomIntGenerator</code>，该类有两个成员属性：最小值min和最大值max</p><p>假设我们的需求是需要创建三种类型的<code>RandomIntGenerator</code>对象，</p><p>1、大于min，小于max；</p><p>2、大于min 小于Integer.MAX_VALUE；</p><p>3、大于Integer.MIN_VALUE 小于max</p></blockquote><p>如果我们不使用静态工厂方法，代码一般如下设计：</p><pre><code>class RandomIntGenerator{    /**     * 最小值     */    private int min = Integer.MIN_VALUE;    /**     * 最大值     */    private int max = Integer.MAX_VALUE;    /**     * 大于min 小于max     * @param min     * @param max     */    public RandomIntGenerator(int min, int max)    {        this.min = min;        this.max = max;    }    /**     * 大于min 小于Integer.MAX_VALUE     */    public RandomIntGenerator(int min)    {        this.min = min;    }}</code></pre><p>观察以上代码，我们发现，以上代码不仅可读性差（<code>new RandomIntGenerator(1, 10)</code>与<code>new RandomIntGenerator(10)</code>，不查文档，不看注释很难知道其创建的对象的具体含义）</p><p>那么假设我们使用静态工厂方法会怎样呢，如下所示：</p><pre><code>class RandomIntGenerator{    /**     * 最小值     */    private int min = Integer.MIN_VALUE;    /**     * 最大值     */    private int max = Integer.MAX_VALUE;    /**     * 大于min 小于max     * @param min     * @param max     */    public RandomIntGenerator(int min, int max)    {        this.min = min;        this.max = max;    }    /**     * 大于min 小于max     * @param min     * @param max     */    public static RandomIntGenerator between(int min, int max)    {        return new RandomIntGenerator(min, max);    }    /**     * 大于min 小于Integer.MAX_VALUE     */    public static RandomIntGenerator biggerThan(int min)    {        return new RandomIntGenerator(min, Integer.MAX_VALUE);    }    /**     * 大于Integer.MIN_VALUE 小于max     */    public static RandomIntGenerator smallerThan(int max)    {        return new RandomIntGenerator(Integer.MIN_VALUE, max);    }}</code></pre><h2 id="2-不必每次创建新对象"><a href="#2-不必每次创建新对象" class="headerlink" title="2.不必每次创建新对象"></a>2.不必每次创建新对象</h2><p>JDK中的<code>Boolean</code>类的<code>valueOf</code>方法可以很好的印证这个优势，在<code>Boolean</code>类中，有两个事先创建好的<code>Boolean</code>对象（True,False）</p><pre><code>public final class Boolean implements java.io.Serializable,                                      Comparable&lt;Boolean&gt;{    /**     * The {@code Boolean} object corresponding to the primitive     * value {@code true}.     */    public static final Boolean TRUE = new Boolean(true);    /**     * The {@code Boolean} object corresponding to the primitive     * value {@code false}.     */    public static final Boolean FALSE = new Boolean(false);</code></pre><p>当我们调用<code>Boolean.valueOf("true")</code>方法时，返回的就是这两个实例的引用，这样可以避免创建不必要的对象，如果使用构造器的话，就达不到这种效果了；</p><pre><code>public static Boolean valueOf(boolean b) {    return (b ? TRUE : FALSE);}public static Boolean valueOf(String s) {    return parseBoolean(s) ? TRUE : FALSE;}</code></pre><h2 id="3-可以返回原返回类型的任意子类对象"><a href="#3-可以返回原返回类型的任意子类对象" class="headerlink" title="3.可以返回原返回类型的任意子类对象"></a>3.可以返回原返回类型的任意子类对象</h2><pre><code> //RedDog和BlackDog为Dog的子类 public static Dog getInstance(){ return new RedDog();//或者return new BlackDog(); }</code></pre><h2 id="4-创建泛型类实例的代码更为简洁"><a href="#4-创建泛型类实例的代码更为简洁" class="headerlink" title="4.创建泛型类实例的代码更为简洁"></a>4.创建泛型类实例的代码更为简洁</h2><pre><code>class MyMap&lt;K,V&gt; {    public MyMap()    {    }    public static &lt;K,V&gt; MyMap&lt;K,V&gt; newInstance(){        return new MyMap&lt;K, V&gt;();    }}public class Main{    public static void main(String[] args)    {        MyMap&lt;String, String&gt; map1 = new MyMap&lt;String, String&gt;();        //更加简洁，不需要重复指明类型参数，可以自行推导出来        MyMap&lt;String, String&gt; map2 = MyMap.newInstance();    }}</code></pre><p>我们可以在<code>Google Guava</code>中发现类似用法，如下所示：</p><pre><code>public static &lt;E&gt; ArrayList&lt;E&gt; newArrayList() {    return new ArrayList();}用法：Lists.newArrayList();</code></pre><p>类似用法在其中还有很多。</p><h2 id="5-服务提供者框架"><a href="#5-服务提供者框架" class="headerlink" title="5.服务提供者框架"></a>5.服务提供者框架</h2><p>先来看张图：</p><p><img src="/images/1186132-76e487514e50921e.png" alt=""></p><p>网易云音乐要向用户提供服务时，首先需要在应用市场注册，然后把客户端上传到应用市场，之后用户才能通过应用市场下载网易云音乐。</p><p>再看下图：</p><p><img src="/images/1186132-5e745f1507de3578.png" alt=""></p><p>所谓服务提供者，就是说一方提供服务，比如网易云音乐；另一方消费服务，比如用户。而双方都要遵守应用市场的规定，网易云音乐根据规定将他们的服务放在应用市场上，用户从应用市场下载客户端软件并欣赏歌曲。为什么要用这样的框架呢？因为市场上可能有很多音乐提供商，比如酷狗音乐、QQ音乐、虾米音乐等等，用户可以随意选用任何一个商家的服务，而不必关心这个服务具体是如何实现的。</p><p>接下来我们介绍几个具体的概念并把它们与上图的内容对照起来：</p><ul><li><strong>服务接口</strong>：应用市场对音乐客户端的规定</li><li><strong>服务提供者接口</strong>：应用市场对商家的规定</li><li><strong>提供者注册API</strong>：网易云音乐（商家）向应用市场注册</li><li><strong>服务访问API</strong>：用户下载客户端</li></ul><p>现在我们分别从应用市场、商家、用户的角度编写Java代码。</p><p>上面的四个概念都是在应用市场中规定的，代码如下。</p><pre><code>//服务接口interface MusicApp {    void play();}//服务提供者接口interface MusicProvider {    MusicApp getMusicApp();}class AppStore {    private AppStore() {}    private static final Map&lt;String, MusicProvider&gt; providers = new ConcurrentHashMap&lt;String, MusicProvider&gt;();    //服务注册API    public static void registerProvider(String name, MusicProvider p) {        providers.put(name, p);    }    //服务访问API    public static MusicApp installApp(String name) {        MusicProvider p = providers.get(name);        if (p==null) {            throw new IllegalArgumentException("No provider registerd with name:" + name);        }        return p.getMusicApp();    }}</code></pre><p>可以看到，服务注册API<code>registerProvider</code>负责为音乐提供商注册到应用市场并起一个名字。用户使用服务访问API<code>installApp</code>安装指定名称的App到用户设备上。</p><p>服务提供商，即网易云音乐，需要实现服务接口和服务提供者接口，代码如下。</p><pre><code>//网易云音乐移动端实现class NetEaseMusicApp implements MusicApp {    @Override    public void play() {        System.out.println("网易云音乐，听见好时光~来自Android客户端");    }}//网易云音乐PC端实现class NetEaseMusicPC implements MusicApp {    @Override    public void play() {        System.out.println("网易云音乐，听见好时光~来自PC客户端");    }}//网易云音乐服务提供者实现class NetEaseMusicProvider implements MusicProvider {    @Override    public MusicApp getMusicApp() {        boolean isDeviceAndroid = true;        if (isDeviceAndroid) {            return new NetEaseMusicApp();        }        else {            return new NetEaseMusicPC();        }    }}</code></pre><p>这里我们分别实现了移动端服务和PC端服务两个服务，以及一个服务提供者。</p><p>最后，给出用户的操作流程代码。</p><pre><code>public static void main(String[] args) {    AppStore.registerProvider("NetEase", new NetEaseMusicProvider());    //以下为用户的操作    MusicApp musicApp = AppStore.installApp("NetEase");    musicApp.play();}</code></pre><p>第一句把服务提供者的实现注册到应用市场的操作既可以由用户来完成，也可以由商家完成。在我们举的例子中应该由商家完成，而使用JDBC时通常由用户自己完成，这并不是重点。重点在于用户只需要根据商家的名字“NetEase”就可以得到一个音乐客户端的实例，而不需要指定与该客户端实例相关的任何细节，这实现了用户与服务的解耦。在上面的代码中，我们为移动端和客户端分别实现了两个服务，而在实际情况中，由于版本、平台的不同可能会有更多的实例，具体为用户创建哪个实例，由服务提供者来决定，用户不必关心。另一方面，服务提供商也可以有多个，用户选择哪个只需要提供该商家的名称即可，这实现了用户与服务提供商的解耦。</p><p>下面再从JDBC源码角度来看服务提供者框架</p><p>首先让我们回忆一下在编写<strong>JDBC</strong>代码的时候，我们在获取<strong>Connection</strong>的时候怎么获取的</p><pre><code>Class.forName("com.mysql.jdbc.Driver");Connection connection= DriverManager.getConnection("jdbc:mysql:///mydatabase", "root", "root");</code></pre><ol><li><p>通过<strong>反射</strong>的方式将com.mysql.jdbc.Driver的<strong>class文件</strong>通过类加载器加载到内存中</p></li><li><p>通过DriverManager得到Connection</p></li></ol><p>sun公司在制定JDBC这套规则的时候，如果MySQL还没有出现，sun公司会再给MySQL重新制定一套规则吗？一定不会吧，可是这个问题怎么解决？</p><ol><li><p>所以sun公司首先自己定义了一套服务接口，就是这些这些主要步骤的定义。 </p></li><li><p>MySQL服务商去实现这套接口。 </p></li><li><p>现在调用者想使用MySQL提供的服务，首先进行注册，也就是调用提供者者注册API，将MySQL的实现的服务提供者接口添加到JDBC的注册列表中。</p></li><li><p>注册之后调用者只需要调用 服务访问API，告之我要使用哪一个SQL服务商的实现类，服务访问API就会调用服务提供者接口的实现返回对应的服务实例。</p></li></ol><p>这里要说明一点因为服务的实现都是后于JDBC规则出现的，所以想实例化这些对象只能通过反射进行实例化，按照类名进行注册，所以服务提供者接口 的实现负责创建其服务实现的实例。同时使用服务提供者接口进行注册，对于MySQL而言就是Driver</p><p>首先，让我们先看一下Mysql是怎么实现服务注册的</p><p><code>com.mysql.jdbc.Driver.java</code></p><pre><code>package com.mysql.jdbc;import com.mysql.jdbc.NonRegisteringDriver;import java.sql.DriverManager;import java.sql.SQLException;public class Driver extends NonRegisteringDriver implements java.sql.Driver {    public Driver() throws SQLException {    }    static {        try {            DriverManager.registerDriver(new Driver());        } catch (SQLException var1) {            throw new RuntimeException("Can\'t register driver!");        }    }}</code></pre><p><code>java.sql.DriverManager.java</code></p><pre><code>public static synchronized void registerDriver(java.sql.Driver driver,        DriverAction da)    throws SQLException {    /* Register the driver if it has not already been added to our list */    if(driver != null) {        registeredDrivers.addIfAbsent(new DriverInfo(driver, da));    } else {        // This is for compatibility with the original DriverManager        throw new NullPointerException();    }    println("registerDriver: " + driver);}</code></pre><p><code>java.sql.Driver</code>就是服务提供者接口，<code>NonRegisteringDriver</code>就是其实现类，<code>com.mysql.jdbc.Driver</code>只是进行注册。在静态代码块中调用了<code>DriverManager.registerDriver</code>方法，并且将实现类添加到JDBC的注册列表（registeredDrivers）。所以在我们通过反射加载<code>com.mysql.jdbc.Driver</code>就可以完成注册了。</p><p>客户端如何调用服务</p><pre><code>DriverManager.getConnection("jdbc:mysql:///mydatabase", "root", "root");</code></pre><pre><code>public static Connection getConnection(String url,    String user, String password) throws SQLException {    java.util.Properties info = new java.util.Properties();    if (user != null) {        info.put("user", user);    }    if (password != null) {        info.put("password", password);    }    return (getConnection(url, info, Reflection.getCallerClass()));}</code></pre><p><code>getConnection</code>方法中的片段</p><pre><code>for(DriverInfo aDriver : registeredDrivers) {    // If the caller does not have permission to load the driver then    // skip it.    if(isDriverAllowed(aDriver.driver, callerCL)) {        try {            println("    trying " + aDriver.driver.getClass().getName());            Connection con = aDriver.driver.connect(url, info);            if (con != null) {                // Success!                println("getConnection returning " + aDriver.driver.getClass().getName());                return (con);            }        } catch (SQLException ex) {            if (reason == null) {                reason = ex;            }        }    } else {        println("    skipping: " + aDriver.getClass().getName());    }}</code></pre><p>重点是遍历<code>registeredDrivers</code>这就上面注册服务的注册列表<br><code>aDriver.driver.connect(url, info);</code><br>这个就是服务提供者进行自己实现的方法，如果URL符合提供者自己的规则就返回对应<code>Connection</code></p><p>总结：</p><p>所以对于JDBC来说<code>Connection</code>就是<strong>服务接口</strong>，<code>DriverManager.registerDriver</code>是<strong>提供者注册API</strong>，<code>DriverManager.getConnection</code>是<strong>服务访问API</strong>，<code>Driver</code>是<strong>服务提供者接口</strong>。</p><p>参考文章：</p><p><a href="https://www.jianshu.com/p/4d7a0cd36a82" target="_blank" rel="noopener">https://www.jianshu.com/p/4d7a0cd36a82</a></p><p><a href="https://blog.csdn.net/zhangshaoqiangchn/article/details/65442234" target="_blank" rel="noopener">https://blog.csdn.net/zhangshaoqiangchn/article/details/65442234</a></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Effective Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用第三方组件</title>
      <link href="/2019/08/10/chang-yong-di-san-fang-zu-jian-ku/"/>
      <url>/2019/08/10/chang-yong-di-san-fang-zu-jian-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="常用Apache-Commons组件"><a href="#常用Apache-Commons组件" class="headerlink" title="常用Apache Commons组件"></a>常用Apache Commons组件</h2><h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3><pre><code>&lt;!--操作Java Bean--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;    &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;    &lt;version&gt;1.7.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>BeanUtils主要是封装了java反射(reflection)和自省（introspection）API，来对javabean进行操作。这里介绍BeanUtils的几个常用方法:</p><pre><code>public static Object cloneBean(Object bean) // 克隆对象(此处未实现深度clone，复杂对象clone的依然只是引用)public static void copyProperties(Object dest, Object orig) // 赋值public static void setProperty(Object bean, String name, Object value) // 设置bean中某个属性的值public static String getProperty(Object bean, String name) // 得到bean中对应属性值public static void populate(Object bean, Map properties) // Map转为bean</code></pre><h3 id="codec"><a href="#codec" class="headerlink" title="codec"></a>codec</h3><pre><code>&lt;!--处理编解码--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-codec&lt;/groupId&gt;    &lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code>public static void main(String[] args) {        //MD5加密        System.out.println("MD5加密：" + DigestUtils.md5Hex("abc"));        //sha加密        System.out.println("sha加密：" + DigestUtils.sha1Hex("abc"));        //加密        String str = "abc";        byte[] b = Base64.encodeBase64(str.getBytes(), true);        System.out.println("base64加密：" + new String(b));        //解密        byte[] b2 = Base64.decodeBase64(b);        System.out.println("base64解密：" + new String(b2));}</code></pre><pre><code>输出：MD5加密：900150983cd24fb0d6963f7d28e17f72sha加密：a9993e364706816aba3e25717850c26c9cd0d89dbase64加密：YWJjbase64解密：abc</code></pre><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><pre><code>&lt;!--扩展集合操作--&gt;&lt;dependency&gt;    &lt;groupId&gt;commons-collections&lt;/groupId&gt;    &lt;artifactId&gt;commons-collections&lt;/artifactId&gt;    &lt;version&gt;3.2.1&lt;/version&gt;&lt;/dependency&gt;</code></pre><pre><code>if (list==null || list.isEmpty()) {}if (list!=null &amp;&amp; !list.isEmpty()) {}</code></pre><p> 可以简化为</p><pre><code>if (CollectionUtils.isEmpty(list)){}if (CollectionUtils.isNotEmpty(list)){}</code></pre><h3 id="BidiMap接口"><a href="#BidiMap接口" class="headerlink" title="BidiMap接口"></a>BidiMap接口</h3><p>双向映射，可以使用值查找键，并且可以使用键轻松查找值。</p><p>示例：</p><pre><code>public static void main(String[] args) {    BidiMap bidi = new TreeBidiMap();    bidi.put("One", "1");    bidi.put("Two", "2");    bidi.put("Three", "3");        // 根据键找值    System.out.println(bidi.get("One"));      // 根据值找键    System.out.println(bidi.getKey("1"));    System.out.println("Original Map: " + bidi);        // 删除当前映射到指定值的键值对    bidi.removeValue("1");    System.out.println("Modified Map: " + bidi);    // 反转键值对，键变值，值变键    BidiMap inversedMap = bidi.inverseBidiMap();    System.out.println("Inversed Map: " + inversedMap);}</code></pre><pre><code>输出：1OneOriginal Map: {One=1, Three=3, Two=2}Modified Map: {Three=3, Two=2}Inversed Map: {2=Two, 3=Three}</code></pre><h3 id="OrderedMap接口"><a href="#OrderedMap接口" class="headerlink" title="OrderedMap接口"></a>OrderedMap接口</h3><p><code>OrderedMap</code>是映射的新接口，用于保留添加元素的顺序。 <code>LinkedMap</code>和<code>ListOrderedMap</code>是两种可用的实现。 此接口支持<code>Map</code>的迭代器，并允许在<code>Map</code>中向前或向后两个方向进行迭代。</p><p>示例：</p><pre><code>public static void main(String[] args) {    OrderedMap map = new LinkedMap();    map.put("One", "1");    map.put("Two", "2");    map.put("Three", "3");    System.out.println(map.firstKey());    System.out.println(map.nextKey("One"));    System.out.println(map.nextKey("Two"));}</code></pre><pre><code>输出：OneTwoThree</code></pre><h3 id="CollectionUtils类"><a href="#CollectionUtils类" class="headerlink" title="CollectionUtils类"></a>CollectionUtils类</h3><p>CollectionUtils的<code>addIgnoreNull()</code>方法可用于确保只有非空(<code>null</code>)值被添加到集合中。</p><pre><code>public static void main(String[] args) {    List&lt;String&gt; list = new LinkedList&lt;String&gt;();    CollectionUtils.addIgnoreNull(list, null);    CollectionUtils.addIgnoreNull(list, "a");    System.out.println(list);    if(list.contains(null)) {        System.out.println("Null value is present");    } else {        System.out.println("Null value is not present");    }}</code></pre><pre><code>输出：[a]Null value is not present</code></pre><h3 id="Lang"><a href="#Lang" class="headerlink" title="Lang"></a>Lang</h3><pre><code>&lt;!--基本对象工具包--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><pre><code>String str = " s s s ";System.out.println(StringUtils.isEmpty(str)); // false，包括空格System.out.println(StringUtils.isBlank(str)); // true，不包括空格StringUtils.trim(str); // 去掉首尾空格String str = null;System.out.println(StringUtils.equals(str,null)); // trueString str = "tests";StringUtils.contains(str, "test"); // true// StringUtils.split方法会丢弃空字符串，并且效率比JDK自带的用正则的split方法高String str = "hello,world";String[] split = StringUtils.split(str, ",");Arrays.stream(split).forEach(System.out::println); </code></pre><h2 id="Google-Guava工具包"><a href="#Google-Guava工具包" class="headerlink" title="Google Guava工具包"></a>Google Guava工具包</h2><pre><code>&lt;!--Google Guava包--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;19.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><h3 id="Preconditions"><a href="#Preconditions" class="headerlink" title="Preconditions"></a>Preconditions</h3><p>对条件做前置判断，经常用在方法的最前面，用来对参数进行校验，不符合则抛出异常。</p><pre><code>Preconditions.checkArgument(user!=null,"user null error"); // user为null则抛出空指针异常Preconditions.checkNotNull(user,"user null"); // 同上</code></pre><h3 id="Objects和MoreObjects"><a href="#Objects和MoreObjects" class="headerlink" title="Objects和MoreObjects"></a>Objects和MoreObjects</h3><p>在开发中经常会需要比较两个对象是否相等，这时候我们需要考虑比较的两个对象是否为<code>null</code>，然后再调用<code>equals</code>方法来比较是否相等，google guava库的<code>com.google.common.base.Objects</code>类提供了一个静态方法<code>equals</code>可以避免我们自己做是否为空的判断</p><pre><code>public static boolean equal(@Nullable Object a, @Nullable Object b) {2    return a == b || (a != null &amp;&amp; a.equals(b));3 }</code></pre><p>首先判断a和b是否是同一个对象，如果是同一对象，那么直接返回相等，如果不是同一对象再判断a不为<code>null</code>并且<code>a.equals(b)</code>，这样做既考虑了性能也考虑了<code>null</code>空指针的问题。</p><p><code>MoreObjects</code>类的还提供了优雅的重写<code>toString</code>方法</p><pre><code>@Overridepublic String toString() {    return MoreObjects.toStringHelper(this.getClass())            .add("name",name)            .add("age",age)            .omitNullValues().toString();}//omitNullValues()方法来指定忽略返回的空值</code></pre><h3 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h3><pre><code>Strings.nullToEmpty(str); // 如果str为null，则转换为空字符串Strings.repeat(str,3); // 重复字符串成为新字符串</code></pre><h3 id="Joiner"><a href="#Joiner" class="headerlink" title="Joiner"></a>Joiner</h3><pre><code>// 使用,拼接字符串，并且忽略nullJoiner joiner = Joiner.on(",").skipNulls();String s = joiner.join("1", null, "2", "3");</code></pre><h3 id="Splitter"><a href="#Splitter" class="headerlink" title="Splitter"></a>Splitter</h3><pre><code>// trimResults表示对结果做trim即去掉首尾空格，omitEmptyStrings表示忽略空字符串Iterable&lt;String&gt; split = Splitter.on(",").trimResults().omitEmptyStrings().split("1,2,3");split.forEach(System.out::print);</code></pre><h3 id="MultiMap"><a href="#MultiMap" class="headerlink" title="MultiMap"></a>MultiMap</h3><p><code>MultiMap</code>是一个key映射多值的<code>Map</code>，类似于<code>Map&lt;K,List&lt;V&gt;&gt;</code>、<code>Map&lt;K,Set&lt;V&gt;&gt;</code> 。主要使用它两个子类<code>ListMultimap</code>和<code>SetMultimap</code>，前者允许重复值，后者不允许。</p><pre><code>Multimap&lt;String,String&gt; multimap= ArrayListMultimap.create();multimap.put("test","1");multimap.put("test","2");Collection&lt;String&gt; test = multimap.get("test");System.out.println(test);// 输出：[1, 2]</code></pre><h3 id="Lists和Maps"><a href="#Lists和Maps" class="headerlink" title="Lists和Maps"></a>Lists和Maps</h3><p><code>Lists</code>和<code>Maps</code>是<code>List</code>和<code>Map</code>的工具类，最大的特性就是提供了静态工厂方法，相比先创建<code>ArrayList</code>再添加元素或者设置初始化方式要优雅得多。</p><pre><code>Lists.newArrayList("1","2","3");Lists.newArrayListWithCapacity(100);</code></pre><h2 id="高效Bean映射框架—Orika"><a href="#高效Bean映射框架—Orika" class="headerlink" title="高效Bean映射框架—Orika"></a>高效Bean映射框架—Orika</h2><p>Orika是java Bean映射框架，可以实现从一个对象递归拷贝数据至另一个对象（深拷贝），在开发多层应用程序中非常有用。在这些层之间交换数据时，通常为了适应不同API需要转换一个实例至另一个实例。总之，可以简化不同层对象之间映射过程。 Orika使用字节码生成器创建开销最小的快速映射，比其他基于反射方式实现（如Dozer、BeanUtils）更快。</p><pre><code>public static void main(String[] args) {//        DefaultMapperFactory mapperFactory = new DefaultMapperFactory.Builder().build();//        MapperFacade mapper = mapperFactory.getMapperFacade();//        User user = new User();//        user.setName("test");//        User user1 = mapper.map(user,User.class);//        System.out.println(user1.getName());  // 不同类之间的复制，如果属性名不一样，可以通过自定义映射来复制，属性名相同则可以直接复制        DefaultMapperFactory mapperFactory = new DefaultMapperFactory.Builder().build();        mapperFactory.classMap(User.class,TestUser.class)                .field("name","testName")                .byDefault()                .register();        MapperFacade mapper = mapperFactory.getMapperFacade();        User user = new User();        user.setName("test");        TestUser testUser = mapper.map(user,TestUser.class);        System.out.println(testUser.getTestName());}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Apache Commons </tag>
            
            <tag> Google Guava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis安装</title>
      <link href="/2019/08/10/redis-an-zhuang/"/>
      <url>/2019/08/10/redis-an-zhuang/</url>
      
        <content type="html"><![CDATA[<h2 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h2><p><strong>1. 安装wget</strong></p><pre><code>yum -y install wget</code></pre><p><strong>2. 下载redis</strong></p><pre><code>wget http://download.redis.io/releases/redis-4.0.2.tar.gz</code></pre><p><strong>3. 解压redis</strong></p><pre><code>tar -xzvf redis-4.0.2.tar.gz</code></pre><p><strong>4. 安装gcc编译环境</strong></p><p>由于redis是用C语言写的，所以我们在编译前需要安装gcc环境</p><pre><code>yum -y install gcc automake autoconf libtool make</code></pre><p><strong>5. 编译安装redis</strong></p><p>执行以下3条命令</p><pre><code>#切换目录cd redis-4.0.2#编译make#安装，默认安装到/usr/local，下面系统还会自动新建一个bin的文件夹用于存放操作redis的工具make install</code></pre><p>这里需要注意是，如果你想指定安装的目录，执行以下命令</p><pre><code>#指定安装到/usr/local/redis目录下make PREFIX=/usr/local/redis install</code></pre><h2 id="二、启动"><a href="#二、启动" class="headerlink" title="二、启动"></a>二、启动</h2><p>由于我是默认安装的，所以安装到了/usr/local/下，启动redis服务端</p><pre><code>#进入对应的安装目录 cd /usr/local/bin#执行命令redis-server</code></pre><p><img src="/images/Snipaste_2019-05-25_19-44-18.png" alt=""></p><p><img src="/images/Snipaste_2019-05-25_19-48-31.png" alt=""></p><p>然后保证此终端不关闭，重新打开一个新的终端，用于启动redis的客户端</p><pre><code>#进入对应的安装目录 cd /usr/local/bin#执行命令redis-cli#然后ping一下，出现PONG则表示连接成功</code></pre><p><img src="/images/Snipaste_2019-05-25_19-52-09.png" alt=""></p><h2 id="三、配置redis"><a href="#三、配置redis" class="headerlink" title="三、配置redis"></a>三、配置redis</h2><p>如果用上面的方式启动redis是否稍显麻烦，我们是否可以以后台守护进程的方式启动redis呢？答案是可以的，同时我们还可以将reids配置成开机自启动</p><p>在此之前，我们先来看下redis的配置文件</p><p><strong>redis.conf 配置文件详解</strong></p><pre><code>1. Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程    daemonize no2. 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定    pidfile /var/run/redis.pid3. 指定Redis监听端口，默认端口为6379，为什么选用6379作为默认端口，因为6379在手机按键上MERZ对应的号码，而MERZ取自意大利歌女Alessia Merz的名字    port 63794. 绑定的主机地址    bind 127.0.0.15.当 客户端闲置多长时间后关闭连接，如果指定为0，表示关闭该功能    timeout 3006. 指定日志记录级别，Redis总共支持四个级别：debug、verbose、notice、warning，默认为verbose    loglevel verbose7. 日志记录方式，默认为标准输出，如果配置Redis为守护进程方式运行，而这里又配置为日志记录方式为标准输出，则日志将会发送给/dev/null    logfile stdout8. 设置数据库的数量，默认数据库为0，可以使用SELECT &lt;dbid&gt;命令在连接上指定数据库id    databases 169. 指定在多长时间内，有多少次更新操作，就将数据同步到数据文件，可以多个条件配合    save &lt;seconds&gt; &lt;changes&gt;    Redis默认配置文件中提供了三个条件：    save 900 1    save 300 10    save 60 10000    分别表示900秒（15分钟）内有1个更改，300秒（5分钟）内有10个更改以及60秒内有10000个更改。10. 指定存储至本地数据库时是否压缩数据，默认为yes，Redis采用LZF压缩，如果为了节省CPU时间，可以关闭该选项，但会导致数据库文件变的巨大    rdbcompression yes11. 指定本地数据库文件名，默认值为dump.rdb    dbfilename dump.rdb12. 指定本地数据库存放目录    dir ./13. 设置当本机为slav服务时，设置master服务的IP地址及端口，在Redis启动时，它会自动从master进行数据同步    slaveof &lt;masterip&gt; &lt;masterport&gt;14. 当master服务设置了密码保护时，slav服务连接master的密码    masterauth &lt;master-password&gt;15. 设置Redis连接密码，如果配置了连接密码，客户端在连接Redis时需要通过AUTH &lt;password&gt;命令提供密码，默认关闭    requirepass foobared16. 设置同一时间最大客户端连接数，默认无限制，Redis可以同时打开的客户端连接数为Redis进程可以打开的最大文件描述符数，如果设置 maxclients 0，表示不作限制。当客户端连接数到达限制时，Redis会关闭新的连接并向客户端返回max number of clients reached错误信息    maxclients 12817. 指定Redis最大内存限制，Redis在启动时会把数据加载到内存中，达到最大内存后，Redis会先尝试清除已到期或即将到期的Key，当此方法处理 后，仍然到达最大内存设置，将无法再进行写入操作，但仍然可以进行读取操作。Redis新的vm机制，会把Key存放内存，Value会存放在swap区    maxmemory &lt;bytes&gt;18. 指定是否在每次更新操作后进行日志记录，Redis在默认情况下是异步的把数据写入磁盘，如果不开启，可能会在断电时导致一段时间内的数据丢失。因为 redis本身同步数据文件是按上面save条件来同步的，所以有的数据会在一段时间内只存在于内存中。默认为no    appendonly no19. 指定更新日志文件名，默认为appendonly.aof     appendfilename appendonly.aof20. 指定更新日志条件，共有3个可选值：     no：表示等操作系统进行数据缓存同步到磁盘（快）     always：表示每次更新操作后手动调用fsync()将数据写到磁盘（慢，安全）     everysec：表示每秒同步一次（折中，默认值）    appendfsync everysec21. 指定是否启用虚拟内存机制，默认值为no，简单的介绍一下，VM机制将数据分页存放，由Redis将访问量较少的页即冷数据swap到磁盘上，访问多的页面由磁盘自动换出到内存中（在后面的文章我会仔细分析Redis的VM机制）     vm-enabled no22. 虚拟内存文件路径，默认值为/tmp/redis.swap，不可多个Redis实例共享     vm-swap-file /tmp/redis.swap23. 将所有大于vm-max-memory的数据存入虚拟内存,无论vm-max-memory设置多小,所有索引数据都是内存存储的(Redis的索引数据 就是keys),也就是说,当vm-max-memory设置为0的时候,其实是所有value都存在于磁盘。默认值为0     vm-max-memory 024. Redis swap文件分成了很多的page，一个对象可以保存在多个page上面，但一个page上不能被多个对象共享，vm-page-size是要根据存储的 数据大小来设定的，作者建议如果存储很多小对象，page大小最好设置为32或者64bytes；如果存储很大大对象，则可以使用更大的page，如果不 确定，就使用默认值     vm-page-size 3225. 设置swap文件中的page数量，由于页表（一种表示页面空闲或使用的bitmap）是在放在内存中的，，在磁盘上每8个pages将消耗1byte的内存。     vm-pages 13421772826. 设置访问swap文件的线程数,最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的，可能会造成比较长时间的延迟。默认值为4     vm-max-threads 427. 设置在向客户端应答时，是否把较小的包合并为一个包发送，默认为开启    glueoutputbuf yes28. 指定在超过一定的数量或者最大的元素超过某一临界值时，采用一种特殊的哈希算法    hash-max-zipmap-entries 64    hash-max-zipmap-value 51229. 指定是否激活重置哈希，默认为开启（后面在介绍Redis的哈希算法时具体介绍）    activerehashing yes30. 指定包含其它的配置文件，可以在同一主机上多个Redis实例之间使用同一份配置文件，而同时各个实例又拥有自己的特定配置文件    include /path/to/local.conf</code></pre><p><strong>把redis配置成开机启动</strong></p><p>在/etc/init.d中添加启动脚本，启动脚本的模板在redis源代码目录的utils文件夹中有，叫redis_init_script,我们把这个文件复制到/etc/init.d文件夹中，并重命名为redis-6379，那么以后启动的服务名也是这个，如 <code>service redis-6379 start</code></p><p>我们进入/etc/init.d目录，查看这个文件的内容</p><pre><code>#!/bin/sh# chkconfig: 2345 90 10# description: Redis is a persistent key-value database ## Simple Redis init.d script conceived to work on Linux systems# as it does use of the /proc filesystem.REDISPORT=6379EXEC=/usr/local/bin/redis-serverCLIEXEC=/usr/local/bin/redis-cliPIDFILE=/var/run/redis_${REDISPORT}.pidCONF="/etc/redis/${REDISPORT}.conf"case "$1" in    start)        if [ -f $PIDFILE ]        then                echo "$PIDFILE exists, process is already running or crashed"        else                echo "Starting Redis server..."                $EXEC $CONF        fi        ;;    stop)        if [ ! -f $PIDFILE ]        then                echo "$PIDFILE does not exist, process is not running"        else                PID=$(cat $PIDFILE)                echo "Stopping ..."                $CLIEXEC -p $REDISPORT shutdown                while [ -x /proc/${PID} ]                do                    echo "Waiting for Redis to shutdown ..."                    sleep 1                done                echo "Redis stopped"        fi        ;;    *)        echo "Please use start or stop as first argument"        ;;esac</code></pre><p>注意到<code>CONF="/etc/redis/${REDISPORT}.conf"</code>，我们还没有配置启动时的配置文件，而且需要在这个目录下才生效，我们把redis配置文件复制到/etc/redis下，并且重命名为<code>端口号.conf</code>，这里也就是<code>6379.conf</code></p><p><code>6379.conf</code>配置文件只需修改如下几个地方:</p><pre><code>daemonize no改成yes#bind 127.0.0.1 注释掉requirepass  你的密码</code></pre><p>如果要使redis开机自启动，那么执行如下命令</p><pre><code>#设置开机执行redis脚本chkconfig redis_6379 on</code></pre><p>但是你会发现，上面的命令报错了<code>service redisd does not support chkconfig</code></p><p>解决办法是在<code>redis-6379</code>脚本文件中开头加如下两行注释</p><pre><code># chkconfig: 2345 90 10# description: Redis is a persistent key-value database </code></pre><p>注释的意思是，redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10</p><p>通过上面的操作后，我们就可以通过如下命令启动和停止redis</p><pre><code>service redis-6379 startservice redis-6379 stop</code></pre><p>但是，按照以下步骤操作下来，你会发现当你启动redis后，却无法停止redis，具体错误如下</p><pre><code>service redis stopStopping ...OK(error) NOAUTH Authentication required.Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...Waiting for Redis to shutdown ...</code></pre><p>出现以上错误的解决办法如下</p><p>1.先杀死正在执行的redis进程</p><pre><code>#查看redis进程ps -ef | grep redis#杀死进程kill 进程号</code></pre><p>2.修改redis服务脚本，加入如下信息</p><pre><code>vim /etc/init.d/redis-6379#修改下面这行$CLIEXEC -a "你的redis连接密码" -p $REDISPORT shutdown</code></pre><p>然后再执行一次启动和停止，就不会出现无法停止的情况了，至此，redis的开机后台自启动配置完成。</p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Centos7根目录扩容</title>
      <link href="/2019/08/10/centos7-zeng-jia-home-de-fen-qu-kong-jian-gei-gen-mu-lu/"/>
      <url>/2019/08/10/centos7-zeng-jia-home-de-fen-qu-kong-jian-gei-gen-mu-lu/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<a href="https://blog.csdn.net/wzhwei1987/article/details/82975455" target="_blank" rel="noopener">https://blog.csdn.net/wzhwei1987/article/details/82975455</a></p><p>1.卸载/home</p><p><code>umount /home</code></p><p>2.删除/home所在的lv逻辑卷</p><p><code>lvremove /dev/mapper/centos-home</code></p><p>3.扩展/root所在的lv</p><p><code>lvextend -L +你分配的大小  /dev/mapper/centos-root</code></p><p>4.扩展/root文件系统</p><p><code>xfs_info /dev/mapper/centos-root</code></p><p><code>xfs_growfs /dev/mapper/centos-root</code></p><p>5.重新创建home lv</p><p><code>lvcreate -L 分配大小 -n home centos</code></p><p>6.创建文件系统</p><p><code>mkfs.xfs  /dev/mapper/centos-home</code></p><p>7.挂载</p><p><code>mount  /dev/mapper/centos-home  /home</code></p><p>8.验证</p><p><code>df -h</code></p><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Centos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Data JPA规范</title>
      <link href="/2019/08/10/spring/spring-data-jpa-gui-fan/"/>
      <url>/2019/08/10/spring/spring-data-jpa-gui-fan/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本注解"><a href="#一、基本注解" class="headerlink" title="一、基本注解"></a>一、基本注解</h2><h3 id="1-Entity"><a href="#1-Entity" class="headerlink" title="1.@Entity"></a>1.@Entity</h3><p>由<code>@Entity</code>定义的对象会成为被JPA管理的实体，将映射到指定的数据库表中。</p><p>源码如下：</p><pre><code>public @interface Entity {    //可选，默认是此实体类的名字，全局唯一    String name() default "";}</code></pre><h3 id="2-Table"><a href="#2-Table" class="headerlink" title="2.@Table"></a>2.@Table</h3><p>用于指定数据库的表名。</p><p>源码如下：</p><pre><code>public @interface Table {    //表的名字，如果不写，则默认与实体的名字一样    String name() default "";    //此表的catalog    String catalog() default "";    //此表的schema    String schema() default "";    //唯一性约束，只有创建表的时候用，默认不需要    UniqueConstraint[] uniqueConstraints() default {};    //索引，只有创建表的时候使用，默认不需要    Index[] indexes() default {};}</code></pre><h3 id="3-Id"><a href="#3-Id" class="headerlink" title="3.@Id"></a>3.@Id</h3><p>定义数据库的主键，一个实体里至少有一个主键。</p><h3 id="4-IdClass"><a href="#4-IdClass" class="headerlink" title="4.@IdClass"></a>4.@IdClass</h3><p>利用外部类的联合主键。</p><p>源码如下：</p><pre><code>public @interface IdClass {    //联合主键的类    Class value();}</code></pre><p>需要满足以下几点：</p><ul><li><p>必须实现<code>Serializable</code>接口</p></li><li><p>必须有默认的<code>public</code>无参构造方法</p></li><li><p>必须覆盖<code>equals</code>和<code>hashCode</code>方法。<code>equals</code>方法用于判断两个对象是否相等，<code>EntityManger</code>通过<code>find</code>方法来查找<code>Entity</code>时是根据<code>equals</code>的返回值来判断的。<code>hashCode</code>方法返回当前对象的哈希码，生成的<code>hashCode()</code>相同的概率越小越好，算法可以进行优化。</p></li></ul><p>联合主键的用处就是一个表中能存在多个主键，这些主键在关联在外部的一个对象中，这个对象需要满足以上条件。然后在需要关联主键的实体上加上<code>@IdClass</code>（value=关联主键对象.class）</p><h3 id="5-GeneratedValue"><a href="#5-GeneratedValue" class="headerlink" title="5.@GeneratedValue"></a>5.@GeneratedValue</h3><p>主键生成策略。</p><p>源码如下：</p><pre><code>public @interface GeneratedValue {    //Id生成策略，默认GenerationType.AUTO    GenerationType strategy() default GenerationType.AUTO;    //通过Sequences生成Id，常见的是Orcale数据库的Id生成规则，需要配合@SequenceGenerator使用    String generator() default "";}</code></pre><p><code>GenerationType</code>有以下4个值：</p><pre><code>public enum GenerationType {    //通过表产生主键，框架由表模拟序列产生主键，使用该策略可以使应用更易于数据库移植    TABLE,    //通过序列产生主键，通过@SequenceGenerator注解指定序列名，Mysql不支持这种方式    SEQUENCE,    //采用数据库Id自增，用于Mysql数据库    IDENTITY,    //JPA默认选项，自动选择策略    AUTO;    private GenerationType() {    }}</code></pre><h3 id="6-Basic"><a href="#6-Basic" class="headerlink" title="6.@Basic"></a>6.@Basic</h3><p><code>@Basic</code>表示属性是到数据库的字段的映射，如果实体的字段上没有任何注解，默认为<code>@Basic</code>。</p><p>源码如下：</p><pre><code>public @interface Basic {    //EAGER是立即加载，这是默认方式，可以看到还有一种LAZY懒加载    FetchType fetch() default FetchType.EAGER;    //Optional 类是一个可以为null的容器对象，设置为true，则表示字段可以为null，默认可以    boolean optional() default true;}public enum FetchType {    LAZY,    EAGER;    private FetchType() {    }}</code></pre><h3 id="7-Transient"><a href="#7-Transient" class="headerlink" title="7.@Transient"></a>7.@Transient</h3><p><code>@Transient</code>表示该属性并非一个到数据库表的字段的映射，是非持久化属性，与<code>@Basic</code>作用相反。</p><p>当你实体中有数据库中不存在的字段，但是又需要用到，那么可以加上<code>@Transient</code>注解，忽略这个字段的映射。</p><h3 id="8-Column"><a href="#8-Column" class="headerlink" title="8.@Column"></a>8.@Column</h3><p>定义属性对应数据库中的列名。</p><p>源码如下：</p><pre><code>public @interface Column {    String name() default "";    //表示该字段是否为唯一标识，默认为false，如果表中有一个字段需要唯一标识，则既可以使用该标记，也可以使用@Table标记中的@UniqueConstraint    boolean unique() default false;    //数据字段是否允许为空，默认允许    boolean nullable() default true;    //执行insert操作时是否包含此字段，默认包含    boolean insertable() default true;    //执行update操作时是否包含此字段，默认包含    //insertable和updatable属性一般多用于只读的属性，例如主键和外键等。这些字段的值通常是自动生成的    boolean updatable() default true;    //表示创建表时，该字段创建的SQL语句，一般用于通过Entity生成表定义时使用    String columnDefinition() default "";    //表示当映射多个表时，指定表的表中的字段。默认值为主表的表名    String table() default "";    //字段长度，默认255    int length() default 255;    // precision属性和scale属性表示精度，当字段类型为double时，precision表示数值的总长度，scale表示小数点所占的位数    int precision() default 0;    int scale() default 0;}</code></pre><h3 id="9-Temporal"><a href="#9-Temporal" class="headerlink" title="9.@Temporal"></a>9.@Temporal</h3><p><code>@Temporal</code>用来设置<code>Date</code>类型的属性映射到对应精度的字段，也就是对日期进行格式化。</p><p>源码如下：</p><pre><code>public enum TemporalType {    DATE,    TIME,    TIMESTAMP;    private TemporalType() {    }}public @interface Temporal {    TemporalType value();}public enum TemporalType {    DATE,    TIME,    TIMESTAMP;    private TemporalType() {    }}</code></pre><p>可以看到有三种格式化方式，</p><p>第一种：<code>@Temporal(TemporalType.DATE)</code>——&gt;实体类会封装成日期“yyyy-MM-dd”的 Date类型。</p><p>第二种：<code>@Temporal(TemporalType.TIME)</code>——&gt;实体类会封装成时间“hh-MM-ss”的 Date类型。</p><p>第三种：<code>@Temporal(TemporalType.TIMESTAMP)</code>——&gt;实体类会封装成完整的时间“yyyy-MM-dd hh:MM:ss”的 Date类型。</p><h3 id="10-Enumerated"><a href="#10-Enumerated" class="headerlink" title="10.@Enumerated"></a>10.@Enumerated</h3><p>用于直接映射枚举类型的字段。</p><p>源码如下：</p><pre><code>public @interface Enumerated {    EnumType value() default EnumType.ORDINAL;}</code></pre><h3 id="11-Lob"><a href="#11-Lob" class="headerlink" title="11.@Lob"></a>11.@Lob</h3><p><code>@Lob</code>将属性映射为数据库支持的大对象类型，支持以下两种数据库类型的字段。</p><p>（1）<code>Clob</code>：长字符串类型，<code>java.sql.Clob</code>、<code>Character[]</code>、<code>char[]</code>、<code>String</code>都将被映射成<code>Clob</code>类型。</p><p>（2）<code>Blob</code>：字节类型，<code>java.sql.Blob</code>、<code>Byte[]</code>、<code>byte[]</code>、实现了<code>Serializable</code>接口类型都将被映射成<code>Blob</code>类型。</p><h2 id="二、关联关系注解"><a href="#二、关联关系注解" class="headerlink" title="二、关联关系注解"></a>二、关联关系注解</h2><h3 id="1-JoinColumn"><a href="#1-JoinColumn" class="headerlink" title="1.@JoinColumn"></a>1.@JoinColumn</h3><p>定义外键关联的字段名称。</p><p>源码如下：</p><pre><code>public @interface JoinColumn {    //注解所在当前表的主键名，必须写    String name() default "";    //关联外部表的列名，默认是外部主键名    String referencedColumnName() default "";    //外键字段是否唯一    boolean unique() default false;    //外键字段是否允许为空    boolean nullable() default true;    //是否跟随一起新增    boolean insertable() default true;    //是否跟随一起更新    boolean updatable() default true;    String columnDefinition() default "";    String table() default "";    ForeignKey foreignKey() default @ForeignKey(ConstraintMode.PROVIDER_DEFAULT);}</code></pre><p>配合<code>@OneToOne</code>、<code>@OneToMany</code>、<code>@ManyToOne</code>一起使用。</p><h3 id="2-OneToOne"><a href="#2-OneToOne" class="headerlink" title="2.@OneToOne"></a>2.@OneToOne</h3><p>源码如下：</p><pre><code>public @interface OneToOne {    //关系目标实体，默认为该字段的类型    Class targetEntity() default void.class;    //级联操作策略    1.CascadeType.PERSIST 级联新建    2.CascadeType.MERGE   级联更新    3.CascadeType.REMOVE  级联删除    4.CascadeType.REFRESH 级联刷新，比如A先对商品修改，B后来修改商品时需要先刷新A修改的商品才可以修改    5.CascadeType.DETACH  级联脱管/游离操作，如果你要删除一个实体，但是它有外键无法删除，你就需要这个级联权限了。它会撤销所有相关的外键关联    6.CascadeType.ALL     拥有以上所有级联操作权限    7.默认，关系表不会产生任何影响    CascadeType[] cascade() default {};    //数据获取方式，立即加载和延迟加载    FetchType fetch() default FetchType.EAGER;    boolean optional() default true;    //关联关系被谁维护，一般不需要特别指定    注意：只有关系维护方才能操作两者的关系，被维护方即使设置了维护方属性进行存储也不会更新外键关联    //mappedBy不能与@JoinColumn或者@JoinTable同时使用    //mappedBy的值是指另一方的实体里属性的字段，而不是数据库字段，也不是实体的对象的名字，是另一方配置了@JoinColumn或者@JoinTable注解的属性的字段名称    String mappedBy() default "";    //是否级联删除，和CascadeType.REMOVE的效果一样，只是配置了两种中的一种就会自动级联删除    boolean orphanRemoval() default false;}public enum CascadeType {    ALL,    PERSIST,    MERGE,    REMOVE,    REFRESH,    DETACH;    private CascadeType() {    }}</code></pre><p><code>@OneToOne</code>需要配合<code>@JoinColumn</code>一起使用</p><p>在使用<code>@OneToOne</code>进行双向关联时，需要在类上加上注解<code>@JsonIdentityInfo</code>，这个注解被用来在序列化/反序列化时为该对象或字段添加一个对象识别码，通常是用来解决循环嵌套的问题。通过配置属性generator来确定识别码生成的方式，配置属性property来确定识别码的名称，识别码名称没有限制。</p><p>一般这个注解可以这么加，</p><p><code>@JsonIdentityInfo(generator =ObjectIdGenerators.PropertyGenerator.class,property = "id")</code></p><h3 id="3-OneToMany和-ManyToOne"><a href="#3-OneToMany和-ManyToOne" class="headerlink" title="3.@OneToMany和@ManyToOne"></a>3.@OneToMany和@ManyToOne</h3><p>自行分析，同上。</p><h3 id="4-OrderBy"><a href="#4-OrderBy" class="headerlink" title="4.OrderBy"></a>4.OrderBy</h3><p>用于关联查询时排序。</p><p><code>@orderBy（“字段名   ASC|DESC”）</code></p><h3 id="5-一些注意事项"><a href="#5-一些注意事项" class="headerlink" title="5.一些注意事项"></a>5.一些注意事项</h3><p>（1）所有的注解要么全配置在字段上，要么全配置在get方法上，不要混用，否则会报错。</p><p>（2）在关联查询中，表一般不需要建立外键索引。</p><h2 id="三、定义查询方法"><a href="#三、定义查询方法" class="headerlink" title="三、定义查询方法"></a>三、定义查询方法</h2><h3 id="1-选择性暴露CRUD方法"><a href="#1-选择性暴露CRUD方法" class="headerlink" title="1.选择性暴露CRUD方法"></a>1.选择性暴露CRUD方法</h3><pre><code>@NoRepositoryBeanpublic interface MyRepository&lt;T,ID extends Serializable&gt; extends Repository&lt;T,ID&gt; {    T findOne(ID id);    T save(T entity);}</code></pre><p>通过自定义的公共基础接口，有选择的暴露了CRUD的方法。之后的数据接口只需要继承它即可。</p><h3 id="2-方法的查询策略的属性表达式"><a href="#2-方法的查询策略的属性表达式" class="headerlink" title="2.方法的查询策略的属性表达式"></a>2.方法的查询策略的属性表达式</h3><p>假设一个<code>User</code>实体对象中有一个属性<code>userCard</code>，这个属性中包含有一个<code>userId</code>，在这种情况下，如果要通过<code>userId</code>查询<code>User</code>对象，那么查询方法写成：</p><pre><code>User findByUserCardCardId(String userId);</code></pre><p>为了解决属性匹配歧义问题，JPA保留了下划线字符，只需要在特定地方加上下划线，即可分割属性，当然强烈建议遵循Java驼峰命名规范。</p><pre><code>User findByUserCard_CardId(String id);</code></pre><h3 id="3-Projections对查询结果的扩展"><a href="#3-Projections对查询结果的扩展" class="headerlink" title="3.Projections对查询结果的扩展"></a>3.Projections对查询结果的扩展</h3><p>一般情况下，我们只需要返回一行数据的某些字段，但是JPA默认查找总会给我们全部返回，这样如果只需要其中几个字段，还需要手动去封装。Spring JPA考虑到这一点，允许对专用返回类型进行建模，以便我们有更多选择，将部分字段显示成视图对象。</p><p>现有两种方法可以进行建模。</p><p>（1）声明一个接口，接口中包含需要返回的属性的方法。</p><p>比如我有一个<code>User</code>实体，里面有4个字段，分别为<code>id</code>，<code>name</code>，<code>email</code>，<code>gender</code>，我现在只需要返回<code>name</code>和<code>email</code>，那么我可以这么定义接口。</p><pre><code>public interface NameAndEmail {    String getName();    String getEmail();}</code></pre><p>   <code>Repository</code>中这么写：</p><pre><code>// 我这里是通过name查找的NameAndEmail findByName(String name);</code></pre><p>Controller写法示例：</p><pre><code>@RequestMapping("/findByName")@ResponseBodypublic NameAndEmail findByName(){    return userRepository.findByName("fcy");}</code></pre><p>（2）使用Dto，定义自己的Dto实体类。</p><pre><code>@Datapublic class NameAndEmailDto {    private String name;    private String email;    public NameAndEmailDto(String name, String email) {        this.name = name;        this.email = email;    }}</code></pre><p>  <code>Repository</code>中这么写：</p><pre><code>Collection&lt;?&gt; findByName(String name, Class&lt;?&gt; type);</code></pre><p><code>Controller</code>写法示例：</p><pre><code>@RequestMapping("/findByName")@ResponseBodypublic Collection&lt;?&gt; findByName(){    return userRepository.findByName("fcy",NameAndEmailDto.class);}//当然这里还可以传入 User.class,这样就返回所有字段了，算是通用接口，推荐这个写法</code></pre><h2 id="四、注解式查询方法"><a href="#四、注解式查询方法" class="headerlink" title="四、注解式查询方法"></a>四、注解式查询方法</h2><h3 id="1-Query"><a href="#1-Query" class="headerlink" title="1.@Query"></a>1.@Query</h3><p>源码如下：</p><pre><code>public @interface Query {    //指定JPQL的查询语句，nativeQuery=true时，是原生SQL语句    String value() default "";    //指定count的JPQL语句，如果不指定将根据query自动生成    String countQuery() default "";    //根据哪个字段来count，默认即可    String countProjection() default "";    //默认为false，表示不是原生SQL，如果要用原生SQL，改成true    boolean nativeQuery() default false;    //可以指定一个query的名字，必须是唯一的    String name() default "";    //可以指定一个count的query的名字，必须是唯一的    String countName() default "";}</code></pre><p>注意：<code>nativeQuery</code>不支持直接<code>Sort</code>的参数查询。</p><p><strong>JPQL语句不支持insert</strong></p><p><code>nativeQuery</code>排序的错误写法：</p><pre><code>@Query（value="......",nativeQuery=true）User findByName（String name,Sort sort） </code></pre><p>正确的排序写法是通过<code>order by</code>来查询。</p><h4 id="Query排序"><a href="#Query排序" class="headerlink" title="@Query排序"></a>@Query排序</h4><pre><code>//使用JPQL语句@Query(value = "select u from User u where u.name like ?1%")List&lt;NameAndEmail&gt; findByAndSort(String name, Sort sort);</code></pre><p><code>new Sort</code>里的属性必须是实体类中的字段，如下。</p><pre><code>userRepository.findByAndSort("f",new Sort("name"));</code></pre><h4 id="Query分页"><a href="#Query分页" class="headerlink" title="@Query分页"></a>@Query分页</h4><pre><code>@Query("select u from User u where u.email=?1")Page&lt;NameAndEmail&gt; findByEmail(String email, Pageable pageable);</code></pre><pre><code>userRepository.findByEmail("XXXXXXX",new PageRequest(1,10));</code></pre><h3 id="2-Param"><a href="#2-Param" class="headerlink" title="2.@Param"></a>2.@Param</h3><p>默认参数是通过顺序绑定在查询语句上的，这使得查询方法对参数位置的重构容易出错。为了解决这个问题，可以使用@Param注解指定方法参数的具体名称，通过绑定的参数名称做查询条件。</p><p>如下：</p><pre><code>@Query("select u from User u where u.email = :email")Page&lt;NameAndEmail&gt; findByEmail(@Param("email") String email, Pageable pageable);</code></pre><h3 id="3-Modifying"><a href="#3-Modifying" class="headerlink" title="3.@Modifying"></a>3.@Modifying</h3><p>源码如下：</p><pre><code>public @interface Modifying {    boolean flushAutomatically() default false;    //我们知道jpa底层实现会有二级缓存，也就是在更新完数据库后，如果后面去用这个对象，你再去查这个对象，这个对象是在一级缓存中，并没有跟数据库同步，这个时候用clearAutomatically=true,就会刷新hibernate的一级缓存了，否则你在同一接口中，更新一个对象，接着查询这个对象，那么你查出来的这个对象还是没有更新之前的状态。    boolean clearAutomatically() default false;}</code></pre><p>在<code>@Query</code>注解中编写JPQL实现DELETE和UPDATE操作的时候必须加上<code>@Modifying</code>注解，以通知Spring Data这是一个DELETE或UPDATE操作。</p><h2 id="五、JpaRepository的扩展"><a href="#五、JpaRepository的扩展" class="headerlink" title="五、JpaRepository的扩展"></a>五、JpaRepository的扩展</h2><h3 id="1-QueryByExampleExecutor"><a href="#1-QueryByExampleExecutor" class="headerlink" title="1.QueryByExampleExecutor"></a>1.QueryByExampleExecutor</h3><p>源码如下：</p><pre><code>public interface QueryByExampleExecutor&lt;T&gt; {    //根据“实例”查找一个对象    &lt;S extends T&gt; Optional&lt;S&gt; findOne(Example&lt;S&gt; var1);    &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1);    &lt;S extends T&gt; Iterable&lt;S&gt; findAll(Example&lt;S&gt; var1, Sort var2);    &lt;S extends T&gt; Page&lt;S&gt; findAll(Example&lt;S&gt; var1, Pageable var2);    &lt;S extends T&gt; long count(Example&lt;S&gt; var1);    &lt;S extends T&gt; boolean exists(Example&lt;S&gt; var1);}</code></pre><pre><code>public interface Example&lt;T&gt; {    static &lt;T&gt; Example&lt;T&gt; of(T probe) {        return new TypedExample(probe, ExampleMatcher.matching());    }    static &lt;T&gt; Example&lt;T&gt; of(T probe, ExampleMatcher matcher) {        return new TypedExample(probe, matcher);    }    T getProbe();    ExampleMatcher getMatcher();    default Class&lt;T&gt; getProbeType() {        return ProxyUtils.getUserClass(this.getProbe().getClass());    }}</code></pre><p><code>Example</code>主要包含：</p><ul><li><p><code>probe</code>：这是具有填充字段的域对象的实际实体类，即查询条的封装类，必填。</p></li><li><p><code>ExampleMatcher</code>：<code>ExampleMatcher</code>源码中有关于如何匹配特定字段的匹配规则，它可以重复使用在多个示例，必填，有默认值。</p></li><li><p><code>Example</code>：用于创建查询。</p></li></ul><h4 id="理解ExampleMatcher"><a href="#理解ExampleMatcher" class="headerlink" title="理解ExampleMatcher"></a>理解ExampleMatcher</h4><pre><code>//现在ExampleMatcher好像变成interface了public class ExampleMatcher {NullHandler nullHandler; //Null值处理方式StringMatcher defaultStringMatcher; //默认字符串匹配方式boolean defaultIgnoreCase; //默认大小写忽略方式PropertySpecifiers propertySpecifiers; //各属性特定查询方式Set&lt;String&gt; ignoredPaths; //忽略属性列表......}</code></pre><p>（1）<code>nullHandler</code>：Null值处理方式，枚举类型，有2个可选值：</p><ul><li><p>INCLUDE（包括）</p></li><li><p>IGNORE（忽略）</p><p>标识作为条件的实体对象中，一个属性值（条件值）为Null是，是否参与过滤。当该选项值是INCLUDE时，表示仍参与过滤，会匹配数据库表中该字段值是Null的记录；若为IGNORE值，表示不参与过滤。</p></li></ul><p>（2）<code>defaultStringMatcher</code>：默认字符串匹配方式，枚举类型，有6个可选值：</p><ul><li><p>DEFAULT（默认，效果同EXACT，即精确匹配））</p></li><li><p>EXACT（相等）</p></li><li><p>STARTING（开始匹配）</p></li><li><p>ENDING（结束匹配）</p></li><li><p>CONTAINING（包含，模糊匹配）</p></li><li><p>REGEX（正则表达式）</p><p>该配置对所有字符串属性过滤有效，除非该属性在<code>propertySpecifiers</code> 中单独定义自己的匹配方式。</p></li></ul><p>（3）<code>defaultIgnoreCase</code>：默认大小写忽略方式，布尔型，当值为<code>false</code>时，即不忽略，大小不相等。该配置对所有字符串属性过滤有效，除非该属性在 <code>propertySpecifiers</code> 中单独定义自己的忽略大小写方式。</p><p>（4）<code>propertySpecifiers</code>：各属性特定查询方式，描述了各个属性单独定义的查询方式，每个查询方式中包含4个元素：属性名、字符串匹配方式、大小写忽略方式、属性转换器。如果属性未单独定义查询方式，或单独查询方式中，某个元素未定义（如：字符串匹配方式），则采用 <code>ExampleMatcher</code>中定义的默认值，即上面介绍的<code>defaultStringMatcher</code>和 <code>defaultIgnoreCase</code> 的值。</p><p>（5）<code>ignoredPaths</code>：忽略属性列表，忽略的属性不参与查询过滤。</p><h4 id="常用情况说明："><a href="#常用情况说明：" class="headerlink" title="常用情况说明："></a>常用情况说明：</h4><p>1、关于基本数据类型。<br>实体对象中，避免使用基本数据类型，采用包装器类型。如果已经采用了基本类型，<br>而这个属性查询时不需要进行过滤，则把它添加到忽略列表（<code>ignoredPaths</code>）中。</p><p>2、Null值处理方式。<br>默认值是 IGNORE（忽略），即当条件值为null时，则忽略此过滤条件，一般业务也是采用这种方式就可满足。当需要查询数据库表中属性为null的记录时，可将值设为INCLUDE，这时，对于不需要参与查询的属性，都必须添加到忽略列表（<code>ignoredPaths</code>）中，否则会出现查不到数据的情况。</p><p>3、默认配置、特殊配置。<br>默认创建匹配器时，字符串采用的是精确匹配、不忽略大小写，可以通过操作方法改变这种默认匹配，以满足大多数查询条件的需要，如将“字符串匹配方式”改为CONTAINING（包含，模糊匹配），这是比较常用的情况。对于个别属性需要特定的查询方式，可以通过配置“属性特定查询方式”来满足要求。</p><p>4、非字符串属性<br>如约束中所谈，非字符串属性均采用精确匹配，即等于。</p><p>5、忽略大小写的问题。<br>忽略大小的生效与否，是依赖于数据库的。例如 MySql 数据库中，默认创建表结构时，字段是已经忽略大小写的，所以这个配置与否，都是忽略的。如果业务需要严格区分大小写，可以改变数据库表结构属性来实现，具体可百度。</p><h4 id="常用查询示例："><a href="#常用查询示例：" class="headerlink" title="常用查询示例："></a>常用查询示例：</h4><p>1、无匹配器的情况</p><p>要求：查询地址是“河南省郑州市”，且重点关注的客户。<br>说明：对于默认匹配器满足条件时，则不需要创建匹配器。</p><pre><code> //创建查询条件数据对象        Customer customer = new Customer();        customer.setAddress("河南省郑州市");        customer.setFocus(true);        //创建实例        Example&lt;Customer&gt; ex = Example.of(customer);         //查询        List&lt;Customer&gt; ls = dao.findAll(ex);        //输出结果        System.out.println("数量："+ls.size());        for (Customer bo:ls)        {            System.out.println(bo.getName());        }</code></pre><p>2、通用情况<br>要求：根据姓名、地址、备注进行模糊查询，忽略大小写，地址要求开始匹配。<br>说明：这是通用情况，主要演示改变默认字符串匹配方式、改变默认大小写忽略方式、属性特定查询方式配置、忽略属性列表配置。</p><pre><code>//创建查询条件数据对象        Customer customer = new Customer();        customer.setName("zhang");        customer.setAddress("河南省");        customer.setRemark("BB");        //创建匹配器，即如何使用查询条件        ExampleMatcher matcher = ExampleMatcher.matching() //构建对象                .withStringMatcher(StringMatcher.CONTAINING) //改变默认字符串匹配方式：模糊查询                .withIgnoreCase(true) //改变默认大小写忽略方式：忽略大小写                .withMatcher("address", GenericPropertyMatchers.startsWith()) //地址采用“开始匹配”的方式查询                .withIgnorePaths("focus");  //忽略属性：是否关注。因为是基本类型，需要忽略掉        //创建实例        Example&lt;Customer&gt; ex = Example.of(customer, matcher);         //查询        List&lt;Customer&gt; ls = dao.findAll(ex);        //输出结果        System.out.println("数量："+ls.size());        for (Customer bo:ls)        {            System.out.println(bo.getName());        }</code></pre><p>3、多级查询<br>要求：查询所有潜在客户<br>说明：主要演示多层级属性查询</p><pre><code>//创建查询条件数据对象        Customer customer = new Customer();        //创建匹配器，即如何使用查询条件        ExampleMatcher matcher = ExampleMatcher.matching() //构建对象                .withIncludeNullValues() //改变“Null值处理方式”：包括                .withIgnorePaths("id","name","sex","age","focus","addTime","remark","customerType"); //忽略其他属性         //创建实例        Example&lt;Customer&gt; ex = Example.of(customer, matcher);         //查询        List&lt;Customer&gt; ls = dao.findAll(ex);        //输出结果        System.out.println("数量："+ls.size());        for (Customer bo:ls)        {            System.out.println(bo.getName());        }</code></pre><h3 id="2-JpaSpecificationExecutor"><a href="#2-JpaSpecificationExecutor" class="headerlink" title="2.JpaSpecificationExecutor"></a>2.JpaSpecificationExecutor</h3><p><code>JpaSpecificationExecutor</code>是JPA2.0提供的Criteria API，可以动态生成query。</p><p>源码如下：</p><pre><code>public interface JpaSpecificationExecutor&lt;T&gt; {    //根据Specification条件查询单个对象    Optional&lt;T&gt; findOne(@Nullable Specification&lt;T&gt; var1);    List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1);    Page&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1, Pageable var2);    List&lt;T&gt; findAll(@Nullable Specification&lt;T&gt; var1, Sort var2);    long count(@Nullable Specification&lt;T&gt; var1);}</code></pre><p>这个接口基本围绕<code>Specification</code>接口定义，<code>Specification</code>接口中的一个方法：</p><pre><code>Predicate toPredicate(Root&lt;T&gt; var1, CriteriaQuery&lt;?&gt; var2, CriteriaBuilder var3);</code></pre><p>JpaSpecificationExecutor<code>是针对Criteria API进行了</code>predicate<code>标准封装，帮我们封装了通过</code>EntityManager`的查询和使用细节，操作Criteria 更加便利。</p><h4 id="Criteria-的介绍："><a href="#Criteria-的介绍：" class="headerlink" title="Criteria 的介绍："></a>Criteria 的介绍：</h4><p><code>Root&lt;T&gt; root</code> :代表了可以查询和操作的实体对象的根。如果将实体对象比喻成表名，那root里面就是这张表里面的字段，只不过是JPQL的实体字段。通过里面的Path<y>get(String attributeName)来获取我们操作的字段。</y></p><p><code>CriteriaQuery&lt;?&gt;query</code>：代表一个specific的顶层查询对象，它包含查询的各个部分，比如：select、from、where、group by、order by等。<code>CriteriaQuery</code>对象只对实体类型或嵌入式类型的Criteria查询起作用，它提供了查询ROOT的方法，常用方法有：</p><pre><code>    CriteriaQuery&lt;T&gt; select(Selection&lt;? extends T&gt; var1);    CriteriaQuery&lt;T&gt; where(Predicate... var1);    CriteriaQuery&lt;T&gt; having(Predicate... var1);</code></pre><h4 id="JpaSpecificationExecutor示例"><a href="#JpaSpecificationExecutor示例" class="headerlink" title="JpaSpecificationExecutor示例"></a>JpaSpecificationExecutor示例</h4><pre><code>public interface UserRepository extends JpaRepository&lt;User,Long&gt;, JpaSpecificationExecutor&lt;User&gt;</code></pre><p>实体类<code>UserRepository</code>必须继承<code>JpaRepository</code>或者<code>Repository</code>，同时继承<code>JpaSpecificationExecutor</code>才可以产生作用，因为<code>JpaSpecificationExecutor</code>并没有继承<code>Repository</code>。</p><p>下面给出一个动态查询的例子（通过email模糊查询，name精确查询，没有提供的话就忽略）</p><pre><code>// 这里给出两种方法public List&lt;User&gt; findByCondition(User user){    return userRepository.findAll(((root, criteriaQuery, criteriaBuilder) -&gt; {        List&lt;Predicate&gt; predicates = new ArrayList&lt;&gt;();        if (!StringUtils.isEmpty(user.getEmail())){            predicates.add(criteriaBuilder.like(root.get("email"),"%"+user.getEmail()+"%"));        }        if (!StringUtils.isEmpty(user.getName())){            predicates.add(criteriaBuilder.equal(root.get("name"),user.getName()));        }        return criteriaQuery.where(predicates.toArray(new Predicate[0])).getGroupRestriction();    }));}public List&lt;User&gt; findByCondition2(User user){    return userRepository.findAll((Specification&lt;User&gt;) (root, criteriaQuery, criteriaBuilder) -&gt; {        Predicate predicate=criteriaBuilder.conjunction();        if (!StringUtils.isEmpty(user.getEmail())){       predicate.getExpressions().add(criteriaBuilder.like(root.get("email"),"%"+user.getEmail()+"%"));        }        if (!StringUtils.isEmpty(user.getName())){            predicate.getExpressions().add(criteriaBuilder.equal(root.get("name"),user.getName()));        }        return predicate;    });}</code></pre><p>如果要用到动态查询，推荐使用上述写法；如果平时只需要用到一些基本的条件查询，那么也可以使用下面这种工厂方式，提供一些常用的功能。</p><pre><code>public class SpecificationFactory {    //模糊查询    public static Specification containsLike(String attribute,String value){        return (root, criteriaQuery, criteriaBuilder) -&gt;            criteriaBuilder.like(root.get(attribute),"%"+value+"%");    }     //相等查询    public static Specification equal(String attribute,Object value){        return (root, criteriaQuery, criteriaBuilder) -&gt;                 criteriaBuilder.equal(root.get(attribute),value);    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Spring Framwork </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java设计模式与案例</title>
      <link href="/2019/08/10/java-she-ji-mo-shi-yu-an-li/"/>
      <url>/2019/08/10/java-she-ji-mo-shi-yu-an-li/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式概述"><a href="#设计模式概述" class="headerlink" title="设计模式概述"></a>设计模式概述</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>设计模式可以分为三大类：创建型模式、行为型模式、结构型模式</p><ul><li><p>创建型模式：提供一种在创建对象的同时，隐藏创建逻辑的方式，而不是直接实例化对象。</p><p>  常用创建型模式：单例模式、简单工厂模式、工厂模式、抽象工厂模式、生成器模式、原型模式</p></li><li><p>行为型模式：关注对象之间的通信。</p><p>  常用行为型模式：责任链模式、命令模式、迭代器模式、访问者模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、解释器模式</p></li><li><p>结构型模式：关注类和对象的组合，继承的概念被用来组合接口和定义组合对象获得新功能的方式。</p><p>  常用结构型模式：享元模式、适配器模式、组合模式、代理模式、桥接模式、装饰器模式、外观模式</p></li></ul><h3 id="接口和抽象类"><a href="#接口和抽象类" class="headerlink" title="接口和抽象类"></a>接口和抽象类</h3><p>“顺序”问题用接口描述，”顺序+共享”问题用抽象类描述。</p><p>举个例子，生产一辆汽车需要由钢板切割、压模、组装、喷漆四道工序组成，这些工序之前是顺序的关系，所以可以用接口来描述。组装多台电脑，我们可能需要不同的显卡，硬盘，但是CPU我们都想要同一型号的，那么CPU就是”共享的”，因此我们可以用抽象类来描述，这样就不需要每次都去实现一遍CPU，如果用接口描述，就需要重复实现。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>反射是在程序运行时获取已知名称的类或已有对象相关信息的一种机制，包括类的方法、属性、父类等信息，还包括实例的创建和类型的判断。</p><p>下面举两个关于反射的例子</p><p><strong>1.通过反射获取任意类的任意方法</strong></p><pre><code>public class ReflectDemo {    public void add(String a, Integer b){        System.out.println(a+b);    }    static boolean process(String className, String funcName, Object[] para) throws Exception {        Class classType = Class.forName(className);        Class c[] = new Class[para.length];        for (int i = 0; i &lt; para.length; i++) {            c[i] = para[i].getClass();        }        Constructor constructor = classType.getConstructor();        Object obj = constructor.newInstance();        Method method = classType.getMethod(funcName, c);        method.invoke(obj, para);        return true;    }    public static void main(String[] args) throws Exception {        boolean process = process("reflection.ReflectDemo", "add", new Object[]{"a", 1});    }}</code></pre><pre><code>输出：a1，也就是执行了add方法</code></pre><p><strong>2.已知接收字符串有两种方式，屏幕输出或保存至文件，要求从命令行输入字符串处理类的类名字符串，输入”ConsoleMsg”就把字符串输出到控制台，输入”FileMsg”就把字符串输出到文件</strong></p><p>定义字符串公共处理接口<code>IMsg</code>，两个子类<code>ConsoleMsg</code>、<code>FileMsg</code></p><pre><code>public interface IMsg {    void process(String s);}</code></pre><pre><code>public class ConsoleMsg implements IMsg {    @Override    public void process(String msg) {        System.out.println(msg);    }}</code></pre><pre><code>public class FileMsg implements IMsg {    @Override    public void process(String msg) {        System.out.println("Sava msg to File");    }}</code></pre><pre><code>public static void main(String[] args) throws Exception {    IMsg obj = null;    obj = (IMsg) Class.forName(args[0]).newInstance();    obj.process("hello");}</code></pre><p><code>Class.forName(args[0]).newInstance();</code>表明产生的类名是<code>args[0]</code>的一个实例，可能是<code>ConsoleMsg</code>，也可能是<code>FileMsg</code>，还可能是其他字符串处理类的一个实例。也就是说，这是动态的，不随哪个具体的<code>IMsg</code>接口的子类改变而改变，它是稳定的。如果现在要增加一个将字符串保存到数据库的类，只需要增加功能子类<code>DbMsg</code>，而测试类代码无需改变。</p><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><strong>代码示例</strong></p><pre><code>// 定义小汽车接口public interface ICar {}</code></pre><pre><code>// 高档小汽车public class UpCar implements ICar {}</code></pre><pre><code>// 中档小汽车public class MidCar implements ICar {}</code></pre><pre><code>// 低档小汽车public class DnCar implements ICar {}</code></pre><pre><code>public class CarSimpleFactory {    public static final String UPTYPE = "uptype";    public static final String MIDTYPE = "midtype";    public static final String DNTYPE = "dntype";    public static ICar create(String mark) {        ICar obj = null;        if (mark.equals(UPTYPE)) {            obj = new UpCar();        } else if (mark.equals(MIDTYPE)) {            obj = new MidCar();        } else if (mark.equals(DNTYPE)) {            obj = new DnCar();        }        return obj;    }}</code></pre><pre><code>public static void main(String[] args) {    ICar obj = CarSimpleFactory.create("uptype");    System.out.println(obj);}</code></pre><p><strong>代码分析</strong></p><p>简单工厂创建步骤：</p><ul><li>定制抽象产品接口，如<code>ICar</code></li><li>定制具体产品子类，如<code>UpCar</code>、<code>MidCar</code>、<code>DnCar</code></li><li>定制工厂类，如<code>CarSimpleFactory</code></li></ul><p>简单工厂类的特点是：它是一个具体的类，非接口或抽象类，有一个<code>create()</code>方法利用<code>if else</code>或<code>switch</code>创建所需产品。由于简单工厂不需要创建实例，所以可以把它实现成一个工具类，直接使用静态方法，因此简单工厂也叫静态工厂。</p><h3 id="工厂模式-1"><a href="#工厂模式-1" class="headerlink" title="工厂模式"></a>工厂模式</h3><p><strong>代码示例</strong></p><pre><code>//定义小汽车接口：ICar.javainterface ICar {    //由于工厂模式仅关系对象的创建，为说明方便，勿需定义方法}//定义高中低档具体的小汽车//高档小汽车：UpCar.javaclass UpCar implements ICar {}//中档小汽车：MidCar.javaclass MidCar implements ICar {}//低档小汽车：DnCar.javaclass DnCar implements ICar {}//定义抽象工厂：AbstractFactory.javaabstract class AbstractFactory {    public abstract ICar create();  }//定义高档小汽车工厂：UpFactory.javaclass UpFactory extends AbstractFactory {    public ICar create() {        return new UpCar(); //高档工厂生成高档小汽车对象    }}//定义中档小汽车工厂：UpFactory.java class MidFactory extends AbstractFactory {    public ICar create() {        return new MidCar();//中档工厂生成中档小汽车对象    }}//定义低档小汽车工厂：DnFactory.javaclass DnFactory extends AbstractFactory {    public ICar create() {        return new DnCar();//低档工厂生成低档小汽车对象    }}//测试类：CarTest.java    public class CarTest {    public static void main(String []args){        AbstractFactory obj = new UpFactory();//多态创建高档工厂        ICar car = obj.create(); //获得高档工厂中的小汽车对象    }}</code></pre><p><strong>代码分析</strong></p><p>工厂模式创建步骤：</p><ul><li>定制抽象产品接口，如<code>ICar</code></li><li>定制具体产品子类，如类<code>UpCar</code>、<code>MidCar</code>、<code>DnCar</code></li><li>定制抽象工厂类（或接口），如<code>AbstractFactory</code>。其中有一个重要的<code>create()</code>抽象方法</li><li>定制具体工厂子类，如<code>UpFactory</code>、<code>MidFactory</code>、<code>DnFactory</code></li></ul><p>工厂与简单工厂模式的区别：</p><p>工厂模式把简单工厂中具体的工厂类（如<code>CarSimpleFactory</code>）划分成两层：抽象工厂层（如<code>AbstractFactory</code>）+具体工厂子类层(如<code>UpFactory</code>等)。</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p>一般来说，简单工厂、工厂模式是单产品系的，抽象工厂是多产品系的，从本质上来说抽象工厂、工厂模式是统一的。</p><p><strong>代码示例</strong></p><pre><code>interface ICar {  }class UpCar implements ICar {  }class MidCar implements ICar {  }class DnCar implements ICar {  }//定义公共汽车接口、高、中、低档公共汽车类interface IBus {  }class UpBus implements IBus {  }class MidBus implements IBus {  }class DnBus implements IBus {  }//定义抽象工厂：AbstractFactory.java abstract class AbstractFactory {    public abstract ICar createCar();  //产生小汽车对象    public abstract IBus createBus();  //产生公共汽车对象}//定义高档工厂：UpFactory.javaclass UpFactory extends AbstractFactory {    public ICar createCar() {        return new UpCar(); //高档工厂生成高档小汽车对象    }    public IBus createBus() {        return new UpBus(); //高档工厂生成高档公共汽车对象    }}//定义中档工厂：MidFactory.javaclass MidFactory extends AbstractFactory {    public ICar createCar() {        return new MidCar(); //中档工厂生成中档小汽车对象    }    public IBus createBus() {        return new MidBus(); //中档工厂生成中档公共汽车对象    }}//定义低档工厂：DnFactory.javaclass DnFactory extends AbstractFactory {    public ICar createCar() {        return new DnCar(); //中档工厂生成中档小汽车对象    }    public IBus createBus() {        return new DnBus(); //中档工厂生成中档公共汽车对象    }}public class CarTest {    public static void main(String []args){        AbstractFactory fact = new UpFactory();        IBus bus = fact.createBus();    }}</code></pre><p>和工厂模式相比，这里多了公共汽车产品，也就是多产品。</p><p><strong>代码分析</strong></p><p>抽象工厂创建步骤：</p><ul><li>定制抽象产品接口，如<code>ICar</code>，<code>IBus</code></li><li>定制具体产品子类，如小汽车类<code>UpCar</code>、<code>MidCar</code>、<code>DnCar</code>，公共汽车类<code>UpBus</code>、<code>MidBus</code>、<code>DnBus</code></li><li>定制抽象工厂类（或接口），如<code>AbstractFactory</code>。其中有两个重要的<code>create()</code>抽象方法，分别返回<code>ICar</code>、<code>IBus</code>对象</li><li>定制具体工厂子类，如<code>UpFactory</code>、<code>MidFactory</code>、<code>DnFactory</code>，每个工厂类中重写<code>create()</code>方法</li></ul><h3 id="应用举例"><a href="#应用举例" class="headerlink" title="应用举例"></a>应用举例</h3><p>编写读文件功能。具体功能是：读取文本文件，包括（GBK,UTF8,UNICODE）编码下的文本文件，要求获得全文内容；读取图像文件（BMP,GIF,JPG)，要求获得图像宽度、长度、每一点的RGB三基色信息。</p><p>画出层次结构图：</p><pre class="line-numbers language-mermaid"><code class="language-mermaid">graph TDA[读文件] -->B(文本文件)A[读文件] -->C(图像文件)B-->D(GBK)B-->E(UTF8)B-->F(UNICODE)C-->G(BMP)C-->H(GIF)C-->I(JPG)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>利用工厂模式可以直接翻译上面的示意图，但是没有用到jdk本身的类库，下面的代码是真正能使用的。</p><pre><code>import java.io.*;import javax.imageio.*;import java.awt.image.*;interface IRead&lt;T&gt;{    T read(String ... in);}class TextRead implements IRead&lt;String&gt; {     //读文本文件    public String read(String... in) {        String result = null;                  //result是结果串        try{            File file = new File(in[0]);         //in[0]表示文件名称            long len = file.length();            FileInputStream input = new FileInputStream(in[0]);            byte buf[] = new byte[(int)len];    //缓冲区大小等于文件长度            input.read(buf);                //一次读完文件            result = new String(buf, in[1]);    //按in[1]编码方式转化成可见字符串            input.close();        }        catch(Exception e){            System.out.println(e.getMessage());        }                return result;    }}//图像基本信息文件class ImageInfo {    private int width;    //图像宽度    private int height;    //图像高度    private int r[][];        //红色分量    private int g[][];        //绿色分量    private int b[][];        //蓝色分量    public void setWidth(int width){        this.width = width;    }    public int getWidth() {        return width;    }    public void setHeight(int height){        this.height = height;    }    public int getHeight() {        return height;    }    public int[][] getR() {        return r;    }    public int[][] getG() {        return g;    }    public int[][] getB() {        return b;    }    public void setRGB(int rgb[]){        r = new int[height][width];        g = new int[height][width];        b = new int[height][width];        int pos = 0;        for(int i=0; i&lt;height; i++){            pos = width*i;            for(int j=0; j&lt;width; j++){                r[i][j] =(rgb[pos+j]&amp;0xff0000)&gt;&gt;16;                g[i][j] =(rgb[pos+j]&amp;0x00ff00)&gt;&gt;8;                b[i][j] =rgb[pos+j]&amp;0x0000ff;                        }        }            }    }//读图像文件class ImageRead implements IRead&lt;ImageInfo&gt; {     //读图像文件    public ImageInfo read(String... in) {        ImageInfo obj = null;        try{        File f = new File(in[0]);                //in[0]表示图像文件名        BufferedImage bi = ImageIO.read(f);        int width = bi.getWidth();        int height = bi.getHeight();        int rgb[] = new int[width*height];                bi.getRGB(0,0,width,height, rgb, width, height);    //将图像数据读到result缓冲区        obj = new ImageInfo();        //设置图像信息        obj.setWidth(width);                //设置宽度        obj.setHeight(height);                //设置高度        obj.setRGB(rgb);                    //设置rgb[]三基色信息        }        catch(Exception e){e.printStackTrace();}        return obj;    }}abstract class AbstractFactory {    public abstract IRead create();}class TextFactory extends AbstractFactory {    public IRead create() {        return new TextRead();    //文件工厂产生具体读文件类    }}class ImageFactory extends AbstractFactory {    public IRead create() {        return new ImageRead();    //图像工厂产生具体读图像类    }}public class Test {    public static void main(String[] args) {        // TODO Auto-generated method stub        ImageFactory fact = new ImageFactory();        IRead obj = fact.create();        ImageInfo inf = (ImageInfo)obj.read("d:/a.jpg");        System.out.println("width="+inf.getWidth());        System.out.println("height="+inf.getHeight());    }}</code></pre><h2 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h2><p>建造者模式的意图在于将一个复杂的构建与其表示分离，使得同样的构建过程可以创建不同的表示。</p><p><strong>代码示例</strong></p><pre><code>// 定义产品类public class Course {    private String courseName;    private String coursePPT;    private String courseVideo;    private String courseArticle;    private String courseQA;    public String getCourseName() {        return courseName;    }    public void setCourseName(String courseName) {        this.courseName = courseName;    }    public String getCoursePPT() {        return coursePPT;    }    public void setCoursePPT(String coursePPT) {        this.coursePPT = coursePPT;    }    public String getCourseVideo() {        return courseVideo;    }    public void setCourseVideo(String courseVideo) {        this.courseVideo = courseVideo;    }    public String getCourseArticle() {        return courseArticle;    }    public void setCourseArticle(String courseArticle) {        this.courseArticle = courseArticle;    }    public String getCourseQA() {        return courseQA;    }    public void setCourseQA(String courseQA) {        this.courseQA = courseQA;    }    @Override    public String toString() {        return "Course{" +                "courseName='" + courseName + '\'' +                ", coursePPT='" + coursePPT + '\'' +                ", courseVideo='" + courseVideo + '\'' +                ", courseArticle='" + courseArticle + '\'' +                ", courseQA='" + courseQA + '\'' +                '}';    }}</code></pre><pre><code>// 定义抽象产品建造者类(接口)public abstract class CourseBuilder {    public abstract void buildCourseName(String courseName);    public abstract void buildCoursePPT(String coursePPT);    public abstract void buildCourseVideo(String courseVideo);    public abstract void buildCourseArticle(String courseArticle);    public abstract void buildCourseQA(String courseQA);    public abstract Course makeCourse();}</code></pre><pre><code>// 定义具体产品建造者类public class CourseActualBuilder extends CourseBuilder {    private Course course = new Course();    @Override    public void buildCourseName(String courseName) {        course.setCourseName(courseName);    }    @Override    public void buildCoursePPT(String coursePPT) {        course.setCoursePPT(coursePPT);    }    @Override    public void buildCourseVideo(String courseVideo) {        course.setCourseVideo(courseVideo);    }    @Override    public void buildCourseArticle(String courseArticle) {        course.setCourseArticle(courseArticle);    }    @Override    public void buildCourseQA(String courseQA) {        course.setCourseQA(courseQA);    }    @Override    public Course makeCourse() {        return course;    }}</code></pre><pre><code>// 定义指挥者类public class Director {    private CourseBuilder courseBuilder;    /**     * 这里的CourseBuilder通过set的方式给注入进来     */    public void setCourseBuilder(CourseBuilder courseBuilder) {        this.courseBuilder = courseBuilder;    }    public Course makeCourse(String courseName, String coursePPT,                             String courseVideo, String courseArticle, String courseQA) {        this.courseBuilder.buildCourseName(courseName);        this.courseBuilder.buildCoursePPT(coursePPT);        this.courseBuilder.buildCourseVideo(courseVideo);        this.courseBuilder.buildCourseArticle(courseArticle);        this.courseBuilder.buildCourseQA(courseQA);        return this.courseBuilder.makeCourse();    }}</code></pre><pre><code>public static void main(String[] args) {    /* 利用多态，父类的引用指向子类的对象 */    CourseBuilder courseBuilder = new CourseActualBuilder();    Director director = new Director();    /* 这里利用set方法注入进去 */    director.setCourseBuilder(courseBuilder);    Course course = director.makeCourse("Java设计模式", "Java设计模式PPT", "Java设计模式视频", "Java设计模式手记", "Java设计模式问答");    System.out.println(course);}</code></pre><pre><code>输出：Course{courseName='Java设计模式', coursePPT='Java设计模式PPT', courseVideo='Java设计模式视频', courseArticle='Java设计模式手记', courseQA='Java设计模式问答'}</code></pre><p>由于<code>Course course = director.makeCourse("Java设计模式", "Java设计模式PPT", "Java设计模式视频", "Java设计模式手记", "Java设计模式问答");</code>制作课程时使用不灵活。</p><p>下面提供一种链式调用的静态内部类方法，该方法的优点在于可以只创建需要的值，使用起来更加优雅。</p><pre><code>public class Course {    private String courseName;    private String coursePPT;    private String courseVideo;    private String courseArticle;    private String courseQA;    public Course(CourseBuilder courseBuilder) {        this.courseName = courseBuilder.courseName;        this.coursePPT = courseBuilder.coursePPT;        this.courseVideo = courseBuilder.courseVideo;        this.courseArticle = courseBuilder.courseArticle;        this.courseQA = courseBuilder.courseQA;    }    public static class CourseBuilder{        private String courseName;        private String coursePPT;        private String courseVideo;        private String courseArticle;        private String courseQA;        public CourseBuilder builderCourseName(String courseName) {            this.courseName = courseName;                 //this指的是当前类，也就是CourseBuilder            //这里返回this的原因是为了能够让返回值能够继续调用本类其他方法，也就是链式调用            return this;        }        public CourseBuilder builderCoursePPT(String coursePPT) {            this.coursePPT = coursePPT;            return this;        }        public CourseBuilder builderCourseVideo(String courseVideo) {            this.courseVideo = courseVideo;            return this;        }        public CourseBuilder builderCourseArticle(String courseArticle) {            this.courseArticle = courseArticle;            return this;        }        public CourseBuilder builderCourseQA(String courseQA) {            this.courseQA = courseQA;            return this;        }        public Course build() {            return new Course(this);        }    }    @Override    public String toString() {        return "Course{" +                "courseName='" + courseName + '\'' +                ", coursePPT='" + coursePPT + '\'' +                ", courseVideo='" + courseVideo + '\'' +                ", courseArticle='" + courseArticle + '\'' +                ", courseQA='" + courseQA + '\'' +                '}';    }}</code></pre><pre><code>public static void main(String[] args){    Course course = new Course.CourseBuilder()            .builderCourseName("Java设计模式")            .builderCoursePPT("Java设计模式PPT")            .builderCourseVideo("Java设计模式视频")            .builderCourseArticle("Java设计模式手记")            .builderCourseQA("Java设计模式问答").build();    System.out.println(course);}</code></pre><p>这种方式可以在<code>lombok</code>插件的<code>@Builder</code>注解中见到。</p><h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式是指用原型实例指定创建对象的种类，并且通过复制这些原型创建新的对象。</p><p>适合场景：</p><ul><li><p>程序需要从一个对象出发，得到若干个和其状态相同，并可独立变化其状态的对象时</p></li><li><p>对象创建需要独立于它的构造方法和表示时</p></li><li><p>以原型对象为基础，克隆新的对象，并完善对象实例变量时</p></li></ul><p>原型模式复制分为浅复制和深复制：</p><ul><li><p>浅复制</p><p>  如果原型对象的成员变量是值类型，则将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说，原型对象和克隆对象的成员变量指向相同的内存地址。在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型，而引用类型的成员对象并没有复制。</p></li><li><p>深复制</p><p>  在深复制中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象。</p></li></ul><h3 id="利用构造函数方法"><a href="#利用构造函数方法" class="headerlink" title="利用构造函数方法"></a>利用构造函数方法</h3><p><strong>代码示例</strong></p><p><strong>浅复制</strong></p><pre><code>public class Student {    String name;    int age;    Address add;    Student(String na, int a, Address add) {        this.name = na;        age = a;        this.add = add;    }      // 构造函数 浅复制    Student(Student s) {        name = s.getName();        age = s.getAge();          add = s.getAdd();    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Address getAdd() {        return add;    }    public void setAdd(Address add) {        this.add = add;    }}</code></pre><pre><code>public class Address {    String pro;    String city;    String zip;    public Address(String p, String c, String z) {        pro = p;        city = c;        zip = z;    }    public Address(Address add) {        pro = add.getPro();        city = add.getCity();        zip = add.getZip();    }    public String getPro() {        return pro;    }    public void setPro(String pro) {        this.pro = pro;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public String getZip() {        return zip;    }    public void setZip(String zip) {        this.zip = zip;    }}</code></pre><pre><code>public static void main(String[] args) throws Exception {    Address adr = new Address("liaoning", "dalian", "116081");    Student s = new Student("zhang", 20, adr);    Student s2 = new Student(s);    System.out.println("s=" + s + "\ts2=" + s2);    System.out.println("s.name=" + s.getName() + "\ts2.name=" + s2.getName());    System.out.println("s.age=" + s.getAge() + "\ts2.age=" + s2.getAge());    System.out.println("s.adr=" + s.getAdd() + "\ts2.adr=" + s2.getAdd());}</code></pre><pre><code>输出：s=prototype.Student@61bbe9ba    s2=prototype.Student@610455d6s.name=zhang    s2.name=zhangs.age=20    s2.age=20s.adr=prototype.Address@511d50c0    s2.adr=prototype.Address@511d50c0</code></pre><p>由最后一行addr的地址可知，对象进行了浅复制。</p><p><strong>深复制</strong></p><p>将<code>Student</code>类中的构造方法改为如下</p><pre><code>Student(Student s) {    name = s.getName();    age = s.getAge();    add = s.getAdd();    // 深复制    add = new Address(s.getAdd());}</code></pre><pre><code>输出：s=prototype.Student@61bbe9ba    s2=prototype.Student@610455d6s.name=zhang    s2.name=zhangs.age=20    s2.age=20s.adr=prototype.Address@511d50c0    s2.adr=prototype.Address@60e53b93</code></pre><p>由最后一行addr可知，对象进行了深复制。</p><h3 id="利用Cloneable接口方法"><a href="#利用Cloneable接口方法" class="headerlink" title="利用Cloneable接口方法"></a>利用Cloneable接口方法</h3><p><code>Object</code>类提供一个<code>clone()</code>方法可以将一个对象复制，但是<code>clone()</code>是一个<code>protected</code>方法，外部类无法直接调用。不过Java规定只要类实现<code>Cloneable</code>接口，就表示这个类能被复制。</p><p><strong>代码示例</strong></p><p><strong>浅复制</strong></p><pre><code>public class Student implements Cloneable {    String name;    int age;    Address add;    Student(String na, int a, Address add) {        this.name = na;        age = a;        this.add = add;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Address getAdd() {        return add;    }    public void setAdd(Address add) {        this.add = add;    }    @Override    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><pre><code>public static void main(String[] args)throws Exception {    Address adr = new Address("liaoning","dalian","116081");    Student s = new Student("zhang",20,adr);    Student s2 = (Student)s.clone();          System.out.println("s="+s+"\ts2="+s2);    System.out.println("s.name="+s.getName()+"\ts2.name="+s2.getName());    System.out.println("s.age="+s.getAge()+"\ts2.age="+s2.getAge());    System.out.println("s.adr="+s.getAdd()+"\ts2.adr="+s2.getAdd());}</code></pre><pre><code>输出：s=prototype.clone.Student@61bbe9ba    s2=prototype.clone.Student@610455d6s.name=zhang    s2.name=zhangs.age=20    s2.age=20s.adr=prototype.clone.Address@511d50c0    s2.adr=prototype.clone.Address@511d50c0</code></pre><p><strong>深复制</strong></p><pre><code>public class Address implements Cloneable {    String pro;    String city;    String zip;    public Address(String p, String c, String z) {        pro = p;        city = c;        zip = z;    }    public String getPro() {        return pro;    }    public void setPro(String pro) {        this.pro = pro;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    public String getZip() {        return zip;    }    public void setZip(String zip) {        this.zip = zip;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Address s = (Address) super.clone();        return s;    }}</code></pre><pre><code>public class Student implements Cloneable {    String name;    int age;    Address add;    Student(String na, int a, Address add) {        this.name = na;        age = a;        this.add = add;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Address getAdd() {        return add;    }    public void setAdd(Address add) {        this.add = add;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Student s = (Student) super.clone();        s.setAdd((Address) add.clone());        return s;    }}</code></pre><pre><code>输出：s=prototype.clone.Student@61bbe9ba    s2=prototype.clone.Student@610455d6s.name=zhang    s2.name=zhangs.age=20    s2.age=20s.adr=prototype.clone.Address@511d50c0    s2.adr=prototype.clone.Address@60e53b93</code></pre><p>由上可知，实现对象深复制，必须对类引用变量级联串中每一环节都进行处理。</p><p><strong>深复制引用变量级联处理示例</strong></p><pre><code>class A implements Cloneable{    B b;    B getB(){return b;}    void setB(B b){this.b = b;}    protected Object clone() throws CloneNotSupportedException {        A a=(A)super.clone();        a.setB((B)b.clone());        return a;    }}class B implements Cloneable{    C c;    C getC(){return c;}    void setC(C c){this.c = c;}    protected Object clone() throws CloneNotSupportedException {        B b=(B)super.clone();        b.setC((C)c.clone());        return b;    }}class C implements Cloneable{    D d;    D getD(){return d;}    void setD(D d){this.d = d;}    protected Object clone() throws CloneNotSupportedException {        C c=(C)super.clone();        c.setD((D)d.clone());        return c;    }}class D implements Cloneable{    protected Object clone() throws CloneNotSupportedException {        return super.clone();    }}</code></pre><h3 id="利用Serializable序列化接口方法"><a href="#利用Serializable序列化接口方法" class="headerlink" title="利用Serializable序列化接口方法"></a>利用<code>Serializable</code>序列化接口方法</h3><p>利用构造函数方法、<code>Cloneable</code>接口方法实现对象深复制都稍显复杂，但使用<code>Serializable</code>序列化接口方法实现要简单很多。<code>Serializable</code>同样是一个空接口，表示该对象支持序列化。</p><p><strong>代码示例</strong></p><pre><code>public class Student implements Cloneable, Serializable {    String name;    int age;    Address add;    Student(String na, int a, Address add) {        this.name = na;        age = a;        this.add = add;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public int getAge() {        return age;    }    public void setAge(int age) {        this.age = age;    }    public Address getAdd() {        return add;    }    public void setAdd(Address add) {        this.add = add;    }    @Override    protected Object clone() throws CloneNotSupportedException {        Object obj = null;        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(this);            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bis);            obj = ois.readObject();        } catch (Exception e) {            e.printStackTrace();        }        return obj;    }}</code></pre><pre><code>public class Address implements Serializable {    String pro;    String city;    String zip;    public Address(String p,String c, String z){        pro=p;city=c;zip=z;    }}</code></pre><pre><code>public static void main(String[] args) throws Exception {        Address adr = new Address("liaoning", "dalian", "116081");        Student s = new Student("zhang", 20, adr);        Student s2 = (Student) s.clone();        System.out.println("s=" + s + "\ts2=" + s2);        System.out.println("s.name=" + s.getName() + "\ts2.name=" + s2.getName());        System.out.println("s.age=" + s.getAge() + "\ts2.age=" + s2.getAge());        System.out.println("s.adr=" + s.getAdd() + "\ts2.adr=" + s2.getAdd());    }</code></pre><pre><code>输出：s=prototype.serializable.Student@6f94fa3e    s2=prototype.serializable.Student@5b6f7412s.name=zhang    s2.name=zhangs.age=20    s2.age=20s.adr=prototype.serializable.Address@5e481248    s2.adr=prototype.serializable.Address@27973e9b</code></pre><p>从代码中可以看出：利用序列化实现对象复制，类引用变量级联串中的每个类都必须实现<code>Serializable</code>接口。在复制对象的源类中为了更好地表达复制功能，复制对象的源类一般也实现<code>Cloneable</code>接口，因此<code>Student</code>、<code>Address</code>类都实现了<code>Serializable</code>接口，而<code>Student</code>类同时还实现了<code>Cloneable</code>接口。</p><p>序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个复制，而原对象仍然存在于内存中。通过序列化实现的复制不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流中读出来，可以实现深克隆。</p><p><strong>深复制引用变量级联处理示例</strong></p><pre><code>class A implements Serializable, Cloneable {    B b;    protected Object clone() throws CloneNotSupportedException {        Object obj = null;        try {            ByteArrayOutputStream bos = new ByteArrayOutputStream();            ObjectOutputStream oos = new ObjectOutputStream(bos);            oos.writeObject(this);            ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());            ObjectInputStream ois = new ObjectInputStream(bis);            obj = ois.readObject();        } catch (Exception e) {            e.printStackTrace();        }        return obj;    }}class B implements Serializable {    C c;}class C implements Serializable {    D d;}class D implements Serializable {}</code></pre><h2 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h2><p>责任链模式的定义如下：使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。</p><p>适合场景：</p><ul><li><p>有许多对象可以处理用户的请求，应用程序可自动确定谁处理用户请求</p></li><li><p>希望在用户不必明确指定接受者的情况下，向多个接受者提交一个请求</p></li><li><p>程序希望动态定制可处理用户请求的对象集合</p></li></ul><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>下面通过一个员工请假的例子来说明责任链模式的使用方法。</p><blockquote><p>请假天数 &lt;= 1天 ，组长决定；</p></blockquote><blockquote><p>1天 &lt; 请假天数 &lt;= 2天，主任决定；</p></blockquote><blockquote><p>请假天数 &gt; 2天，经理决定。</p></blockquote><p><strong>代码示例</strong></p><pre><code>// 请求类public class Request {    int day;    Request(int day) {        this.day = day;    }}</code></pre><pre><code>// 抽象处理者类public abstract class Handler {    private Handler next;    public void setNext(Handler next) {        this.next = next;    }    public Handler getNext() {        return next;    }    public abstract boolean handle(Request req);}</code></pre><pre><code>// 具体处理者类public class ZuZhang extends Handler {    static int limit = 1;    public boolean handle(Request req) {        if (req.day &lt;= limit) {            System.out.println("ZuZhang agrees the request!");            return true;        }        return getNext().handle(req);    }}</code></pre><pre><code>public class ZhuRen extends Handler {    static int limit = 2;    public boolean handle(Request req) {        if (req.day &lt;= limit) {            System.out.println("ZhuRen agrees the request!");            return true;        }        return getNext().handle(req);    }}</code></pre><pre><code>public class JingLi extends Handler {    public boolean handle(Request req) {        System.out.println("JingLi agrees the request!");        return true;    }}</code></pre><pre><code>// 责任链public class MyChain {    private Handler one = new ZuZhang();    private Handler two = new ZhuRen();    private Handler three = new JingLi();    public void createChain() {        one.setNext(two);        two.setNext(three);    }    public void handle(Request req) {        one.handle(req);    }}</code></pre><pre><code>public static void main(String[] args) {    // 请假3天     Request req = new Request(3);    MyChain mc = new MyChain();    mc.createChain();    mc.handle(req);}</code></pre><pre><code>输出：JingLi agrees the request!</code></pre><h3 id="反射改进"><a href="#反射改进" class="headerlink" title="反射改进"></a>反射改进</h3><p>当需求发生变化时，为了不修改程序，可以使用”配置文件+反射”的方式。</p><p><strong>代码示例</strong></p><pre><code>// myconfig.txt  注意是全类名chain=chain.ZuZhang,chain.ZhuRen,chain.JingLi</code></pre><pre><code>public class MyChain2 {    private Handler handle[];    public void createChain() {        try {            FileInputStream in = new FileInputStream("src/chain/myconfig.txt");            Properties p = new Properties();              // 读配置文件            p.load(in);            String s = p.getProperty("chain");            String unit[] = s.split(",");            int n = unit.length;            handle = new Handler[n];            for (int i = 0; i &lt; n; i++) {                // 反射加载各责任链类对象                handle[i] = (Handler) Class.forName(unit[i]).newInstance();            }            for (int i = 0; i &lt; n - 1; i++) {                  // 设置责任链节后节点关系                handle[i].setNext(handle[i + 1]);            }            p.load(in);            //    in.close();        } catch (Exception e) {            e.printStackTrace();        }    }    public void handle(Request req) {        handle[0].handle(req);    }}</code></pre><pre><code>public static void main(String[] args) {    Request req = new Request(3);    MyChain2 mc = new MyChain2();    mc.createChain();    mc.handle(req);}</code></pre><pre><code>输出：JingLi agrees the request!</code></pre><h3 id="回调技术"><a href="#回调技术" class="headerlink" title="回调技术"></a>回调技术</h3><p>A对象的<code>fA()</code>方法调用了B对象的<code>fB()</code>方法，<code>fB()</code>方法调用了A对象的<code>fA2()</code>方法，这是一个回调过程。</p><p>下面对英文字符串处理：</p><blockquote><p>全部变为大写字母；</p></blockquote><blockquote><p>去掉所有空格。</p></blockquote><p><strong>代码示例</strong></p><pre><code>// 定义抽象处理者接口public interface Filter {    void doFilter(Request req, Response rep, FilterChain fc);}</code></pre><pre><code>// Request表示请求类，包含对字符串的原生封装public class Request {    String req;    Request(String req) {        this.req = req;    }}</code></pre><pre><code>// Response表示响应类，包含对处理后的结果字符串的封装public class Response {    String rep;    Response(String rep) {        this.rep = rep;    }}</code></pre><pre><code>// FilterChain表示过滤器容器类，其对象作为具体处理者必备的回调参数public class FilterChain {    ArrayList&lt;Filter&gt; ary = new ArrayList();    int index = 0;    void addFilter(Filter f) {        ary.add(f);    }    public void doFilter(Request req, Response rep, FilterChain fc) {        if (index == ary.size())            return;        Filter f = ary.get(index);        index++;        f.doFilter(req, rep, fc);    }}</code></pre><pre><code>// 具体处理者类，字符串小写变大写public class OneFilter implements Filter {    public void doFilter(Request req, Response rep, FilterChain fc) {        String s = req.req;        rep.rep = s.toUpperCase();        fc.doFilter(req, rep, fc);    }}</code></pre><pre><code>// 具体处理者类，去掉所有空格public class TwoFilter implements Filter {    public void doFilter(Request req, Response rep, FilterChain fc) {        String s = rep.rep;        StringBuffer sbuf = new StringBuffer();        for (int i = 0; i &lt; s.length(); i++) {            char ch = s.charAt(i);            if (ch != ' ') {                sbuf.append(ch);            }        }        rep.rep = sbuf.toString();        fc.doFilter(req, rep, fc);    }}</code></pre><pre><code>public static void main(String[] args) {    Request req = new Request("i am a student");    Response rep = new Response("");    Filter one = new OneFilter();    Filter two = new TwoFilter();    FilterChain fc = new FilterChain();    fc.addFilter(one);    fc.addFilter(two);    fc.doFilter(req, rep, fc);    System.out.println(rep.rep);}</code></pre><pre><code>输出：IAMASTUDENT</code></pre><p><code>ArrayList</code>类型成员变量<code>ary</code>是各具体过德器的集合对象，其添加顺序就是各具体过滤器对象的执行顺序。<code>addFilter()</code>完成了具体过滤器对象的添加。</p><p>成员变量<code>index</code> 与<code>doFilter()</code>方法一起决定当前执行焦点是哪一个具体过滤器对象。例如：当<code>index=0</code>时，则从<code>ary</code>中获得第一个过滤器对象f，同时使<code>index</code>加1，为执行下一个过滤器做准备，然后运行f中的<code>doFilter0</code>方法，当运行完后，再回调执行<code>FiterChain</code> 类中的<code>doFitr0</code>方法。此时，若<code>index</code>为1,则从<code>ary</code>中获得第二个过滤器对象f，同时使<code>index</code>加1，为执行下一个过滤器做准备，然后运行f中的<code>doFilter()</code>方法，当运行完后,再回调执行<code>FilterChain</code>类中的<code>doFiter()</code>方法。以此类推，那么什么时候回调结束呢？当<code>index</code> 值等于<code>ary</code>容器元素长度时，表明所有过滤器对象都已执行完毕，则结束即可。</p><p>本例实现的其实是同步回调。利用多线程可以实现异步回调。</p><p><strong>代码示例</strong></p><p>修改<code>FilterChain</code>如下</p><pre><code>public class FilterChain {    ArrayList&lt;Filter&gt; ary = new ArrayList();    int index = 0;    void addFilter(Filter f) {        ary.add(f);    }    public void doFilter(Request req, Response rep, FilterChain fc) {        if (index == ary.size())            return;        Filter f = ary.get(index);        index++;          // 自定义线程        MyThread th = new MyThread(req, rep, f, fc);        th.start();    }}</code></pre><pre><code>public class MyThread extends Thread {    Request req;    Response rep;    Filter f;    FilterChain fc;    MyThread(Request req, Response rep, Filter f, FilterChain fc) {        this.req = req;        this.rep = rep;        this.f = f;        this.fc = fc;    }    @Override    public void run() {        f.doFilter(req, rep, fc);        System.out.println(rep.rep);    }}</code></pre><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>命令模式的定义如下：将一个请求封装为一个对象，从而使用户可用不同的请求对客户端进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>适合场景：</p><ul><li><p>程序需要在不同的时刻指定、排列和执行请求</p></li><li><p>程序需要提供撤销操作</p></li><li><p>程序需要支持宏操作</p></li></ul><p>命令模式一般有四种角色，如下：</p><ul><li><p>抽象命令者，是一个接口，规定用来封装请求的若干个方法</p></li><li><p>具体命令发送者，是实现命令接口的类的实例</p></li><li><p>请求者，具体命令的管理和维护类。请求者是一个包含“命令接口”变量的类的实例。请求者中的“命令”接口的变量可以存放任何具体命令的引用，请求者负责调用具体命令，让具体命令执行那些封装了请求的方法</p></li><li><p>命令接受者，是一个类的实例，该实例负责执行与请求相关的操作</p></li></ul><p><strong>代码示例</strong></p><pre><code>// 抽象命令者public interface Command {    void execute(); }</code></pre><pre><code>// 命令接受者public class CourseVideo {    private String name;    public CourseVideo(String name) {        this.name = name;    }    public void open() {        System.out.println(this.name+"课程开放");    }    public void close() {        System.out.println(this.name+"课程关闭");    }}</code></pre><pre><code>// 具体命令发送者public class CloseCourseVideoCommand implements Command {    private CourseVideo courseVideo;    public CloseCourseVideoCommand(CourseVideo courseVideo) {        this.courseVideo = courseVideo;    }    @Override    public void execute() {        courseVideo.close();    }}</code></pre><pre><code>// 具体命令发送者public class OpenCourseVideoCommand implements Command {    private CourseVideo courseVideo;    public OpenCourseVideoCommand(CourseVideo courseVideo) {        this.courseVideo = courseVideo;    }    @Override    public void execute() {       courseVideo.open();    }}</code></pre><pre><code>// 请求者public class Staff {    private List&lt;Command&gt; commandList = new ArrayList&lt;&gt;();    public void addCommand(Command command) {        commandList.add(command);    }    public void executeCommands() {        for (Command command : commandList) {            command.execute();        }        commandList.clear();    }}</code></pre><pre><code>public static void main(String[] args) {        CourseVideo courseVideo = new CourseVideo("Java设计模式");        OpenCourseVideoCommand openCourseVideoCommand = new OpenCourseVideoCommand(courseVideo);        CloseCourseVideoCommand closeCourseVideoCommand = new CloseCourseVideoCommand(courseVideo);        Staff staff = new Staff();        staff.addCommand(openCourseVideoCommand);        staff.addCommand(closeCourseVideoCommand);        staff.executeCommands();}</code></pre><pre><code>输出：Java设计模式课程开放Java设计模式课程关闭</code></pre><h2 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h2><p>迭代器模式定义如下：提供一种方法访问一个容器对象中的各个元素，而又不暴露该对象的内部细节，是一种只应用于容器对象遍历的设计模式。</p><p>适合场景：</p><ul><li><p>遍历集合对象，不需要知道对象在集合中的存储方式</p></li><li><p>用户可以同时使用多个迭代器遍历一个集合</p></li></ul><p>JDK中迭代器模式很成熟，它应用在多个容器中。</p><p>下面自己写一个数组的迭代器，不使用JDK自带的迭代器，来说明迭代器模式的使用方法。</p><p><strong>代码示例</strong></p><pre><code>public interface Iterator {    Object next();    boolean hasNext();}</code></pre><pre><code>public interface Collection {    public void add(Object o);    public int size();    public Iterator iterator();    public Iterator reverseIterator();}</code></pre><pre><code>public class MyArrayList implements Collection {    private Object[] elementData;    private int size;    public MyArrayList(int size) {        this.elementData = new Object[size];        this.size = 0;    }    public MyArrayList() {        this(10); //默认创建容器长度为10    }    @Override    public void add(Object o) {        if (this.size == elementData.length) {            int newSize = size * 2;            elementData = Arrays.copyOf(elementData, newSize);        }        elementData[size] = o;        size++;    }    @Override    public int size() {        return size;    }    public Object get(int size) {        return elementData[size];    }    @Override    public Iterator iterator() {        return new ArrayListIterator();    }    @Override    public Iterator reverseIterator() {        return new ReverseIterator();    }    private class ArrayListIterator implements Iterator {        private int currentIndex = 0;        @Override        public boolean hasNext() {            return currentIndex &lt; size;        }        @Override        public Object next() {            Object o = elementData[currentIndex];            currentIndex++;            return o;        }    }    private class ReverseIterator implements Iterator {        private int currentIndex = size - 1;        @Override        public boolean hasNext() {            return currentIndex &gt;= 0;        }        @Override        public Object next() {            Object o = elementData[currentIndex];            currentIndex--;            return o;        }    }}</code></pre><p><code>iterator()</code>方法返回具体的数组容器迭代器<code>ArrayListIterator</code>对象。<code>ArrayListIterator</code>是一个内部类，实现了<code>iterator</code>接口，重写了<code>hasNext()</code>、<code>next()</code>两个容器遍历方法。</p><p>因此，如果需要添加新的容器类，写法和上面相同。</p><pre><code>public static void traverse(Collection c) {    Iterator it = c.iterator();    while (it.hasNext()) {        String s = (String) it.next();        System.out.println(s);    }}public static void main(String[] args) {    Collection c = new MyArrayList(2);    //初始化自定义数组容器    for (int i = 0; i &lt; 5; i++) {        c.add("array" + i);    }    System.out.println("数组容器遍历:");    traverse(c);    Collection c1 = new MyArrayList(2);    //初始化自定义数组容器    for (int i = 0; i &lt; 5; i++) {        c1.add("array" + i);    }    System.out.println("反向迭代器遍历:");    Iterator it = c1.reverseIterator();    while (it.hasNext()) {        String s = (String) it.next();        System.out.println(s);    }}</code></pre><pre><code>输出：数组容器遍历:array0array1array2array3array4反向迭代器遍历:array4array3array2array1array0</code></pre><h2 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h2><p>访问者模式定义如下：表示一个作用于某对象结构中的各个元素的操作。它可以在不改变各个元素的类的前提下，定义作用于这些元素的新操作。</p><p>适合场景：</p><ul><li><p>对集合中的对象增加一些新的操作</p></li><li><p>对集合中的对象进行很多不同且不相关的操作，而又不想修改对象的类</p></li></ul><blockquote><p>有如下应用：已知三点坐标，编写功能类，求三角形的面积和周长</p><p>目前已经确定的需求是面积和周长，但有可能将来要求重心等，因此我们可以用访问者模式</p></blockquote><p><strong>代码示例</strong></p><pre><code>// 抽象需求分析接口interface IShape {    float getArea();        //明确的需求分析    float getLength();        //明确的需求分析    Object accept(IVisitor v);    //可扩展的需求分析}// 具体功能实现类class Triangle implements IShape {    float x1, y1, x2, y2, x3, y3;            //三角形三点坐标    public Triangle(float x1, float y1, float x2, float y2, float x3, float y3) {        this.x1 = x1;        this.y1 = y1;        this.x2 = x2;        this.y2 = y2;        this.x3 = x3;        this.y3 = y3;    }    public float getDist(float u1, float v1, float u2, float v2) {    //求任意两点距离        return (float) Math.sqrt((u1 - u2) * (u1 - u2) + (v1 - v2) * (v1 - v2));    }    @Override    public float getArea() {                //固定需求分析求面积        float a = getDist(x1, y1, x2, y2);        float b = getDist(x1, y1, x3, y3);        float c = getDist(x2, y2, x3, y3);        float s = (a + b + c) / 2;        return (float) Math.sqrt(s * (s - a) * (s - b) * (s - c));//海伦公式求面积    }    @Override    public float getLength() {            //固定需求分析求周长        float a = getDist(x1, y1, x2, y2);        float b = getDist(x1, y1, x3, y3);        float c = getDist(x2, y2, x3, y3);        return a + b + c;    }    @Override    public Object accept(IVisitor v) {    //可扩展需求分析        return v.visit(this);    }}// 定义访问者接口interface IVisitor {    Object visit(Triangle t);}class Point {    float x, y;}// 重心坐标实现类class CenterVisitor implements IVisitor {    @Override    public Object visit(Triangle t) {        Point pt = new Point();        pt.x = (t.x1 + t.x2 + t.x3) / 3;        pt.y = (t.y1 + t.y2 + t.y3) / 3;        return pt;    }}</code></pre><pre><code>public static void main(String[] args) {    IVisitor v = new CenterVisitor();        //定义求重心具体访问者对象    Triangle t = new Triangle(0, 0, 2, 0, 0, 2);    //定义三角形对象    Point pt = (Point) t.accept(v);            //通过访问者对象求三角形重心坐标    System.out.println(pt.x + "\t" + pt.y);}</code></pre><p>如果我们再想增加一个求三角形外接圆半径的功能，只需再定义一个新类实现<code>IVisitor</code>接口。</p><p>上面存在一个问题，当我们需要新增N个功能时，就必须创建N个具体访问者类，这样会让代码很臃肿，利用反射可以解决这个问题。</p><pre><code>interface IShape {    float getArea();        //明确的需求分析    float getLength();        //明确的需求分析    Object accept(IVisitor v, String method);    //可扩展的需求分析}class Triangle implements IShape {    float x1, y1, x2, y2, x3, y3;            //三角形三点坐标    public Triangle(float x1, float y1, float x2, float y2, float x3, float y3) {        this.x1 = x1;        this.y1 = y1;        this.x2 = x2;        this.y2 = y2;        this.x3 = x3;        this.y3 = y3;    }    public float getDist(float u1, float v1, float u2, float v2) {    //求任意两点距离        return (float) Math.sqrt((u1 - u2) * (u1 - u2) + (v1 - v2) * (v1 - v2));    }    @Override    public float getArea() {                //固定需求分析求面积        float a = getDist(x1, y1, x2, y2);        float b = getDist(x1, y1, x3, y3);        float c = getDist(x2, y2, x3, y3);        float s = (a + b + c) / 2;        return (float) Math.sqrt(s * (s - a) * (s - b) * (s - c));//海伦公式求面积    }    @Override    public float getLength() {            //固定需求分析求周长        float a = getDist(x1, y1, x2, y2);        float b = getDist(x1, y1, x3, y3);        float c = getDist(x2, y2, x3, y3);        return a + b + c;    }    @Override    public Object accept(IVisitor v, String method) {        return v.visit(this, method);    }}interface IVisitor {    Object visit(Triangle t, String method);}class Point {    float x, y;}class CenterVisitor implements IVisitor {    public Object getCenter(Triangle t) {        Point pt = new Point();        pt.x = (t.x1 + t.x2 + t.x3) / 3;        pt.y = (t.y1 + t.y2 + t.y3) / 3;        return pt;    }    @Override    public Object visit(Triangle t, String method) {        Object result = null;        try {            Method mt = this.getClass().getMethod(method, Triangle.class);            result = mt.invoke(this, new Object[]{t});        } catch (Exception e) {            e.printStackTrace();        }        return result;    }}</code></pre><pre><code>public static void main(String[] args) {    IVisitor v = new CenterVisitor();        //定义求重心具体访问者对象    Triangle t = new Triangle(0, 0, 2, 0, 0, 2);    //定义三角形对象    Point pt = (Point) t.accept(v, "getCenter");        //通过访问者对象求三角形重心坐标    System.out.println(pt.x + "\t" + pt.y);}</code></pre><p><code>t.accept(v, "getCenter");</code>一个类中多个方法只需要写出方法名即可调用，不用创建过多类。</p><h2 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h2><p>中介者模式是指用一个中介者对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p><p>适合场景：</p><ul><li><p>许多对象以复杂方式交互，所导致的依赖使系统难以维护</p></li><li><p>一个对象引用其他很多对象，导致难以复用该对象</p></li></ul><blockquote><p>对于中介者模式，这里只举一个例子，不再展示代码了。</p><p>比如房屋中介实现：</p><ul><li>租房者发布租房信息给房屋中介，房屋中介将收到的信息发布给所有出租房屋者；</li><li>出租房屋者发布信息给房屋中介，房屋中介将收到的信息发布给所有租房者。</li></ul></blockquote><h2 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h2><p>备忘录模式指在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可将该对象恢复到原先保存的状态。</p><p>适合场景：</p><ul><li><p>必须保存某对象在某一时刻的部分或全部状态信息，以便对象恢复到该时刻的运行状态</p></li><li><p>一个对象不想通过提供public权限的方法让其他对象得到自己的内部状态</p></li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><p>代理模式的定义如下：为其他对象提供一组代理以控制对这个对象的访问。</p><p>适合场景：</p><ul><li><p>不希望用户直接访问该对象，而是提供一个特殊的对象以控制对当前对象的访问</p></li><li><p>对象需要很长时间才能加载完成</p></li><li><p>对象位于远程主机上，需要为用户提供远程访问的能力</p></li></ul><p>代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户端不能看到的内容和服务或者添加客户端需要的额外服务。</p><p>代理模式是给一个对象提供一个代理<code>Proxy</code>，由代理对象控制对原对象的引用。</p><p>代理模式包含如下角色：</p><ul><li><code>ISubject</code>：抽象主题角色，是一个接口，该接口是对象和它的代理所共用的接口</li><li><code>RealSubject</code>：真实主题角色，是实现抽象主题接口的类</li><li><code>Proxy</code>：代理角色，内部含有对真实对象<code>RealSubject</code>的引用，从而可以操作真实对象。代理对象提供与真实对象相同的接口，以便在任何时刻都能代替真实对象，同时，代理对象可以在执行真实对象操作时，附加其他的操作，相当于对真实对象进行封装</li></ul><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PropertiesUtil通用配置文件工具类</title>
      <link href="/2019/08/10/propertiesutil-tong-yong-pei-zhi-wen-jian-gong-ju-lei/"/>
      <url>/2019/08/10/propertiesutil-tong-yong-pei-zhi-wen-jian-gong-ju-lei/</url>
      
        <content type="html"><![CDATA[<h2 id="PropertiesUtil工具类"><a href="#PropertiesUtil工具类" class="headerlink" title="PropertiesUtil工具类"></a>PropertiesUtil工具类</h2><p>记得引入<code>org.apache.commons.lang</code>包</p><p>使用说明（以SpringBoot为例）：</p><p>1.在resource包下创建application.properties(没有的话)</p><p>2.创建你自己的配置文件，名字随意，文件中以<code>key=value</code>的形式填写</p><p>3.在application.properties中填写<code>feichaoyu=你创建的配置文件名</code>，如果有多个，以逗号隔开</p><p>4.调用方式<code>PropertiesUtil.getProperty("你的配置文件名","键名","是否带默认值")</code></p><pre><code>import org.apache.commons.lang.StringUtils;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.io.IOException;import java.io.InputStreamReader;import java.util.HashMap;import java.util.Map;import java.util.Properties;import java.util.Set;public class PropertiesUtil {    private static Logger logger = LoggerFactory.getLogger(PropertiesUtil.class);    private static Map&lt;String, Properties&gt; proFileSet = new HashMap&lt;&gt;();    private static Properties props = new Properties();    static {        // 先加载application.properties获取所有自定义配置文件        String fileName = "application.properties";        try {            props.load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(fileName), "UTF-8"));            String value = props.getProperty("feichaoyu");            if (StringUtils.isNotBlank(value)) {                String[] fileNames = value.split(",");                for (String name : fileNames) {                    if (StringUtils.isNotBlank(name)) {                        proFileSet.put(name.trim(), new Properties());                    }                }            }        } catch (IOException e) {            logger.error("application.properties读取自定义配置文件异常", e);        }        // 加载自定义配置文件        for (String key : proFileSet.keySet()) {            try {                proFileSet.get(key).load(new InputStreamReader(PropertiesUtil.class.getClassLoader().getResourceAsStream(key), "UTF-8"));            } catch (IOException e) {                logger.error("自定义配置文件读取异常", e);            }        }    }    public static String getProperty(String profile, String key) {        Properties props = match(proFileSet, profile);        if (props == null) {            return null;        }        String value = props.getProperty(key.trim());        if (StringUtils.isBlank(value)) {            return null;        }        return value.trim();    }    public static String getProperty(String profile, String key, String defaultValue) {        Properties props = match(proFileSet, profile);        if (props == null) {            return null;        }        String value = props.getProperty(key.trim());        if (StringUtils.isBlank(value)) {            value = defaultValue;        }        return value.trim();    }    // 根据key查找map中符合要求的value    public static &lt;T&gt; T match(Map&lt;String, T&gt; map, String key) {        if (StringUtils.isBlank(key)) {            return null;        }        for (String k : map.keySet()) {            if (key.equals(k)) {                return map.get(k);            }        }        return null;    }}</code></pre><script>        document.querySelectorAll('.github-emoji')          .forEach(el => {            if (!el.dataset.src) { return; }            const img = document.createElement('img');            img.style = 'display:none !important;';            img.src = el.dataset.src;            img.addEventListener('error', () => {              img.remove();              el.style.color = 'inherit';              el.style.backgroundImage = 'none';              el.style.background = 'none';            });            img.addEventListener('load', () => {              img.remove();            });            document.body.appendChild(img);          });      </script>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PropertiesUtil </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
